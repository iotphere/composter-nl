Tamam, senin senaryonu netleştirelim:

Raspberry Pi çalışıyor

Kendi microSD’si (OS kurulu, Pi Connect dahil) ana yuvasında takılı

Boş microSD USB kart okuyucuya takılı, Pi’ye bağlı

SSH ile bağlandın, ekran yok, sadece terminal var

Amacımız: kaynak kartı → hedef karta birebir kopyalamak (byte-by-byte)

Bunu yapmanın en pratik yolu Pi OS’in kendi içinde zaten bulunan sdcard kopyalama yöntemi — ama ekran olmadığı için GUI “SD Card Copier” yok. Biz komut satırı üzerinden dd ile yapacağız.

1️⃣ Hangi disk hangi cihaz?
Önce cihaz isimlerini bulmamız lazım:

bash
Kopyala
Düzenle
lsblk
Çıktıda şuna benzer bir şey göreceksin:

pgsql
Kopyala
Düzenle
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
mmcblk0     179:0    0 29.8G  0 disk 
├─mmcblk0p1 179:1    0 256M   0 part /boot
└─mmcblk0p2 179:2    0 29.5G  0 part /
sda           8:0    1 29.8G  0 disk 
├─sda1        8:1    1 256M   0 part
└─sda2        8:2    1 29.5G  0 part
mmcblk0 → Pi’nin kendi OS kartı (kaynak)

sda → USB üzerinden takılan boş kart (hedef)

Burada isimler değişebilir, o yüzden kopyalamadan önce hangi kartın hangisi olduğunu kesin olarak doğrula. Yanlış yaparsan kendi sistemi silebilirsin.

2️⃣ Kopyalama işlemi
Terminalde:

bash
Kopyala
Düzenle
sudo dd if=/dev/mmcblk0 of=/dev/sda bs=4M conv=fsync status=progress
Açıklama:

if= → input file = kaynak kartın cihaz adı

of= → output file = hedef kartın cihaz adı

bs=4M → 4 MB blok boyutu (hız için)

conv=fsync → yazma işlemini güvenli şekilde bitirir

status=progress → ilerlemeyi gösterir

3️⃣ Bitince veri senkronizasyonu
bash
Kopyala
Düzenle
sync
Bu komut RAM’de bekleyen tüm disk yazmalarını tamamlar.

4️⃣ Test (opsiyonel)
Hedef kartı çıkar, Pi’ye tak ve çalışıp çalışmadığını gör. Eğer Pi Connect kuruluyduysa hiçbir şey değişmemiş gibi bağlanacaksın.

💡 Notlar:

Kopyalama işlemi kartın kapasitesine göre uzun sürebilir (16–32 GB için 5–15 dakika).

Hedef kart, kaynak karttan en az aynı boyutta olmalı (marka farkı yüzünden bazı 32 GB kartlar aslında 31.8 GB oluyor, bu uyumsuzluk olabilir).

Eğer daha küçük karta kopyalamak istersen, önce kaynak karttaki partition’u küçültüp imajı alman gerekir.


------------------
msg.payload={
  method: <string>,
  params: {
    subject: <string>,
    body: <misc>,
    attach: <misc>
  }
}
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}

{
  "method": "settings",
  "params": {
    "subject": null,
    "body": "body": {"timers": {"fsm": {"end_timer": {"pulse": {"t_on": 10}}}}},
    attach: null
  }
}


{"subject": null, "body": {"timers": {"fsm": {"end_timer": {"pulse": {"t_on": 10}}}}}}
-------------------------------------------------------------
tekrar merhaba,

sinamic motor sürücülerinde motorun hızı 0-16384 arası bir değeri modbus'tan anlık olark göndererilerek belirlenebiliyor.

flow_context'te şunlar vardı;
settings>sinamics>sinamics-actuator-name>speeds>low (8192 vardı)
settings>sinamics>sinamics-actuator-name>speeds>full (16384 vardı)
örneğin sinamics-actuator-name olarak hatch için aşağıdaki mesaj çıkıyordu;
{
  "method": "default",
  "params": {
    "subject": "hatch",
    "body": "speed",
    "attach": "low"
  }
}
flow_context'te;
şu eklemeyi yaptım;
config>actuators>sinamics>max_speed (sinamics'lere özgü 16384 değerini yazdım)
ayrıca speeds alanını kaldırdım ve onun yerine şunu koydum;
settings>sinamics>sinamics-actuator-name>speed (0-100 arası bir değer).

0-100'e karşılık 0-max_speed scale edilecek.
mesaj şöyle çıkacak;
{
  "method": "default",
  "params": {
    "subject": "hatch",
    "body": "speed",
    "attach": <0-max_speed arası değer>
  }
}

const flowData = flow.get("flow");
const max_speed = flowData.config?.actuators?.sinamics?.max_speed ?? 16384;
const hatch_speed = ((flowData.settings?.sinamics?.hatch?.speed ?? 100) / 100) * max_speed;
const fan_speed = ((flowData.settings?.sinamics?.fan?.speed ?? 100) / 100) * max_speed;
const water_pump_speed = ((flowData.settings?.sinamics?.water_pump?.speed ?? 100) / 100) * max_speed;
const discharger_speed = ((flowData.settings?.sinamics?.discharger?.speed ?? 100) / 100) * max_speed;


özel durum.

{
  "method": "settings",
  "params": {
    "subject": "get",
    "body": <json>,
    "attach": null
  }
} bunun responsu mu
{
  "method": "settings",
  "params": {
    "subject": "set",
    "body": <json>,
    "attach": null
  }
} bud rumda neler yapmalı?

{
  "method": "settings",
  "params": {
    "subject": "set",
    "body": <json>,
    "attach": "speed"
  }
} bud rumda neler yapmalı?

payload: {
    method: "default",
    params: {
        subject: actuatorName,
        body: "speed",
        attach: realSpeed
    }
}

şimdiye kadar thingsboard'dan gelen settings method'lu mesajlarda subject kısmı hep null değerindeydi, doğru mudur? ekleyeceğimiz özellik sayesinde thingsboard bizim flow context'ten veri isteyebilecek. bundan böyle thingsboard'dan gelen settings method'lu mesajların subject'inde set veya get olacak mutlaka.
öncelikle şunu yapalım, settings method'lularda şimdiye kadar yaptığı işleri yalnızca gelen mesajın subject'tinde set varsa yapsın, koda bunu ekleyelim. bir sonraki adımda get ile ne yapacağına bakalım.. 
--------------------------------
merhaba, raspberry pi'de node red yüklü ve node-red-contrib-modbus paketi yüklü. mqtt de kullanıyorum.
şu ana kadar 8 adet fonksiyon nodu kullandım, kodları çalışıyor.
fakat mesaj yapısında ve bazı yaklaşımlarda köklü değişim yaptım.
ya kodları sıfırdan yazalım ya da revize edelim.
bu konuda yol göstereceğim. öncelikle sana flow_context adlı fonksiyon nodunun js kodunu gönderiyorum, esas herşey burada tanımlı ve üzerinden işleyecek.
genel kural olarak nodlarda küçük geçici runtime işlerdeki hafıza gereksinimi için nod context'i kullanalım.
diğer faydalı runtime değerler'i flow_context'in runtime kısmı ile etkileşimli olarak çözelim.
bir nod mesaj çıkarmadan önce flow context'te varsa yapması gereken güncellemeyi yapar.
flow'daki 8 fonksiyon nodunun listesi:
flow_context; 
girişine bağlı olan bir inject ile her node red restartında flow context'ini elle yüklüyorum.
daha sonra settings.js'de diske yazan kalıcılık ayarını yaptığımda bu noda gerek kalmayacak. 
digital_inputs_modbus 
analog_inputs_modbus
energy_meter_modbus
fsm
fsm_timer
actuators_timer
actuators_modbus
flow genelinde geçerli olacak sabit bir mesaj yapımız var, hiç topic kullanmıyoruz.
msg.payload={
  method: <string>, // settings | runtime
  params: <json> // full path in flow context
}  
bir kaç istisna dışında daima bu mesaj yapısı olacak, istisna durumları önceden bildireceğim sana.
hazır mısın?





actuators_modbus

snake_case yazım kullanıyorum, sen kendi ürettiğin/geçici terimlerde camelCase kullan, böylece birbirimizi ayırabilelim.
flow'da supervisor olarak çalışan context_manager ve mqtt_manager fonksiyon nodları bulunur.
flow context'inin config alanına asla yazılmaz, settings ve live alanlarına da yalnızca context_manager yazabilir.
context_manager'ın gerekli nodlara bağlantıları var, onlardan gelen mesajlara göre settings ve live alanlarına yazar.
settings alanına yazılacak olanlar yalnızca mqtt_manager'dan gelir.
genel kural olarak flow context'i asla boşyere ve sık meşgul edilmez, hiçbir periyodik yazma işlemi olmamalıdır.
nodlar asla flow context'ine yazamazlar, yalnızca config ve settings kısımlarından okuyabilirler, live'de okuyamazlar.
nodlar kendi iç işleri için, hafıza gereksinimleri için, yalnızca kendi node context'lerini kullanırlar.

---------------------------------------------
tamamdır, sıfırdan yazalım. digital_inputs ile başlayalım.
girişine bir modbus flex getter nodu bağlı ve her 100ms'de bir mesaj geliyor. 
gelen mesaj 16 bitlik tek bir sayı içeren array.
config alanındaki bit_map ve label_map'e bakarak mesajı çıkaracak.
çıkacak örnek mesaj payload'u(1 bit için);
{
  method: "runtime",
  params: {
    io: {
      digital_inputs: {
        oxygen: "on"
      }
    }
  }
}
önce bir double-check parazit filtresi yapar ve yalnızca değişim olan bit(ler) varsa o durumda mesaj çıkarır, aynı anda birden fazla bit değişmişse, ardarda ayrı ayrı mesajlar çıkarır her bit için, bit_map sırasına göre.
yani bir değişimin geçerli sayılması için en az ardarda 2 mesajda değerinin aynı gelmesi gerekir, bir tür validation onayı diyelim, parazit değilmiş anlamında. 
ve bu periyodik işteki hafıza gereksinimi için kendi nod context'ini kullanır, ger 100ms'de bir flow context'ini meşgul etmez, zaten geçici bir kullanım, faydalı bilgi değeri yok.
eğer mesaj çıkacaksa yani en az bir bitlik değişim varsa önce flow context'te runtime alanındaki biti(leri) günceller, sonra mesajını çıkarır.
flow context'ini full path kullanarak kolayca günceller umuyorum. 
genel not: gönderdiğim flox_context'te şu an aynı ögeler için değerler hep aynı ama bunların sonra elbette gerçek farklı değerini yazcağım. 
---------------------------------------
tamamdır, kodları daha sonra test edeceğim.
aynı yaklaşımla analog_inputs_modbus'a geçelim şimdi.
analog_inputs_modbus'a modbus flex getter'dan 8 sayısal değer geliyor array olarak, register_map ve label_map kullan.
parazit filtresi ve değişim onayı için tolerans kullanalım analog değerler olduklarına göre.
ayrıca bir de factor ile çarpalım, tüm registerler için aynıdır. 
-----------------------------------------
flow'da önemli değişikler yapmak istiyorum.
1.
flow mesaj akışı için bir adres sistemi belirledim.
bundan böyle payload'ların method alanında mesajın ulaşmasını istediğim fonksiyon nodunun adı olacak.
{
  method: <nod_adı>,
  params: {...}
}
adına gönderilmediyse çıkışa paslayıp return ile çıkacak.
adına ise kodu devam ettirecek.
2.
flow context'ini daha sade ve kullanışlı hale getirmeye çalıştım, daha fazla runtime odaklı.
örneğin bit_map, register_map gibi kısımlara ayrıca gerek yok.

eski flow_context js kodunu tamamen unut, yenisini gönderiyorum.
daha önce yazdığın digital_inputs, analog_inputs, energy_meter fonksiyon kodlarını da yeni_flow_context'e göre revize etmeliyiz sonraki adımlarda.
ve hatta bu kodları gerekirse bir de optimize et hazır dokunmuşken.

ilk olarak flow_context kodunu göndereceğim hazır mısın..
-----------------------------------
genel olarak flow'un node red restart'ından(restart/power reset/boot) etkilenmiyor olmasını, restore olmasını istiyorum, olabildiğince.
node red settings.js'de contextStorage için localfilesystem aktif edeceğim, böylece node red context'leri arka planda her flushinterval periyodu geldiğinde (default 30s) diske diske yazıp periyodik olarak saklar.
biz bir context'e örneğin her saniye yazsak da flushinterval periyodu gelmeden diske yazılmıyor, yani en kötü 30 saniyelik bir sapma olur restore'larda, makuldur.
bunu belirttim çünkü genel olarak flow'daki timer'ları da kendimiz ve kalıcı olarak tasarlamalıyız.
çünkü uzun süreli zamanlamalar için kalıcılık gerekli.
inject veya delay gibi node red'in kendi nod'ları restart durumunda kalıcı değiller. 
ve artık tek bir timer fonksiyon nodu olacak, sana önceden isimlerini belirtmiş olduğum actuators_timer ve fsm_timer nodlarını iptal ettim.
timer nodu fsm noduyla mesaj alışverişi, actuators_modbus'a ise yalnızca gönderecek.
kısaca yapacağı iş; gelen mesajı zamanlayıp çıkıştan iletir.
biliyorsun flow'daki mesaj yapımızda params kısmında flow context'indeki full path'i belirtmeye özen gösteriyoruz.
böylece mesajı alan nodun yapacağı iş ve güncellenecek flow context ile ilgili bilgi iletmiş oluyoruz, sanırım böyle söylemek yanlış olmaz evet.
neyse genellemeler bazen hatalı olabilir biz net adımlarla ilerleyelim.

timer noduna gelecek olan örnek bir mesaj ve yapılacak işler:
{
  method: "fsm",
  params: {actuators: {timers: {timer_1: {action: "stop"}, timer_2: {action: "stop"}, timer_3: {action: "stop"}, timer_4: {action: "run"}}}}
}
flow context'teki diğer hatch timer'ları(timer_1,2,3) kapatılacak, onların herbiri için flow_context'te action: "stop" olarak güncellenecek.
timer_4 için flow context'te action: "run" olarak güncellenip, timer_4 başlatılacak.
timer_4 bir pwm timer olduğundan ilk olarak on phase'ine geçecek.
hemen şu mesaj çıkacak;
{
  method: "fsm",
  params: {actuators: {sinamics: {hatch: {action: "forward_run"}}}}
}
on süresi dolduğunda şu mesaj çıkacak;
{
  method: "fsm",
  params: {actuators: {sinamics: {hatch: {action: "forward_run"}}}}
}

bir başka örnek mesaj:
{
  method: "fsm",
  params: {fsm: {timers: {timer_2: {active: true}}}}
}
timer nodu 2 çıkışlı olacak, 1 nolu çıkış fsm'ye, 2 nolu çıkış ise actuators_modbus'a mesaj gönderecek biçimde bağlılar.



iki port çıkışlı.
aşağıda timer tiplerini (type) görebilirsin.
always; gelen mesajı anında iletir.
pulse; gelen mesajı anında iletir ve t_on süresi sonunda 

, pulse, delay, pwm. 
küçük işler nod context, diğerleri dışardan takip edilsin.
thingsboard rpc initial.

---- timer on start context'te map yap, şu an 35 adet
flow context'e yeni timer ekle/çıkar yapıp node red restart yaptığımda on start sayesinde bu map oluşur ve timer koduna hiç dokunmama gerek kalmaz.

flow'da yalnızca fsm_timer ve actuators_timer nodları timer içeriyor olacak.
4 ayrı timer tipi olacak; always, pulse, loop, pwm.
zamanlamalara göre ve tipine göre phase değişimlerinde mesaj çıkaracaklar.
gelen başlat/durdur mesajları ile ilk mesaj çıkışı başlar.
esnek düşün.
fsm_timer run/stop komutları alır, actuators_timer ise run/forward_run/reverse_run/stop komutları alır.

genel kuralımız şöyledir; timer nod'larından çıkan mesajlar, gelen başlat/durdur komutunu  
always aslında timer olmasa da timer kategorisine almış oldum, elbette kendiliğinden stop olmaz.
pulse, bir süre sonunda stop mesajı çıkarır.
loop, periyodik olarak run mesajı çıkarır.
pwm, phase geçişlerinde mesaj çıkarır(yeni phase'i çıkarır).
flow_context'in settings kısmındaki timer değerleri saniye birimindedir, yani saniye'lik hassasiyet benim için yeterli.
kalıcı timer tasarlamak için aklımda 3-4 farklı yol var ama sana bırakıyorum, istediğin gibi yap.
eğer dışardan timer tick mesajı da gelmesini istiyorsan bana bildir, flow'a 1 saniye periyod'lu bir inject nodu eklerim, hem actuators_timer'ın ve hem de fsm_timer'ın girişine bağlarım.
inject'ten nod'lara her saniye giden mesaj şöyle olur;
{
  method: "runtime",
  params: {
    tick: true
  }
}
timer'larda on/off terimleri kullanma.


benim içim şu yeterlidir; timer'lar her başlatıldığında flow context'e bir timestamp yazalım, power reset sonrası timestamp'ten geçen süreye baksın.
tabi çok uzun elektrik kesilmelerinde, geride kalan ve yapması gerekip de yapmamış olacağı zamanlamalı işleri yok saymış olur, olsun mühim değil.
yani aklımda 3-4 çeşit ve daha hassas/detaylı kalıcı timer yaklaşımı var ama bu söylediğim en basit olanı yeterlidir.
bu timestamp alanlarını özellikle flow context'inde oluşturdum ki kalan süre dışardan kalan süre vb. 


fsm_timer'a 2 yerden mesaj geliyor;
1) 1hzlik tick mesajı(payload), şöyle kabul edelim, yeterlidir.
{
  method: "runtime",
  params: {
    tick: true
  }
}
2) fsm nodundan, örnek.
{
  method: "runtime",
  params: {
    fsm: {      
      timers: {
        end_timer: {
          actions: "stop" // stop | run
  }
}
timer'ları kalıcı olarak tasarlamalıyız, recovery olabilmeli.
bunun için 3-4 yöntem var aklımda.
fakat en sade olanı yapalım, evet elektrik uzun süre kesildiğinde, yapması gereken işi atlamış olacak o timer'la çalışan ögeler ama sorun değil.
"forever" tipi zaten timer sayılmaz. 
pulse tipi başlatıldığında, pwm tipi ise her on/off faz geçişinde olmak üzere, bir timestamp kaydetsin, yani her tick'te kaydetmeye gerek yok.
flow context'in runtime'ına ben ilave timer'lar için timestamp alanları ekleyeceğim birazdan, şu alanlar uygun mudur?
(hatırlatma: herhangi bir actuator için aynı anda yalnızca 1 timer çalışabilir.)

sanırım date.now() ve elapsed time

ister javascript'teki settimeout vb. fonksiyonları kullanalım isterse date.now() ve elapsed time olsun, timer'ları kalıcı olarak tasarlamalıyız.
gelen her tick'te context'te kayıt tutmalıyız, ki recovery olabilsin.
bu kaydı flow context'te tutalım ki  
---------------------------------------
merhaba, 
raspberry pi node red ile bir flow oluşturmak istiyorum.
node-red-contrib-modbus paketi yüklü.

genel açıklama yapmak isterdim fakat çok uzun sürecek.
o nedenle flow'daki fonksiyon nodlarını adım adım oluşturalım.
ilk olarak hazır haldeki flow_context'i göndereyim ki içerik anlaşılsın.
daha sonra bazıları için önceki tecrübemden kodlar gönderip revize etmeni isteyeceğim flow_context'e göre.
bazılarını ise sıfırdan yazmanı.

hazırsan flow context'i göndereyim..
----------------
tamamdır, tüm fonksiyon nodlarında genel yaklaşımımız şöyle olsun.
küçük işlerde hafıza gereksinimi node context ile karşılanır, tüm faydalı bilgiler ve ön plana çıkacak olanlar runtime üzerinde işlem görür.
flow context yapısı korunur, nested yapı, içindeki datakey'ler, hiçbir şey değişmez, eklenmez, çıkarılmaz. 
ileriki adımlarda, örneğin kalıcı (persistence) timer'lar için runtime alanına ilave datakey'ler eklenecek. 
gönderdiğim kodlardaki notasyon iptal edilip, tümüyle flow_context'teki notasyon kullanılacak, örneğin, bit, map, register notasyonları yerine channels notasyonu gibi.
flow'da hiçbir zaman topic kullanılmayacak.
tüm mesajlarda yapı aşağıdaki gibidir, method daima string, params daima object:
msg.payload={
  method: <string>,
  params: {....}
} 

şimdi digital_inputs_modbus fonksiyon nodu ile başlayalım.
bu noda her 100ms'de bir flex getter'dan array içinde tek bir sayı gelir.
göreceğin gibi ardarda 2 değerin aynı olması istenerek bir parazit filtresi var.
ve değişen channel(s) varsa her biri için ayrı mesaj çıkar.
değişim yoksa asla mesaj çıkmaz.
çıkacak mesaj yapısı şu örnek gibi olsun:
msg.payload={
  method: "oxygen_detector",
  params: {state: "on"}
}

digital_inputs_modbus fonksiyon nodu:
-------------------------------------------------
önce şu bilgiyi senle paylaşmalıyım.
evet flow'un node red restart'ından(power reset/reboot) mümkün olduğunca etkilenmemesini istiyorum.
bir miktar zaman sapması makul kabul edilir.
settings.js'de şunu yapacağım:
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
node red tüm context'lerin global(kullanmıyoruz)/flow/node, her 30 saniyede bir(flushinterval) anlık güncel halini diske kaydeder.
bu işlemi arka planda yapar, kendi bağımsız zamanlamasıyla.
örneğin flow contet her 1 saniyede güncelleniyor da olsa, diske yalnızca bir sonraki flushinterval geldiğinde en güncel hali kaydedilir.
node red restart olduğunda, flow en kötü senaryoda power down'dan 30 saniye öncesindeki runtime değerleri ile yeniden çalışmaya başlayacaktır.
bu benim için makul bir süredir. 
peki ya timer'lar?
node red'in timer özelliği olan inject/delay gibi nodları restart durumunda sıfırlanır, kalıcı değiller.
şimdi timer_manager adlı fonksiyon noduna geçelim.
zamanla alakalı tüm işler bu nodda olacak.
ileride kurguladığım fsm adlı fonksiyon nodunun yükü almak için, timer_manager'ı dummy delay timer olarak değil de bir görev zamanlayıcı gibi tasrlamanı istiyorum.
delay/pwm/loop olarak 3 tipte ve birbirlerinden bağımsız, özel adları olan, ön tanımlı görevleri olan, kalıcı timer'lar işleyecek bu nodda.
bu nod bir injenct tarafından tick biçiminde her 1 saniyede tetikleniyor olacak.
date.now yöntemi ile kalıcı timer'lar gerçekleştirilecek.
her tick'te, o an state="on" olan timer'lar flow context'in runtime kısmında kendi alanlarındaki anlık zaman değerlerini güncelleyecek.  
örneğin flow_context'teki fan_pwm_mid: {state: "off", phase: null, x: 0, y: 0,...} alanına.
bu alanlara eklenecek x,y... key'leri bana da bildir lütfen.
pwm için phase_a, phase_b notasyonunu kullanalım, phase_a ile başlar.
t_duty değeri phase_a süresidir. t_cycle değeri ise phase_a + phase_b yani toplam tekrar periyodu süresidir.
timer'lar on/of ve phase_a, phase_b değişimleri ve diğer kalıcılık/takip bilgilerini daima runtime alanında kendileri günceller.
peki timer_manager nodu nasıl mesajlaşacak, tick haricinde gelen diğer mesajlarda ne yapacak?
özetle gelen mesajdaki method'a karşılık, ön tanımlı methodları olan zamanlanmış mesajlar üretecek. 
delay tipi 2 defa mesaj çıkarır; başladığında ve duration süresi dolduğunda.
loop tipi; başladığında ve her intervalde.
pwm tipi; başladığında ve her phase geçişinde mesaj çıkarmaya devam ederek.

bu durumda sanırım sana bir tablo halinde gelen mesaj ve karşılığında çıkan mesajları açık açık yazmalıyım.
şimdilik konsept bu, tabloyu hazırlamaya çalışıyorum..
----------------------------
şimdi timer_manager konusunda önümde 2 seçenek var;
A) senin önerdiğin dummy timer yaklaşımı.
msg.payload = {
  method: "<timer_ismi>",       // örn: fan_pwm_mid
  params: { state: "on" | "off", phase?: "phase_a" | "phase_b" }
}
yani yalnızca kendinden bahseden mesajlar çıkaran timer.
B) mesaj(görev) zamanlayıcı, bir tür time base driver gibi, veya node red'in delay nodu gibi düşünelim ön tanımlı mesaj var, bu mesajı zamanlıyor.

SEÇİM:
Ben B seçeneği diyorum;
yani mesaj zamanlayıcı, benim fsm nodunda ve ileride mqtt nodunda, timer_manager'dan gelen mesajları timer konusundan soyutlanmış ve tıpkı diğer event'lar gibi değerlendirebilmemi sağlacak olan, ve zamanla alakalı tüm işlevleri timer_manager'da tutan, bir driver/scheduler gibi çalışıp diğer nodları yükten kurtaran.
zaten timer isimlerini görüyosun, hep özel işlere göre isimlendirdim.

şimdi yol haritam şöyle;
1)
önce timer tiplerine göre verdiğin yeni key'leri her bir timer için flow_context koduna yerleştireceğim.
benim B seçeneğine geçmemden sonra bu ilave key'lerde bir değişiklik söz konusu ise bana bildir lütfen.
2)
config>timers alanında her bir timer'ın kendi alanında bir pass: {} objesi içinde o timer'a özel olarak, timer'ın hangi durumunda hangi mesaj çıkacağını ön tanımlı hale getireceğim.
timer'a bir start komutu gelecek ve timer kendini state="on" yapıp göreve başlayacak. 
delay tipi timerlarda 2 mesaj olacak, bunlar birer defa çıkmış olacak;
pass: {on: {method:<method>, params: {<params>}}, off: {method:<method>, params: {<params>}}}
pwwm tipi timerlarda 2 mesaj olacak, bunlar döngü halinde çıkmaya devam edecek;
pass: {phase_a: {method:<method>, params: {<params>}}, phase_b : {method:<method>, params: {<params>}}}
loop tipi timerlarda 1 mesaj olacak, bu döngü halinde çıkmaya devam edecek;
pass: {loop: {method:<method>, params: {<params>}}}

şu ayrıntıları da tekrar vericem.
timer start'ta hemen ilk mesaj çıksın mı, şu an için evet diyorum.
bir timer state="on" iken zorla durdurmak için stop mesajı gelirse ne mesajı çıkarsın, buna da bakarım.

unuttuğum bir şey var mı bilmiyorum, bu planıma ne dersin, kullanışlı mı?







method kısmı aynen korunacak.

harika,
ve benim aşağıdaki timer'larda düzeltme yapmam gerekiyor, çünkü aslında bunlar type: "down_counter" olmalıydı.
ve her decriment'te mesaj çıkarmalıydı.
config>timers alanında bunlar için şöyle değişiklik yaptım:
end_day_counter: {type: "down_counter", interval: 1, base: 21, unit: "d"},
dry_day_counter: {type: "down_counter", interval: 1, base: 3, unit: "d"},
runtime alanında ise şöyle değişiklik yaptım:
end_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
dry_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
örneğin end_day_counter 21'den aşağı sayıyor ve her sayıda bir mesaj çıkarıyor olacak, yani down_counter'ın mesajı dinamik.
start verildiğinde içinde 21 olan mesaj çıkaracak, son mesaj'ın içinde sıfır olacak ve timer kendini kapatacak(state: "off").
config ve runtime olarak key'ler doğru mu, uygun mu?
tabi tüm timer'lar için config kısmındaki pass mesajlarını hazırlamaya devam ediyorum.
delay, pwm, loop, down_counter olarak 4 tip timer oldu böylece.

config>timers:
end_day_counter: {type: "counter", direction: "down", interval: 1, base: 21, unit: "d"},
dry_day_counter: {type: "counter", direction: "down", interval: 1, base: 3, unit: "d"},
runtime alanında ise şöyle değişiklik yaptım:
end_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
dry_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
------------------------------
tekrar merhaba,
birazdan flow_contex'i yeni haliyle sana göndereceğim.
not: config>io alanında bazı geliştirmeler yaptım.
şimdilik o alanı hiç dikkate alma, çünkü öncelikle timer_manager'a odaklanmalıyız.
hazırsan flow_contex'i göndereyim.
ve hemen bir sonraki adımda timer_manager açıklamasını göndereceğim.

timer_manager açıklaması:
iyice düşünüp gereksiz timer'ları sildim, tabi yine; delay, pwm, loop, counter olarak 4 tip var.
timer'lar birer mesaj(görev) zamanlayıcı yani scheduler gibi çalışacak.
config>timers alanında her bir timer için ön tanımlı mesajlar var, pass alanlarında.
timer_manager 3 çıkış portlu bir fonksiyon nodudur, pass alanlarında hangi mesajın hangi porttan gönderileceğini belirttim.
tabi ki gönderilecek mesajda port: keyleri olmayacak.
timer_manager noduna timerlar için start mesajları gelecek ve nod zamanlanmış mesajlar göndermeye başlayacak, örneğin;
{
  method: "timer_start",
  params: {target: "water_pump_pwm"}
}
timer_start o timerı resetleyip başlatır.
göreve devam ediyorken timerlara dışardan zorla stop mesajları da gelebilecek, örneğin;
{
  method: "timer_stop",
  params: {target: "water_pump_pwm"}
}
timer_stop o timerı resetlenip durdurur.
yani timer_managera yalnızca iki farklı methodla mesaj gelir; timer_start, timer_stop.
pass alanında mesajları doğal olay akış sırasına göre yazmaya çalıştım.
delay tipinde:
timer_start geldiğinde pass.1 gönderecek.
duration süresi dolduğunda pass.2 gönderecek.
timer_stop geldiğinde pass.2 gönderecek.
pwm tipinde:
timer_start geldiğinde ve her phase_a fazına geçişte pass.1 gönderecek.
her phase_b fazına geçişte pass.2 gönderecek.
timer_stop geldiğinde pass.2 gönderecek.
loop tipinde:
timer_start geldiğinde ve her intervalde pass.1 gönderecek.
timer_stop geldiğinde pass.1 gönderecek.
counter tipinde:
timer_start geldiğinde pass.1 gönderecek.
bitime signal süresi kaldığında (count=signal olduğunda) pass.2 gönderecek, bu özelliği yeni ekledim.
bittiğinde (örneğin fsm_day_counter için count=0 olduğunda) pass.3 gönderecek.
istisnasız olarak her mesajla birlikte(timer_start geldiğinde dahil) pass.4 mesajı da gönderecek.
pass.4 dinamik değer içeriyor, her defasında fsm_day=count yaparak gönderecek.
timer_stop geldiğinde pass.3 gönderecek.
-------------------------
her bir mesajı ilgili portunu hesaba katarak bir mesaj buffer'ına push edip, fonksiyondan tek defada return msg; ile çıkmak en iyisi olur, doğru mudur? tabi eğer gönderilecek mesaj varsa.
pwm için süre hesabı şöyleydi, hatırlayalım:
timer_start geldiğinde pwm döngüsü phase_a ile başlar.
phase_a süresi t_duty kadardır.
phase_b süresi t_cycle - t_duty kadardır.
yani t_cycle döngüsel süredir. 
----------------------
önce digital_inputs_modbus nodunu hem flow_context ile uyumlu hale getirelim ve hem de 2 çıkış portlu hale getirelim.
1 no'lu porttan mevcut koddaki mesaj yapısı çıksın, ve 1 nolu porttan her ne zaman mesaj çıkarsa 2 no'lu port'tan da aşağıdaki örnek yapıdaki gibi mesaj çıksın;
{
  method: "publish_on_change",
  params: {oxygen_detector: "off"}
}
daha sonra analog_inputs_modbus ve energy_meter_modbus fonksiyon nodlarında yapılacak revizyonları söyleyeceğim.
çünkü onlarınki biraz farklı.

digital_inputs_modbus kodunu göndereceğim hazır mısın?
--------------------
şimdi analog_inputs_modbus noduna geçelim.
mevcut mantık ve mesaj yapısında kalıp flow_context'e uyumlu hale getirilecek.
not: factor ve tolerans değerleri özelleştirildi.
tek çıkışlı olarak kalacak.
config'deki material_detector: {off: 30, on: 60}} değerlerini hiç dikkate almayacak.
çünkü daha sonra çıkışına analog_detector adlı bir nod bağlayacağız ve detector değerleri analog_detector'da kullanılacak.

hazır mısın analog_inputs_modbus'ı göndereyim mi?


analog_inputs_modbus nodunun çıkışı analog_detector adlı bir fonksiyon nodunun girişine bağlı.
şimdi analog_detector kodunu sıfırdan yazmanı istiyorum.
2 çıkış portlu olacak.
analog_inputs_modbus'dan gelen mesajlardaki analog değerlere göre(material_level, water_level gibi) ve config kısmındaki material_detector: {off: 30, on: 60}} hysteresis eşik seviyelerine göre, material_detector ve water_detector adlı on/off değerli mesajlar çıkaracak, tabi ki değişimlerinde.
bu mesajlar tıpkı diğer nodlardaki gibi her zamanki mesaj yapısında olacak ve 1 nolu porttan çıkacak.
ve tabi ki önce runtime'daki material_detector, water_detector alanlarındaki on/off değerleri de güncelleyerek.
her ne zaman 1 nolu porttan mesaj çıkacaksa, tıpkı diğer nodlarda olduğu gibi aşağıdaki örnek yapıdaki bir mesaj da 2 nolu porttan çıkacak.
{
  method: "publish_on_change",
  params: {material_detector: "off"}
}

hazırsan analog_detector fonksiyon nodunun kodunu yaz lütfen.



gelen analog değerlerine göre ve 
tabi ileride eklenecek yeni hsyteresis detector'leri için gereken esnek yapıda olacak kodu.
hysteresis için flow_context'in runtime alanındaki material_detector ve water_detector alanlarına yeni key'ler eklemedim, gerekiyorsa hafıza ihtiyacını node context ile karşılarsın diye düşündüm, ne dersin?
bu detector'ler için tıpkı digital_inputs_modbus'taki mantıkla yalnızca değişim olduğunda(tabi bu defa detector'leri biz üretiyoruz, parazit filtresi yok) mesaj çıkacak.
ve tıpkı digital_input_modbus'taki on/off'lar gibi aynı mesaj yapısında, fakat burada 2 nolu porttan çıkacaklar.
her ne zaman 2 no'lu porttan mesaj çıkarsa, 3 nolu porttan da aşağıdaki örnek yapıda mesaj çıkacak.
{
  method: "publish_on_change",
  params: {material_detector: "off"}
}

açıklamamda eksik veya uyumsuz yerler varsa revize etmeye başlamadan beni uyar lütfen.
hazır mısın analog_inputs
---------------
analog_detector''deki:
const detectorMap = {
  material_level: "material_detector",
  water_level: "water_detector"
};
energy_meter_detectordeki;
const detectorKey = "kwh_detector";
gereken mapleri karşılık gelen, yani origin'i olan map'lerden alabilirsin.
channels: {
  material_level: {map: 0, factor: 0.01, tolerance: 0.1, material_detector: {off: 30, on: 60}},
  water_level: {map: 1, factor: 0.01, tolerance: 0.1, water_detector: {off: 30, on: 60}}
}
ve
channels: {
  kwh: {map: 0, factor: 0.01, tolerance: 0.1, kwh_detector: {off: 30, on: 60}}
}

uygun mudur? hazırsan önce analog_detector'de gerekli düzenlemeyi yap lütfen.

mevcut actuators_modbus kodu eski bir flow_context'e göre ve actuators adlı bir üst katman grubuna göre mesaj bekliyor ve işliyordu.
şimdi ise bu actuators katmanı iptal edilmiş gibi düşünelim.

öncelikle, loader konusunda bir karışıklık vardı, flow_context'te yeni bir düzenleme yaptım, birazdan flow_context'in son halini(referansımız artık bu son halidir) göndereceğim.
yalnızca loader sözcüğünün geçtiği yerlere bakman yeterli, diğer her şey aynı.
ve hemen ardından açıklamam gelecek, sonra kodlamaya başlayabilirsin.
flow_context'i göndereceğim hazır mısın?


aslında genellemeler üzerinden anlatmak yerine doğrudan gelebilecek mesaj çeşitlerini örnekler halinde sana iletsem daha net ve isabetli olabilir.

1.
sinamics mesajları:
{
  method: "forward_run", // forward_run | reverse_run | stop
  params: {
    target: "hatch" // esnek yapıda olmalı, tüm sinamics'ler için yapılacak iş standart, yalnızca unitid'leir farklı, sinamics adları hard code olmamalıdır. 
  }
}
{
  method: "change_speed",
  params: {
    target: "hatch", // esnek yapıda olmalı, tüm sinamics'ler için yapılacak iş standart, yalnızca unitid'leri farklı, sinamics adları hard code olmamalıdır. 
    speed: 16384 // set_point / 100 * speed_max
  }
}
2.
genel olarak relay mesajları:
{
  method: "relay_on", // relay_on | relay_off
  params: {
    target: "light" // esnek yapıda olmalı, tüm relay'ler için yapılacak iş standart, yalnızca unitid'leri(relay_outputs_*) farklı ve bit map'lerine göredir, relay adları(light, buzzer vb.) hard code olmamalıdır. 
  }
}
özel olarak loader mesajları:
{
  method: "forward_run", // forward_run | reverse_run | stop
  params: {
    target: "loader" 
  }
}
ve şimdi sana revize edilecek olan actuators_modbus fonksiyon noduna ait kodu tekrar göndereceğim.  
loader methodlarında (forward_run | reverse_run | stop) hangi relay'lerin etkileneceğini de kodda görebilirsin.

hazırsan actuators_modbus'ı göndereyim.

-------------------------

şimdilik her node red restart'ında flow_context nodunu bir inject yardımıyla elle tetikleyerek flow context'ini yüklüyorum. 

mqtt_manager nodu thingsboard iot platformu ile ve flow'un çeşitli nodlarıyla haberleşir.
thingsboard ile rpc ve telemetry prosedürlerini işleterek haberleşir.
node red'teki mqtt configuration (gizli nod) nodu thingsboard için ayarlandı.
mqtt_in nodu (mqtt in tipi nod) rpc prosedürü için thingsboard'un v1/devices/me/rpc/request/+ topic'ine abone olarak ayarlandı.
mqtt_out nodu (mqtt out tipi nod) thingsboard'un rpc ve telemetry prosedürlerine uygunluk için topic kısmı boş bırakılmış olarak ayarlandı, dinamik olarak değiştirilir.
rpc prosedüründe mqtt_in nodundan mqtt_manager'a v1/devices/me/rpc/request/$request_id topic'li gelen her mesajın karşılığında v1/devices/me/rpc/response/$request_id topic'ine mqtt_out nodu üzerinden mutlaka thingsboard'a response mesajı gönderilir, böylece prosedür başarıyla tamamlanmış olur.
telemetry prosedürü tek yönlü, mqtt_manager'dan thingsboard'a, v1/devices/me/telemetry topicine mqtt_out nodu üzerinden mesaj gönderilir.  
mqtt_manager 2 çıkış portlu bir fonksiyon nodudur, 1 nolu port mqtt_out noduna gider, 2 nolu port fsm noduna gider.
mqtt_in nodunun çıkışı, mqtt_manager'ın girişine bağlıdır.
gelen ve giden olan mesajlarda, ve zaten esas olarak tüm flow'da mesaj payload yapısı şöyledir:
msg.payload={
  method: <string>,
  params: {<object içeriği>}
}
mesaj yapısı, rpc prosedürü, telemetry prosedürü açıklanmış olduğuna göre şimdi mqtt_manager'a gelen mesajlardaki method'lara göre neler yapacağını açıklamak istiyorum.
TELEMETRY PROSEDÜRÜ işletilecek olanlar.
method: "telemetry" olarak gelen mesajlar için geçerlidir.
1.
gelen mesaj;
msg.payload={
  method: "telemetry",
  params: {<boş>}
}
1 nolu porttan giden mesaj;
msg.payload={
  method: "telemetry",
  params: {<flow_context'in tüm runtime içeriği, "runtime" root adı olmayacak>}
}
2.
gelen mesaj;
msg.payload={
  method: "telemetry",
  params: {<dolu>}
}
1 nolu porttan giden mesaj, gelen mesajın aynısıdır.
RPC PROSEDÜRÜ işletilecek olanlar.
not: 2 nolu porttan giden mesajlarda topic olmayacak.
gelen mesajda method: "telemetry" değilse rpc prosedürü geçerlidir.  
1.
gelen mesaj;
msg.payload={
  method: "rpc_set",
  params: {<flow context'te güncellenecek alan ve değeri>}
}
1 nolu porttan giden mesaj, gelen mesajın aynısıdır, yani güncelleme yapıldı.
2.
gelen mesaj;
msg.payload={
  method: "rpc_get",
  params: {<flow context'te sorgulanan alan, değeri null olarak belirtilmiş>}
}
1 nolu porttan giden mesaj;
msg.payload={
  method: "rpc_get",
  params: {<flow context'te sorgulanan alan ve değeri(null yerine)>}
}
3.
not: rpc prosedüründe, gelen diğer tüm methodlar için hem 1 nolu port'tan, hem de 2 nolu porttan gelen mesajın aynısı gönderilecek.
hatırlatma: rpc prosedüründe 2 nolu porttan giden mesajlarda topic olmayacak.
gelen rpc_set methodu flow_context'te bir güncelleme yapılmasını istiyor.
gelen rpc_get methodu ise bir sorgulama yapıyor, null yazan yerleri değerleri flow_context'ten okunacak.
cevaplar daima gelen mesajla aynı yapıdadır. 
----------------------------

PATH KONUSU rpc prosedüründeki rpc_set ve rpc_get methodları için:
gelen örnek mesajlar;
msg.payload={
  method: "rpc_set",
  params: {kwh_detector: {off: 35}} // on: <değer> aynı kalacak, yalnızca off: 35 olarak güncellenecek. 
}
msg.payload={
  method: "rpc_set",
  params: {kwh_detector: {off: 35, on: 65}}
}
msg.payload={
  method: "rpc_set",
  params: {light: {map: 1}}
}
msg.payload={
  method: "rpc_get",
  params: {kwh: {val: null}}
}
msg.payload={
  method: "rpc_get",
  params: {kwh_detector: {off: null}}
}
not: rpc_set ve rpc_get için, gelen mesajdaki path flow context'te yoksa, "rpc_error" cevap mekanizması uygulanacak.
rpc prosedüründe hangi method olursa olsun daima cevap gönderilir. 
şimdilik logger gerekmez. 





flow context'in runtime alanındaki tüm içeriği params'ın içinde telemetry prosedürü ile gönderecek, tabi root olarak runtime key'i olmayacak, içeriği gönderilecek.
eğer params boş bir object değil ise 
method: "telemetry" olacak.



şu prosedürlerle haberleşecek;
thingsboard rpc // dashboard'dan komut ve context ayar mesajları gelecek.
telemetry prosedürü // on_change ve periodical olarak mesajlar gidecek.


set_context
get_context
publish_on_change
publish_period (telemetry)

------------------------
tekrardan merhaba, timer_manager fonksiyon nodu ile ilgili bir strateji değişikliği yapmak istiyorum.

fsm_day_counter: {
  type: "counter", direction: "down", interval: 1, base: 21, signal: 3, unit: "d",
  pass: {
    1: {method: "fsm_start", params: {}, port: 1},
    2: {method: "fsm_dry", params: {}, port: 1},
    3: {method: "fsm_end", params: {}, port: 1},
    4: {method: "telemetry", params: {fsm_day: {val: null}}, port: 3},
  }             
},

actuators_modbus nodunda iki geliştirme yapmak istiyorum.
ilki şöyle;
sanırım şu an kod gelen mesaja göre target'ın state'ini güncellemiyor, gönderenin güncellemiş olduğunu kabul ediyor, şu an mevcut kod öyle mi çalışıyor diye bakar mısın?
oysa ben taget'ın runtime'daki tüm güncellemesini actuators_modbus'ın yapmasını istiyorum, çünkü gönderici olan fsm nodu bunu yapmadam yalnızca mesajını gönderiyor actuators_modbus'a.
ben yine önce flow_context'i göndereyim mi sana sonra da actuators_modbus'ı?
-------------------
gelen komutlar aşağıdakilerle ilgili, fakat aslında bu bilgiyi vermeme de gerek yok, gelen mesajda target runtime alanı güncellenecek.
loader_forward_valve: {state: "off"},
loader_reverse_valve: {state: "off"},
loader_motor: {state: "off"},
light: {state: "off"},
buzzer: {state: "off"},  
hatch: {speed: {set_point: 100}, state: "off"},
fan: {speed: {set_point: 100}, state: "off"},
water_pump: {speed: {set_point: 100}, state: "off"},
discharger: {speed: {set_point: 100}, state: "off"},
loader: {state: "stop"},

{
  method: "stop",
  params: {target: "all"}
}
--------------------------------------
merhaba, raspberry pi'de node red ile bir flow oluşturuyorum.
node-red-contrib-modbus paketi de yüklü.
flow biraz plc'ye benziyon olacak.

sana öncelikle flow'u göndermek istiyorum.
10 adet fonksiyon nodu var, bağlantıları görmen için, nod'ların js kodlarını boş bıraktım şimdilik, ve hepsi disabled.
daha sonra flow_contex nodunu göndereceğim ve sonraki adımda da açıklamalara başlayacağım.
fonksiyon nodlarının kodları daha önceki sohbetlerimizde yazıldı, var, fakat ben sürekli fikir değiştirdiğimden şimdi hepsinin epey bir düzenlenmesi gerekiyor.
hazır mısın flows.json dosyasını göndereyim mi?
--------------------------------
flow'da aşağıdaki standart mesaj yapısı var, ve topic kullanılmıyor.
msg.payload={
  method: <string>,
  params: <json>
}
istisna durumlar şöyle;
modbus için kullanılan flex getter'dan gelen ve flex writer'a gönderilen mesajlar mecburen kendi payload formatında.
ve ileride göreceğimiz gibi thingsboard rpc ve telemetry prosedürlerinde topic elbette kullanılıyor olacak.
diğer bir konu ise flow_context.
her node red restart'ında şimdilik bir inject yardımıyla tetikleyip flow context'inin yüklenmesini sağlıyorum.
flow'un elektrik kesintisinden mümkün olduğunda az etkilenip önceki durumuna yakın bir yerden devam etmesini istiyorum elektrik geldiğinde, tıpkı bir plc gibi.
o nedenle settings.js'de aşağıdaki ayarı yapacağım daha sonra;
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
böylece en son kesinti öncesindeki en yakın değerler ile devam etmesi için.
bununla birlikte timerları da kalıcı olarak tasarlıyoruz, node red'in timer özelliği olan delay, inject vb. kendi nodlarını kullanmıyoruz, uzun süreli işler için.
şimdi flow'daki fonksiyon nodlarının bir listesini yap ve sonra ben mqtt_manager kodunu göndereceğim ve nasıl revize etmeni istediğimin açıklamasını göndereceğim ardından.
genel olarak böyle ilerleriz adım adım.
---------------------
doğru liste bu:
flow_contex
digital_inputs
analog_inputs
analog_detector
energy_meter
energy_meter_detector
actuators_modbus
timer_manager
mqtt_manager
fsm
-------------------
mqtt_manager'ı 3 çıkış portlu istiyorum.
gelen mesajlara göre neler yapılacağına aşağıda bakalım:
TELEMETRY PROSEDÜRÜ
method: "telemetry" ile gelen mesajlar için kod aynı kalacak.
RPC PROSEDÜRÜ
gelen method: "telemetry" değil ise rpc prosedürü işletilecek.
dolayısıyla aşağıdakiler yalnızca rpc prosedürü ile ilgilidir.
rpc prosedüründe requestId ve topic tekniğiyle cevap mutlaka gönderilir, her gelen mesaj için.
cevap daima gelen mesajın aynıdır, bir tek istisna dışında, "get" methodunda null olan değereler flow'dan okunan değerler ile değiştirilip cevap öyle gönderiliyor.  
mevcut kod zaten bunları yapabiliyor gördüğüm kadarıyla, bunlar 1 nolu çıkış portu ile ilgili, mqtt_out noduna bağlantılı.
gelen rpc mesajlarında bundan böyle params alanı içinde type alanı da olacak, "context", "fsm", "manual" değerlerinde.
"set" ve "get" method'ları type: "context" ile birlikte gelir ve ilgili cevaplar 1 nolu porttan çıkar.
diğer tüm methodlar için type "fsm" veya "manual" olarak gelecek.
"fsm" ile gelenler hiç değişikliğe uğramadan 2 nolu porttan çıkacak, tabi ki topic iptal edilerek.
"manual" ile gelenler hiç değişikliğe uğramadan 3 nolu porttan çıkacak, tabi ki topic iptal edilerek.
tekrar hatırlatma: tüm rpc prosedürlerinde 1 nolu porttan cevap mutlaka çıkar, ki prosedür thingsboard tarafında onaylansın ve başarılı kabul edilsin.
-------------
flow'da genel kural olarak; bir nod, flow_context'te güncelleme yaptıysa mutlaka bir telemetry mesajı da çıkarmalı, bu mesaj mqtt_manager'a gider. actuators_modbus halen 2 port çıkışlı. onu 3 port çıkışlı yapalım ve flow_context'in runtime alanını her güncellediğinde, yani aslında mesaj geldiyse, mesaj çıkaracaksa 1 ve 2 nolu portlardan, yani bu nod çalıştıysa bir güncelleme de mutlaka olacaktır, öyleyse 3 nolu porttan ve yine flow'un standart mesaj yapısına uygun, güncellediği alanı belirten mesaj çıkarsın. sanırım timer_manager benzerini yapıyordu. 
-------------------
analog_detector ve energy_meter_detector isimlerindeki fonksiyon nodlarının digital_inputs içindeki oygen_detector ve humidity_detector alanlarıyla hiçbir ilgisi yok.
dinamik bulucuya ihtiyaç var mı?
örneğin analog_detector nodu gelen aşağıdaki örnek mesaj için:
msg.payload={
  method: "water_level",
  params: {val: <number>}
}
şu mesajı çıkaracak, tabi ki eğer hysteresis olarak bir değişim varsa:
1 nolu porttan;
msg.payload={
  method: "water_detector",
  params: {state: on | off}
}
2 nolu porttan;
msg.payload={
  method: "telemetry",
  params: {water_detector: {state: on | off}}
}
ve runtime'de key bulmak için config'den faydalanabilir.
yani zaten aşağıdaki kısımda görülebileceği gibi water_level ile water_detector aynı object'in içindeler ve aynı map: 0 olarak.
yani water_level'a karşılık runtime'da water_detector verisi güncellenir.
material_level'a karşılık runtime'da material_detector verisi güncellenir.
aynı teknik energ_meter_detector nodu için de geçerlidir.
kwh'a karşılık kwh_detector.
tabi burada yazdıklarımız hysteresis eşik seviyelerine göre hesaplanır. 
------------------------



daha fazla genel açıklama yapmam uzun sürer, onun yerine her adımda bir fonksiyon kodu ve ardından gelen-giden mesaj örnekleri, bazı değişiklikler, yeni flow_context'e uygunluk üzerinden revizyonu yapabilmen için bilgi vereceğim.
hazırsan ilk fonksiyon nodu olarak flow_contex'i göndereyim.
-------------------
sıra actutors fonksiyon nodunda.
3 çıkış portlu olarak kalacak.
1 ve 2 nolu çıkışların mesaj yapısı aynen kalacak, çünkü modbus flex writer nodları bu yapıda mesaj bekliyor actuators'dan.
3 nolunun mesajlarını yeni mesaj yapısıyla çıkarıyoruz, method: "evt" olarak çıkacak.
örnek olarak mesajlar şöyle gelecek:
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "hatch"} // bu bir sinamics mesajı
}
msg.payload={
  method: "cmd",
  params: {type: "forard_on", target: "loader"} // bu bir loader mesajı, 3 relay'i içeriyor.
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir relay mesajı
}
not: "relay_on", "relay_off" olarak gelmesini beklemesin, daha generic biçimde "on", "off" olarak gelecek, target'a bakıldığında relay olup olmadığı anlaşılsın.
sanırım bu nod yeni flow_contex'e uyum ve mesaj yapısı bakımından epey değişiklik istiyor.
hazır mısın göndereyim mi?
------------------
sırada timer_manager fonksiyon nodu var.
aynı revizyon yöntemleri uygulanacak, flow_contex ve gelen-giden mesajlar için yeni mesaj yapısıyla %100 uyumlu olmalı.
3 portlu olarak kalacak.
şöyle bir kod kısmı var:
// Ana mesaj işleme
if (method === "timer_on") {
  timerOn(timers[target], runtime[target], Date.now(), out, target);

} else if (method === "timer_off") {
  if (target === "all") {
    for (const [key, timer] of Object.entries(timers)) {
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    timerOff(timers[target], runtime[target], out, target);
  }
} else if (method === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}
ve yine bunda da "timer_on", "timer_off" yerine "on", "off" gelecek, target target'ta bir timer adı olup olmadığına göre ayrım yapılacak.
msg.payload={
  method: "cmd",
  params: {type: "on", target: "water_pump_pwm"} // bu bir timer mesajı
}
ve tabi target'ta bir timer adı yoksa gelen mesaj 2 nolu porttan (out[1]) aynen gönderilecek.
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir timer mesajı değil, 2 nolu porttan aynen çıkacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu da bir timer mesajı değil, 2 nolu porttan aynen çıkacak.
}
hazır mısın timer_managerı göndereyim mi?
-----------------------------------
sırada mqtt_manager fonksiyon nodu var.
yine aynı revizyon çerçevesinde.
3 portlu olarak kalacak.
gelen mesajları farklı işlevler için aşağıdakiler gibi beklesin:
TELEMETRY PROSEDÜRÜ method: "evt":
msg.payload={
  method: "evt",
  params: {type: <string>, val: <misc>} // telemetry prosedürü ile göndermek için
}
msg.payload={
  method: "evt",
  params: {type: <telemetry_periodical>, val: null} // tüm runtime'ı telemetry prosedürü ile göndermek için
}
RPC PROSEDÜRÜ method: "cmd":
msg.payload={
  method: "cmd",
  params: {type: "set", target: {aynı path,value sistemi}} // set için
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {aynı path,null sistemi}} // get için
}
msg.payload={
  method: "cmd",
  params: {type: <string>, target: "fsm"} // fsm için
}
eski "manual" için ise aşağıdaki gibidir.
eğer method: "cmd" iken type: "set" veya type: "get" değilse o zaman bir de target'a baksın target: "fsm" değilse gelen mesajı 3 nolu port'tan çıkarsın.

hazır mısın göndereyim mi?





-----------------
merhaba, raspberry pi ve node red ile plc gibi çalışan bir flow oluşturmaya devam ediyorum.

senden istediğim her defasında aynı gönderecek olduğum fonksiyon nodunun flow_context ile tam uyumlu olup olmadığını denetlemen.
not: node-red-contrib-modbus paketi de yüklü. hazır mısın?
---------------------------------------------
merhaba,
raspberry pi ve node red ile plc gibi çalışan bir flow oluşturmaya devam ediyorum.
node-red-contrib-modbus paketi de yüklü.
yeni flow context ve mesaj yapısı için mevcut 10 adet fonksiyon nodlarının kodlarını revize etmiştin.
henüz test etmedim.
flow_contex
digital_inputs
analog_inputs
analog_pro
energy_meter
energy_meter_pro
actuators
timer_manager
mqtt_manager
fsm
flow genelinde mesajlarda topic yok, istisna olarak mqtt_in ve mqtt_out nodlarıyla çalışırken thingsboard rpc ve telemetry prosedürleri için topic kullanılıyor.
flow genelinde yeni mesaj yapısı şöyle;
msg.payload={
  method: <string>, // evt | cmd
  params: <json>, // evt için {type: <string>, val: <misc>} | cmd için {type: <string>, target: <misc>}
}
istisna olarak modbus flex getter nodlarından çıkan ve modbus flex writer nodlarına gide mesajlar mecburen kendine özgü payload formatındalar.
yeni mesaj yapısı (method: <string>, params: <json>) aynı zamanda thingsboard rpc prosedürü mesaj payload yapısıyla da aynı.
flow context'ini şimdilik her node red restart'ından sonra bir inject nodu yardımıyla elle tetikleyerek flow_context nodu ile yüklemiş oluyorum.
ileride settings.js'de aşağıdaki ayarı yapıp diskte kalıcı dosya halinde arka planda periyodik olarak kaydediliyor olmasını sağlayacağım.
sonra da flow_context nodunu flow'dan kaldıracağım.
flow bir plc'ye benziyor demiştim, elektrik kesintisinden sonr tekrar çalıştığında kesintiden önceki diske kaydedilmiş en son runtime değerleri ile kaldığı yerden devam edebilmesini hedefliyoruz.
o yüzden timer'ları bile date.now gibi bir teknikle kalıcı olarak tasarlıyoruz, node red'in kendi inject, delay vb. nodları kalıcı değiller, uzun zamanlamalar için kullanamazdık, kesintiden sonra resetleniyorlar.

şimdi senden istediğim; revize edilmiş bu fonksiyon kodlarının flow_context ve yeni mesaj yapısı ile tam uyumluluğunu son defa kontrol etmen, eksik/fazla/hatalı kodlar var mı diye bakman.
kodlar ileride flow_context'te yapılacak değişiklikler için yeterince esnek mi.
önce flow_context kodunu referansımız olarak gönderip daha sonra her adımda bir tane olmak üzere 9 fonksiyon kodu göndermek istiyorum.
fakat daha önceki sohbetlerimizde şunu gördüm, birkaç adım sonra flow_context'i unutmuş olabiliyorsun.
yoksa her kodla birlikte flow_context'i de yanında mı göndersem, ne dersin?
notlar;
kodları file upload olarak değil, içeriklerini sohbette göndereceğim.
modbus flex getter tipi nodlar her 100ms'de bir mesaj gönderir.
timer_tick her 1 saniyede gelir.

benim de kontrol edebilmem için her kodun beklediği mesajları ve bu mesajlara karşılık yaptığı işleri ve çıkardığı port mesajlarını kısaca listelemeni istiyorum, her adımda.
-----------------------------
tahmin ettiğim gibi actuators belki de revize edilmemiş !!

3 çıkış portlu olarak kalacak.
1 ve 2 nolu çıkışların mesaj yapısı aynen kalacak, çünkü modbus flex writer nodları bu yapıda mesaj bekliyor actuators'dan.
3 nolunun mesajlarını yeni mesaj yapısıyla çıkarıyoruz, method: "evt" olarak çıkacak.
örnek olarak mesajlar şöyle gelecek:
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "hatch"} // bu bir sinamics mesajı
}
msg.payload={
  method: "cmd",
  params: {type: "speed", set_point: 50, target: "hatch"} // bu bir sinamics mesajı, sadece speed'e özel olarak set_point adında bir key daha eklemiş olduk.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu bir loader mesajı, 3 relay'i içeriyor.
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir relay mesajı
}
istersen actuators ve referansımız olan flow_context'i tekrardan ve birlikte olarak göndereyim mi?
---------------------------------
sırada timer_manager fonksiyon nodu var.
aynı revizyon yöntemleri uygulanacak, flow_contex ve gelen-giden mesajlar için yeni mesaj yapısıyla %100 uyumlu olmalı.
3 portlu olarak kalacak.
şöyle bir kod kısmı var:
// Ana mesaj işleme
if (method === "timer_on") {
  timerOn(timers[target], runtime[target], Date.now(), out, target);

} else if (method === "timer_off") {
  if (target === "all") {
    for (const [key, timer] of Object.entries(timers)) {
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    timerOff(timers[target], runtime[target], out, target);
  }
} else if (method === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}
ve yine bunda da "timer_on", "timer_off" yerine "on", "off" gelecek, target target'ta bir timer adı olup olmadığına göre ayrım yapılacak.
-------------------------------------------------------------
merhaba, raspberry pi'de node red ile plc gibi çalışan bir flow oluşturduk daha önceki sohbetlerimizde.
şimdi timer_manager ve mqtt_manager adlı fonksiyon nodlarının kodlarını son bir defa daha kontrol etmeni istiyorum, henzü test etmedim.
flow genelinde esas referansımız flow_context nodudur ve hazır haldedir.
flow'un context'ini şimdilik her node red restart'ından sonra bir inject nodu yardımıyla elle tetikleyerek flow_context nodu ile yüklemiş oluyorum.
ileride settings.js'de aşağıdaki ayarı yapıp diskte kalıcı dosya halinde arka planda periyodik olarak kaydediliyor olmasını sağlayacağım.
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
sonra da flow_context nodunu flow'dan kaldıracağım.
flow bir plc'ye benziyor demiştim, elektrik kesintisinden sonr tekrar çalıştığında kesintiden önceki diske kaydedilmiş en son runtime değerleri ile kaldığı yerden devam edebilmesini hedefliyoruz.
o yüzden timer'ları bile date.now gibi bir teknikle kalıcı olarak tasarlıyoruz, node red'in kendi inject, delay vb. nodları kalıcı değiller, uzun zamanlamalar için kullanamazdık, kesintiden sonra resetleniyorlar.
flow genelinde mesajlarda topic yok, mqtt_manager adlı nod için istisna olarak mqtt_in ve mqtt_out nodlarıyla çalışırken thingsboard rpc ve telemetry prosedürleri için topic kullanılıyor.
flow genelinde mesaj yapısı şöyle;
msg.payload={
  method: <string>, // evt | cmd
  params: <json>, // evt için {type: <string>, val: <misc>} | cmd için {type: <string>, target: <misc>}
}
öncelikle esas referansımız olan flow_context nodunun kodunu göndereceğim, gereken alanları analiz edersin.
daha sonra timer_manager'ı kontrol etmen için önce açıklamasını ve ardından mevcut kodunu göndereceğim.
daha sonra da mqtt_manager'ı kontrol etmen için önce açıklamasını ve ardından mevcut kodunu göndereceğim.
açıklamalarımda örnek mesajlar göstereceğim.
kodları flow_context ve mesaj yapısı ve varsa düzeltilmesi gereken yerler bakımından kontrol edersin ve gerekirse kodları revize edersin.
hazırsan flow_context ile başlayalım..


daha sonra da adım adım flow_contex ve mesaj yapısı ile uyumlarını ve varsa düzeltilmesi gereken kısımları.

ardından timer_manager kodunu göndereceğim bir göz atarsın.
sonra da timer_manager için nasıl kontrol etmeni istediğimi açıklayacağım, varsa gereken düzeltmeleri yapman için.




-------------------------
method: "evt":
--------------
params: {type: "oxygen_detector", val: "off"}
params: {type: "oxygen_detector", val: "on"}
params: {type: "humidity_detector", val: "off"}
params: {type: "humidity_detector", val: "on"}
----------------------
energy_meter_pro'yu test ediyorum bağımsız olarak.
girişine 3 inject bağladım, hysteresis yapacak mı diyerek.
inject_80:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 80}
}
inject_50:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 50}
}
inject_20:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 20}
}
farklı sıralarla hysteresis'i tetiklemeye çalışıyorum fakat energy_meter_pro'nun çıkışında mesaj görmüyorum.
flow_context'te kwh_detector değerini üretmek için gereken hysteresis eşiklerinin 30 ve 60 olduğunu görebilirsin.
kwh: {map: 0, factor: 0.01, pro: {kwh_detector: {off: 30, on: 60}}}
fakat çalışmıyor.

benzer yapıdaki analog_pro gayet güzel çalışıyor, prensibe oradan bakabilirsin.

energy_meter_pro:





analog_pro:
{"method": "evt", "params": {"type": "kwh", "val": 80}}

{"method": "cmd", "params": {"type": "forward_on", "target": "hatch"}}
80 0 96
-----------------------------
actuators fonksiyon nodunu test ediyorum, genel olarak çok güzel çalışıyor, mantık ve çıkış portlarına yönlendirmeler tamamdır.
fakat şu 2 detayı da çözersek daha iyi olur.
1. detay:
şu 3 kısımı düşündüğümüzde; sinamics, relay_outputs_1, relay_outputs_2.
hangisinde değişim varsa yalnızca onun için mesaj çıksın, değişmeyeni tekrar göndermeye gerek yok.
2. detay:
3 nolu çıkış porttundan çıkan mesajlar konusunda, sinamics'te 3 nolu çıkış portundan çıkan mesajlarda original mesaj type korunmalı, mevcut kodda örneğin forward_X korunmuyor ve X olarak çıkıyor.
loader'da bu sorun yok, forward_X olarak çıkıyor. (X ifadesi on|off anlamında). light, buzzer tabi tam anlaşılmıyor, zaten sadecec on|off olduklarından, sanırım sorun yoktur. 
----------------------
evet gönderdiğin kod tam olarak talep etmiş olduğum gibi çalıştı, tamamen runtime üzerinden durum değişikliğine bakıyor, değişmeyen hiçbir şeyi çıkarmıyor.
fakat şimdi test ederken şunu anladım ki, tasarım olarak böyle yapmasa daha iyi olacak, çünkü biraz riskli, runtime ile modbus ve mqtt arasında, yani dış dünyadaki gerçek durumlar bakımından tutarsızlıklar oluşabilir.
özellikle sinamics'lerde runtime'daki mevcut durumuna (val) hiç bakılmaksızın gelen komutu yerine getirsin, mesajını üretsin.
yani kod eski hali gib çalışsın, ve sadece sinamics'ler ile relay_outputs_x'in birbirinden izole edilmesi sağlansın yeterlidir.
loader, light, buzzer gibileri için yine hem relay_outputs_1'i hem de relay_outputs_2'yi göndersin, zararı yok, röleler tazelenmiş olur. runtime ile modbus cihazlarındaki gerçek durum hep tutarlı kalsın.
yani özetle; her şey için komut ezici üstünlüğe sahiptir, runtime'daki mevcut duruma bakmaz, mutlaka mesajları gönderir.
runtime'a hiç bakılmadan aynı komut tekrar tekrar bile çalışabilsin, tabi ki runtime'ı da arka planda günceller daima.
ve tabi ki relay_outputs_x için önceki bitleri koruyan node contex sistemi aynen devam edecek.
not: sinamics 3 nolu çıkış portu original type korunamıyordu, bu sorun çözülmüş tamamdır.

şimdi actuators'u bu tasarıma göre revize et lütfen, sanırım küçük bir değişiklik istiyor hepsi o kadar.
------------------------
tam çözüme çok yakınız.
şimdi actuators'un en beğendiğim sürümünü sana gönderiyorum ve sadece aşağıdaki değişiklikleri uygula lütfen.
1) sinamics'lerin relay_outputs_X'lerle hiç ilgisi olmadığından, dolayısıyla sinamics komutları geldiğinde relay_output_X'ler için işlem yapılmasın ve onlar için mesaj da çıkmasın, zaten işlem yapılmıyor.
2) sinamics'lerin 3 nolu çıkış porttundan gönderilecek mesajlarında original type korunsun, örneğin "forward_on" gibi("on" çıkması yanlış), bunu yeni sürümlerde çözdüğün gibi çöz yine.

actuators:
-----------------------------------------------
timer_mnager için açıklama ve gelen mesajlardan bazı örnekler:
msg.payload={
  method: "evt",
  params: {type: "timer_tick", val: null} // bu bir timer_tick mesajı
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "water_pump_pwm"} // bu bir timer mesajı
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "day_counter"} // bu bir timer mesajı
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir timer mesajı değil, 2 nolu porttan aynen çıkacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu da bir timer mesajı değil, 2 nolu porttan aynen çıkacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "water_pump"} // bu da bir timer mesajı değil, 2 nolu porttan aynen çıkacak.
}
özetle;
method: "evt" olarak sadece type: "timer_tick", val: null olarak mesaj gelir, timer'ları yürütmek için her saniyede bir gelir, bu mesajın kendi doğrudan mesaj üretmez, göndermez.
diğer tüm mesajlar method: "cmd" ile gelir, yani aşağıdaki açıklamaların hepsi method: "cmd" ile gelen mesajlar içindir.
gelen mesajda önce target'a bakılır eğer bir timer (timer adı) değilse, gelen mesaj hiçbir işleme uğramadan port 2'den aynen gönderilir.
eğer target bir timer ise o timer için işlem yapılacak demektir.
her timer'ın kendi pass alanında mesajlar bulunur, mesajların çıkacağı port noları metadata olarak port: X biçimindedir. 
tabi ki pass alanındaki mesajlar gönderilirken port: X metadata yok edilerek gönderilir.
her timer formu için pass alanındaki mesajları göndermenin ayrı kuralları vardır.
gerekirse bu kuralları da tek tek açık olarak sana yazarım fakat ben kodda gereken kuralların zaten bulunduğunu düşünüyorum.

teste geçerken fan_pwm ve light_pulse için config'de süreleri küçülttüm ki çabuk görebileyim diye.
timer_tick de aktif ve saniyede bir mesaj gönderiyor timer_manager'a.
inject'lerle yaptığım ilk test başarısız, port1,2,3 çıkışlarına bağlı debug'larda mesaj yok.
örneğin en basitinden gidelim:
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light_pulse"}
}
geldiği gibi hemen şuradaki(config>timers>light_pulse) pass.1 mesajı çıkmalıydı 2 nolu porttan, fakat yok.
2 saniye sonra da pass.2 mesajı çıkmalıydı 2 nolu porttan, fakat yok. 
light_pulse: {
  type: "delay", duration: 2, unit: "s",
  pass: {
    1: {method: "cmd", params: {type: "on", target: "light"}, port: 2},
    2: {method: "cmd", params: {type: "off", target: "light"}, port: 2}
  }
}
target'ta timer adı olmayan mesajları doğru biçimde 2 nolu porttan çıkarıyor, bunda sorun yok.
henüz daha karmaşık olan day_counter adlı timer'ı test etmedim.

sorunları giderebilir misin?
istersen pass mesaj mantığını tam olarak yazayım fakat kodda mevcut diye düşünüyorum.
sen kodda gördüğün pass mesaj mantığını açıkla lütfen.
-------------------
sanırım şimdi sırada mqtt_manager var.
yine flow_context ile birlikte göndereyim ve bir göz at istersen.
daha sonra testlere başlarım.

mqtt_manager:
{"method": "cmd", "params": {"type": "set", "target": {"light_pulse": {"duration": 6}}}}
-----------------------------
mqtt_manager'ı denemeye başladım. öncelikle get metodu için şöyle bir inject ile mesaj gönderdim, rpc'yi taklit ederek.
msg.topic= "v1/devices/me/rpc/request/1001"
msg.payload={
  "method": "cmd",
  "params": {"type": "get", "target": {"light_pulse": {"duration": null}}}
}
port1,2,3 çıkışlarına da birer debug bağladım.
çıkan mesaj şöyle:
07.08.2025 19:29:30node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
light_pulse: object
duration: null
tabi ki duration: 2 olarak çıkmalıydı mesaj.
flow_context'te light_pulse için duration değerini bulamamış anlaşılan.
path: value' gibi bir sorunumuz mu var?
get sorgulaması config veya runtime alanı fark etmeksizin doğru değeri bulup, gelen get mesajındaki null yerine koyup cevap olarak göndermeli.
muhtemelen set mesajında da benzer bir sorun olacaktır, henüz test etmedim.
ben full path olarak yani en root tarafı, yanini config>timers>... veya runtime>material.. gibi yazmaya gerek olmadan bir yol bulunur diye düşünmüştüm.
çünkü flow_context'te çakışma olacak alanlar yok.
evet set/get konusuyla başlayalım mqtt_manager'a.
kodu göndereyim mi istermisin?
msg.payload={
  method: "cmd",
  params: {type": "get", target: {config: {timers: {light_pulse: {duration: null}}}}}
}
msg.payload={
  method: "cmd",
  params: {type": "set", target: {config: {timers: {light_pulse: {duration: 5}}}}}
}

------------------------------
bu arada, timer_manager'da bir sorunu fark ettim.
sanki çıkış portu yönlendirmeleri hatalı.
const out = [[], [], []]; // Port 1,2,3 biçimindedir, istediğim adlandırma budur.
timer'la ilgili olmayan komutlar doğru biçimde port 2'den çıkıyor.
örneğin aşağıdaki gelen mesaj aynen port 2'ye yönlendiriliyor, bu doğru, sorun yok.
msg.payload={
  "method": "cmd",
  "params": {"type": "forward_on", "target": "hatch"}
}
fakat örneğin timer'la ilgili gelen şu mesaj port 3'ten çıkıyor.
msg.payload={
  "method": "cmd",
  "params": {"type": "on", "target": "light_pulse"}
}
oysa doğrusu port 2'den çıkmasıdır, çünkü pass alanındaki metadata'sı port: 2.
light_pulse: {
  form: "delay", duration: 2, unit: "s",
  pass: {
    1: {method: "cmd", params: {type: "on", target: "light"}, port: 2},
    2: {method: "cmd", params: {type: "off", target: "light"}, port: 2}
  }
},
sanırım metadata port: X değerlerini 0 index'li kabul ediyor, port: 2 olması gerekirken sanki port: 3 olarak yorumlanıyor kodda.
acaba sorunun kaynağı bu mudur, yoksa başka bir şey mi?
eğer buysa nasıl düzeltebiliriz?
---------------
{"method": "cmd", "params": {"type": "get", "target": {"light_pulse": {"duration": null}}}}
---------------------------------
mqtt_manager açıklaması.
method: "cmd" ile gelen tüm mesajlar için ekstra yapılacak işler bir yana, mutlaka thingsboard rpc prosedürü uygulanır.
yani 1 nolu porttan cevap mesajı gönderilir ki thingsboard cevabı alsın ve prosedürü başarılı olarak sonlandırsın kendi tarafında.
cevap mesajı için msg.topic'te kodda gördüğün gibi requestId'li dönüşüm yapılır.
cevabın payload'u ise yalnızca bir istisna hariç daima gelen mesajın payload'unun aynısıdır. 
istisna ise type: "get" olarak gelen mesajlardadır, gelen payload'da null yazan yere flow context'inden alınan değer koyulur ve cevap payload'u olarak gönderilir, istisna durum yalnızca budur.
get'ten bahsettiğimiz göre hemen type: set olan mesajlarda ne olacak bakalım.
dediğim gibi, method: "cmd" ile gelen tüm mesajlarda type: "get" özel durumu hariç, cevap payload'u gelen payload'un aynısıdır, ve bir de topic dönüşümü var tabi.
şimdi rpc prosedürünü açıklamış olduk, devam edelim.
type: "set" ile gelenlerde flow context'i güncelleniyor, bunu yeterince konuştuk, get/set full path sistemine geçtiğimizi bundan böyle.
target: "fsm" olarak gelen tüm mesajlar topic'leri yok edilerek ve payload'una hiç dokunmadan 2 nolu porttan gönderilir.
ve burası önemli, (type: "set" veya type: "get" veya taget: "fsm") olmayan tüm mesajların topic'leri yok edilip, payload'larına hiç dokunmadan 3 nolu porttan gönderilir.
yani mqtt_manager kodunda, timer vb. bir ayrım söz konusu değil, varsa bu ayrım iptal edilsin. 
buraya kadar hep method: "cmd" için konuştuk, şimdi de method: "evt"'ye bakalım.
method: "evt" ile gelen tüm mesajlara telemetry prosedürü uygulanır, yani karşılığında 1 nolu porttan mesaj göndermek anlamındadır ve mesaja bir de mag.topic= "v1/devices/me/telemetry" biçiminde topic eklemek anlamındadır.
yani thingsboard'a tek yönlü bir gönderimdir.
method: "evt" ile gelen mesajlar için gönderilecek payload'un ne olacağı konusunda bir ayrım var.
eğer type: "telemetry_periodical", val: null ise gönderilecek payload;
msg.payload={
  method: "evt",
  params: {runtime'ın altındaki tüm yapı ve olduğu gibi}
}
eğer type: "telemetry_periodical", val: null ise gelen mesajın payload'una hiç dokunmadan gönderilir.
tekrar hatırlatırsak method: "evt" ile gelen mesajlara karşılık 1 nolu porttan mesaj gönderilir, msg.mag.topic= "v1/devices/me/telemetry" biçiminde topic ekleyerek ve yukarıda açıkladığım ayrıma bakıp cevap payload'unu belirleyerek.

umarım hatalı açıklama yapmamışımdır, mqtt_manager'ın bu açıklamalarıma göre düzenlemesini yaparsan çok sevinirim.
istersen kodu tekrar gönderirim..
---------------------
şöyle bir mesaj gönderdim inject nodundan:
msg.topic= "v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
1 nolu porttan çıkan debug mesaj şöyle oldu:
07.08.2025 21:15:43node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: null
gönderdiğim mesaj mı hatalı yoksa kod mu acaba?
-------------------------,
tekrar anlayamadığım şey şu:
flowData zaten var.
const flowData = flow.get("flow") || {}; 
gelen mesaj diyelim get olsun ve örneğin target: {"a": {"b": {"c": null}}} olsun.
flowData.a.b.c bizim istediğimiz değer değil mi?
------------------
kodu tekrar test ettim şöyle detay bir sorun var.
mevcut duration: 2 iken get yaptım, cevap şu çıktı, duration key yok olmuş aradan:
07.08.2025 22:18:51node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: 2
daha sonra duration: 8 olacak biçimde set yaptım ve cevap şu çıktı, doğru olarak:
07.08.2025 22:19:07node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8
sonra tekrar get yaptım ve cevap artık doğru çıktı, duration key var.
07.08.2025 22:19:22node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8

kullandığım kod şu:

mqtt_manager:
------------------------
{"method": "cmd", "params": {"type": "start", "target": "fsm"}}

07.08.2025 22:45:47node: port 2
msg.payload : Object
object
method: "cmd"
params: object
type: "start"
target: "fsm"
-------------------------
sanırım mqtt_manager için tüm testleri yaptım, tek bir detay sorun kaldı geriye.
gelen ilk get mesajı:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
çıkan debug mesaj (doğru):
07.08.2025 23:19:43node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 2
gelen set mesajı:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "set", "target": {"config": {"timers": {"light_pulse": {"duration": 8}}}}}}
çıkan debug mesajı(doğru):
07.08.2025 23:19:57node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8
gelen 2. get mesajı:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
çıkan debug mesajı(yanlış):
07.08.2025 23:20:18node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: object
duration: 8
yani duration içinde bir duration daha olmuş.

kullandığım kod şu.
mqtt_manager:
{"subject":"hatch","body":"stop"}
---------------
tekrardan merhaba,
mqtt_manager kodunda bir değişiklik istiyorum.
bu fonksiyon nodunun 3 çıkış portu vardı, şimdi artık 2 portlu olacak, nod setup'ında gerekli değişikliği yaptım.
halen 3 nolu porttan çıkıyor olan mesajların da 2 nolu port'tan çıkmalarını sağlayabilir misin?
bu port yönlendirme dışında kodda başka hiçbir değişiklik olmasın.
gerekli olabilir mi bilmiyorum ben yine de flow_context kodunu da gönderiyorum.

mqtt_manager:
------------------------
tamamdır, mqtt_manager artık port 1 ve port 2 olarak 2 çıkış portlu oldu.
şimdi bir değişiklik daha istiyorum.
method: "evt" ile gelen mesajlar ikiye ayrılıyor ve benim kodu okuyabildiğim kadarıyla şöyle işliyor.
gelen telemetry_priodical için flow context'in runtime alanının altındaki tüm yapı olduğu gibi gönderiliyor ve sonuç olarak çıkan mesajın payload'u şöyle oluyor:
msg.payload={
  oxygen_detector: {val: "off"},
  humidity_detector: {val: "off"},
  .....,
  .....,
  .....,
}
else durumunda yani aslında tekil olarak gelen mesajların payload'ları ise olduğu gibi(params'ın içi) gönderildiğinden örneğin şöyle çıkıyor:
msg.payload={
  type: "oxygen_detector",
  val: "val: "off"
}
aşağıdaki koda bakıldığında, buraya kadar söylediklerim doğru mu?
eğer doğruysa gelen bu iki ayrı mesaj opsiyonu için nasıl aynı yapıda mesaj çıkmasını istediğimi açıklayacağım ve mqtt_manager'da senden düzeltmeni isteyeceğim.
aynı yapıda çıkmalılar ki thingsboard tarafında tek yöntemle key: value'ları ayıklayabileyim, toplu da gelse tek tek de gelse thingsboard'a.

if (method === "evt") {
    const subType = params?.type;
    if (subType === "telemetry_periodical") {
        return [{
            topic: "v1/devices/me/telemetry",
            payload: runtime
        }, null];
    } else {
        return [{
            topic: "v1/devices/me/telemetry",
            payload: params
        }, null];
    }
}
--------------------------
merhaba,
raspberry pi'de node red ile bir flow oluşturmaya devam ediyorum.
node-red-contrib-modbus paketide yüklü.
öncelikle sana actuators nodunun ve flow_context nodunun kodlarını göndereyim, ve doğrudan kod yazmaya yardımcı olsun.
hemen ardından açıklama göndereceğim.

şimdi bir fonksiyon nodu daha eklemem gerekiyor flow'a.
önce şu bilgiyi hatırlayalım.
flow'un node red restart'ından(power reset/reboot) mümkün olduğunca etkilenmemesini istiyorum, tıpkı bir plc gibi çalışacak çünkü.
bir miktar zaman sapması makul kabul edilir.
şimdilik bir flow_context nodu var ve girişine bağlı olan bir inject ile her node red restart'ında flow context'ini elle yüklüyorum.
daha sonra settings.js'de aşağıdaki gibi, diske yazan, kalıcılık ayarını yaptığımda bu noda gerek kalmayacak. 
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
node red tüm context'lerin global(kullanmıyoruz)/flow/node, her 30 saniyede bir(flushinterval) son güncel halini diske kaydeder.
bu işlemi arka planda yapar, kendi bağımsız zamanlamasıyla.
örneğin flow context her 1 saniyede güncelleniyor da olsa, diske yalnızca bir sonraki flushinterval geldiğinde en güncel hali kaydedilir.
node red restart olduğunda, flow en kötü senaryoda power down'dan 30 saniye öncesindeki runtime değerleri ile yeniden çalışmaya başlayacaktır.
bu benim için makul bir süredir.
ve bu yüzden timer_manager içinde; dıştan 1 saniyelik timer_tick ve date.now yöntemiyle çalışan kalıcı timer'lar tasarladık, node red'in kendi nodları (inject, delay) kalıcı değiller ve uzun süreli işler için kullanılamazlardı.
buraya kadar tamam ama eksik olan şu:
sinamics, loader(röle grubu), diğer röleler(şimdilik light, buzzer var), bunlar aynı elektrik sistemindeler ve elektrip gidip geldikten sonra muhtemelen hepsi "off" olarak başlayacaklar, runtime'ları "forward_on", "on" vb. olarak kurtarılmış olsa bile.
yani flow'a restore adlı bir fonksiyon nodu eklemek gerekir ve çıkışını actuators noduna bağlamak.
restore nodunun her node red start'ında bir defa çaılşması için sanırım ui configuration ekranında "on message" değil de "on start" sekmesi altına kodu yazmak düşünülebilir, en pratik yol bu mudur, ne dersin?
restore adında ayrı bir noda gerek yok, actuators'un kendi "on start" sekmesi kullanılabilir restore edecek kodu yazmak için.
fakat yine de generic bir restore nodu olsun flow'da. 
bence telemetry'yi restore etmenin gereği yok çünkü zaten tüm event'lar anında thingsboard'a gönderilmiştir.
belki tam gönderme anında bir kesinti sorun olabilir. bilemiyorum, çok düşük olasılık.
peki restore nasıl bir görev yapmalı?
bence runtime'daki son durumları forward_on/on/off vb. olarak ayrıştırmaya gerek olmadan son durumların gereği olan mesajları çıkarsın ve gerçek dünyadaki modbus cihazlarını kendine node red start'ında sync etmiş olsun.
senin görüşün nedir ne yapmalı?

runtime'da sinamics, loader, relay'lar vb tüm actuatorler için off'lar için gerekmez demeden, hepsi için gereken mesajlar çıksın ve zorla sync etsin. 
restore nodu ayrı olsun, "on_start" sekmesinin altına kodu yerleştiririz. şöyle bir bak istersen..
---------------
    fan_pwm: {"val":"off","phase":null,"on_time":0,"phase_until":0},
    light_pulse: {"val":"off","on_time":0,"done":false},
    day_counter: {"val":"off","on_time":0,"count":21,"next_time":0},
    telemetry_periodical: {"val":"off","on_time":0,"next_time":0},
    fsm: {"state":"stop"}
    ----------------------
restore fonksiyonu(kodu on start sekmesine yazıyoruz) ilk çalışmaya belirli bir süre sonra başlasın.
bu süre geçmeden mesaj göndermeye başlamasın.
çünkü elektrik gidip geldiğinde örneğin sinamics cihazları henüz power up'larını tamamlamamış olabilirler.
flow_context'e config>sinamics>restore_delay: 10, olarak saniye cinsinden bir süre ekledim, bu süreyi kullanalım ve gerekli kod eklemesini yapalım lütfen.

----------------------------------
şimdi mqtt_manager'da bir değişiklik yapalım set|get konusuyla ilgili.
mevcut kod set payload'unu aşağıdaki örnekler gibi bekliyor:
msg.payload={
  method: "cmd",
  params: {type: "set", target: {config: {timers: {fan_pwm: {t_duty: <value>}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "set", target: {config: {io: {analog_inputs: {channels: {material: {pro: {material_detector:{on: <new-value>}}}}}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "set", target: {runtime: {oxygen_detector: {val: "on"}}}}; // bazen bozuk sensörler için runtime'da bu şekilde overwrite yapmam gerekebilir çünkü.
}
mevcut kod get payload'unu aşağıdaki örnekler gibi bekliyor:
msg.payload={
  method: "cmd",
  params: {type: "get", target: {config: {timers: {fan_pwm: {t_duty: null}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {config: {io: {analog_inputs: {channels: {material: {pro: {material_detector:{on: null}}}}}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {runtime: {oxygen_detector: {val: null}}}};
}
yukarıda anlattıklarım doğru mudur, ve karşılığında gönderdiği cevaplar da aynı yapıdadır değil mi?
eğer bunlar doğru ise birazdan değişiklik isteğimi göndereceğim.

mqtt_manager:
----------------------------------
yeni bir çözüm arayışının kaynağı, thingsboard tarafındaki rpc widget'lerinin initial değerleri için get komutunu rpc prosedürü ile göndermem gerekmesi.
fakat thingsboard tarafında widget initialization için yalnızca method kısmını gönderebiliyorum, params kısmını gönderemiyorum rpc widget'lerden, yani orayı kullanamam anladığım kadarıyla.
önümde 2 yol var.
1.
mqtt_manager'da get ayrımı için mesajın ona method: "get" olarak gelmesi, yani gelen mesajda doğrudan method ile ifade edilmesi.
ve bu durumda tüm flowData'nın thingsboard'a cevap olarak gönderilmesi, orada ayıklanması post process'te.
ve belki de set için değişikliğe gitmemek.
2.
hem set hem de get için geçerli olabilecek biçimde target: nested gönderimi yerine, örneğin az önce paylaşmış olduğum örneklere için, mqtt_manager'a aşağıdaki mesajlar gelecek biçimde thingsboard'da ayar yapabilirim:
gelen set mesajı örneği:
msg.payload={
  method: "set.config.timers.fan_pwm.t_duty",
  params: {value: <flow context'e yazılacak yeni t_duty değeri>};
}
thingsboard rpc dökümanından anladığım kadarıyla set mesajına cevabı basitçe şöyle verebiliriz, içinde onay değerinin(value: <new-value> v) olup olmaması fark etmiyor:
msg.payload={
  response: true
}
gelen get mesajı örneği:
msg.payload={
  method: "get.config.timers.fan_pwm.t_duty",
  params: {}; // thingsboard widget'i params gönderiyor mu göndermiyor mu bilmiyorum ama sanırım çok da önemi yok, yine anladığım kadarıyla.
}
get mesajına cevabı şöyle verebiliriz:
msg.payload={
  value: <flow context'ten alınacak t_duty değeri>
}
yani set/get ayrımı için method'u "." split edip startsWith(set/get) bakarak çalışır mqtt_manager kodu.
"." kullanmanın bir mahsuru var mı, ">" gibi başka bir karakter mi kullanalım?
sonuç olarak ben 2. yolu daha çok beğendim, hem set hem de get için aynı yapı olur gelen mesajlarda.
ayrıca madem ki set için aşağıdaki response'u belirledik, o zaman method: "cmd" ile gelen mesajlar için de aynı response ile cevap verilsin.
msg.payload={
  response: true
}
mevcut kodda echo gibi cevap veriyorduk. 
yalnızca get için yani method: "get......" ile gelen mesajlar için özel bir cevabımız olur.
not: burada anlattıklarımın rpc ile ilgilidir, method: "evt" ile gelen mesaj'larla(telemetry) hiçbir ilgisi yok.

ne dersin 2. yol uygun mu, ya da thingsboard ile ilgili bilmediğim bir şey var mı?
---------------
get.runtime.roof.speed.set_point

var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.value;

cmd

return {"type":"speed","set_point":value,"target":"fan"};
----------------------------
thingsboard'un örneğin time series chart widget'leri aşağıdaki gibi bir data post process'e imkan sağlıyor:

"Data post-processing function

function (time, value, prevValue, timePrev, prevOrigValue): any

A JavaScript function doing post-processing on telemetry data.

Parameters:

time: number - timestamp in milliseconds of the current datapoint.
value: primitive (number/string/boolean) - A value of the current datapoint.
prevValue: primitive (number/string/boolean) - A value of the previous datapoint after applied post-processing.
timePrev: number - timestamp in milliseconds of the previous datapoint value.
prevOrigValue: primitive (number/string/boolean) - An original value of the previous datapoint.
Returns:

A primitive type (number, string or boolean) presenting the new datapoint value.

Examples
Multiply all datapoint values by 10:
return value * 10;
Round all datapoint values to whole numbers:
return Math.round(value);
Get relative difference between data points:
if (prevOrigValue) {
    return (value - prevOrigValue) / prevOrigValue;
} else {
    return 0;
}
Formatting data to time format
if (value) {
  return moment(value).format("DD/MM/YYYY HH:mm:ss");
}
return '';
Creates line-breaks for 0 values, when used in line chart
if (value === 0) {
  return null;
} else {
  return value;
}
Display data point of the HTML value card under the condition
return value ? '<div class="info"><b>Temperature: </b>'+value+' °C</div>' : '';"

yani bakıldığında gelen telemetry datasını ancak number/string/boolean bir value olarak kabul ediyor gibi görüyorum.
peki benim mqtt_manager'dan gönderdiğin telemetry datası string olarak mı thingsboard2a ulaşıyor? ya da şöyle sorayım, runtime'ın altından material: {val: 0} olarak gönderiyoruz. 

var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.oxygen_detector.val === "run" ? true : false;
------------------------------
// Post-process function
var source = typeof value !== 'undefined' ? value : data;
var obj = typeof source === 'string' ? JSON.parse(source) : source;

// Örnek: tek bir val değeri döndürmek
if (obj && obj.val !== undefined) {
    return obj.val;
}

// Örnek: nested key (ör. oxygen_detector.val)
if (obj && obj.oxygen_detector && obj.oxygen_detector.val !== undefined) {
    return obj.oxygen_detector.val === "run"; // LED için boolean
}

// Varsayılan
return null;
------------------------------------
context/
 ├─ <flowID>/
 │   ├─ global.json
 │   ├─ flow.json
 │   ├─ <nodeID>.json
 │   ├─ <başkaNodeID>.json
 │   └─ ...
global.json → global.set() ile kaydedilenler

flow.json → flow.set() ile kaydedilenler

<nodeID>.json → node.context().set() ile kaydedilenler

<flowID> klasör ismi, o flow’un internal ID’sidir.

-------------------------
önceki konuya dönersek:

örneğin thingsboard time series chart widget ile runtime'daki water değerini izlemek istiyorum.

thingsboard time series chart için help şöyle:

"Data post-processing function

function (time, value, prevValue, timePrev, prevOrigValue): any

A JavaScript function doing post-processing on telemetry data.

Parameters:

time: number - timestamp in milliseconds of the current datapoint.
value: primitive (number/string/boolean) - A value of the current datapoint.
prevValue: primitive (number/string/boolean) - A value of the previous datapoint after applied post-processing.
timePrev: number - timestamp in milliseconds of the previous datapoint value.
prevOrigValue: primitive (number/string/boolean) - An original value of the previous datapoint.
Returns:

A primitive type (number, string or boolean) presenting the new datapoint value.

Examples
Multiply all datapoint values by 10:
return value * 10;
Round all datapoint values to whole numbers:
return Math.round(value);
Get relative difference between data points:
if (prevOrigValue) {
    return (value - prevOrigValue) / prevOrigValue;
} else {
    return 0;
}
Formatting data to time format
if (value) {
  return moment(value).format("DD/MM/YYYY HH:mm:ss");
}
return '';
Creates line-breaks for 0 values, when used in line chart
if (value === 0) {
  return null;
} else {
  return value;
}
Display data point of the HTML value card under the condition"

yani burada anahtar sözcük value ve primitive (number/string/boolean) diye bir açıklaması var.

bizim mqtt_manager nodu flow tarafından method: "evt" ile gelen mesajları mqtt_out noduna örneğin şöyle bir kodla gönderiyor?
msg.payload={
  water: {val: 15}
}
yani json olarak yazarsak şöyle:
{
  "water": {"val": 15}
}
ve bu gönderim geröekte object midir yoksa string hakine mi getirilmiştir ben bu konuları iyi anlayamadım.
dolayısıyla bir yorum yapamıyorum.
istediğim şey, 15 değerini, yani gelen değerleri chart'ta gösterebilmek.
daha önce bu konuda kod önerileri göndermiştin, widget'in "veri işleme sonrası fonksiyon kullan" editörüne koyabilmem için.
örneğin şu kod:
// value -> ThingsBoard'un grafiklerde verdiği parametre
if (typeof value === 'string') {
    try {
        value = JSON.parse(value);
    } catch (e) {
        return null; // JSON parse hatasında veri yokmuş gibi davran
    }
}

// value bir nesne ise "val" alanını döndür
if (value && typeof value === 'object' && 'val' in value) {
    return value.val;
}

// primitive ise direkt döndür
return value;
kodu ilgili alana koyduğumda aşağıdaki satırda "Read only" uyarı ikonunu görüyorum editörde.
lütfen bu konuyu çözmemi sağlayacak olan kodu yazabilir misin?
veya acaba mümkün olmayacak mı, mqtt_manager'dan mesaj gönderim yapımızı mı değiştirmeliyiz, umarım gerek kalmaz.

gönderdiğin şu kodu denedim önce bir uyarı ve bir de hata veriyor.

if (typeof value === 'string') {
    value = JSON.parse(value);
}
return value.val;
uyarı ikonu value = JSON.parse(value); satırında, "Read only".
Ekle(Add) butonuna bastığımda ise "Fonksiyon bir değer döndürmelidir" hata mesajı geliyor ekrana ve kabul etmiyor.
bir de şöyle denedim;
var x;
if (typeof value === 'string') {
    x = JSON.parse(value);
}
return x.val;
uayrı ikonu yok ama hata aynı ve kabul etmiyor.
--------------------
{"state":"stop"}
-----------------
tekrardan merhaba,
aşağıdaki analog_pro kodunu ve flow_context ile uymunu incelemeni rica ediyorum.
bazı isim değişiklikleri yapmış olsam da sağlıklı çalışıyordur.
karışıklık olamsın, bu adımda key'lerden yalnız _ang_ olanlar ilgi alanımızdadır.
_dig_ olanlar bir sonraki adımda sıfırdan yazacağımız digital_pro adlı fonksiyon nodunda kullanılacaklar.
şimdi hem bir sorun var mı diye kontrol etmeni hem de hysteresis'i görmeni istiyorum.
tabi ki sonraki adımda digital_pro'daki hysteresis kodu _dig_ key'leri birazcık farklı yorumlayacak.
_dig_, _ang_ ayrımını merak etmişsindir;
projede bir oxygen bir de humidity sensör cihazları var, hem analog 4-20ma(ang) hem de 2 adet alarm switch(dig) çıkış sağlıyorlar.
dig olanlar'ın eşikleri cihazların kendinde parametre olarak girilmiş olur.
ang ise parametreleri flow_context'te olup eşikler analog_pro'da oluşturulur.
şimdilik hangi çıkış tipinin kullanılacağı belli değil, o nedenle her ihtimale açık olsun diye flow, böyle yapıyorum.

analog_pro:

flow_context:
----------------
LED OLD
var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.body === "run" ? true : false;
----------------

flow'da kodları yazılmış halde 12 adet fonksiyon nodu var.
bunlardan biri flow_context. daha önce bahsettiğim gibi settings.js'de kalıcılık ayarı yapıldıktan sonra dosya haline dönüşecek, fakat şimdilik flow context'ini her node red restart'ında bir inject yardımıyla bu nodu elle yüklemiş oluyorum.
sen bir konuda beni uyardın, flow context'i üzerinde çok kısa zaman'lar içinde bir çok nodun işlem yapması, özellikle yazma/güncelleme işlemi, çeşitli sorunlara neden olabilir diyerek.
ve nodların bu işlemi tümden değil de sadece gerekli kısmın güncellenmesi ile yapmasının daha iyi olacağını, merge yöntemini bildirdin.
şimdi nasıl bir yol izleyelim ki tüm nodları bu merge yöntemi ile çalışır hale getirelim.
her adımda sana hem değişecek nodu hem de yanında flow_context nodunu göndereyim ve sen de nodu değiştir desem uygun mudur?


mergeDeep(flowData, newData);
flow.set("flow", flowData);

....

function mergeDeep(target, source) {
    for (const key of Object.keys(source)) {
        if (
            source[key] &&
            typeof source[key] === "object" &&
            !Array.isArray(source[key])
        ) {
            if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key])) {
                target[key] = {};
            }
            mergeDeep(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}
------------------
aklıma şu geldi, acaba merge tekniğini yalnızca timer_manager'da mı kullansak, diğer nodlarda buna gerek olmadığını mı düşünsek.
flow'da yalnızca timer_manager nodu periyodik olarak tetikleniyor ve sanki diyelim background gibi işlem yapıyor. diğer tüm nodlar ise bir sıralama ile tetiklenirler en kötü senaryoda bile, yani birinin flow context'i ile işi bitmeden ve mesaj çıkarmadan diğeri tetiklenmez henüz.
bilmiyorum tam anlatabildim mi? tamam bunun yanında digital_inputs vb. nodlar da var, her 100ms'de bir modbus flex getter'ın yolladığı veriyi kontrol ediyorlar, ama kendi node context'leri ile bunu yapıyorlar, ve yalnızca bir değişiklik varsa flow context'ini güncelliyorlar ki bu değişiklik mesela bir butona basılmasıdır.
evet bir butona basıldığında ardarda nodlar tetikleniyor ama dediğim gibi sıralıdır. fakat ben javascript konusunu iyi bilmediğimden thread yönetimi nasıl bilmediğimden bu konuda yorum yapamıyorum. senin fikrini merak ettim.
------------------------
evet beni çok iyi anladın.
öyleyse sadece node context'ini kullanalım merge ile yazma konusundan tamamen vazgeçelim.
flow'daki hiçbir nod'a (timer_manager dahil) merge fonksiyonu eklemeyeceğiz. 
ve şimdi gelelim timer_manager'a:  
talebim tam olarak şöyle.
timer_manager nodu flow context'ini hiç kullanmasın, oradaki ihtiyacını tamamen node context'inde halletsin, yani kendi node context'ini kullansın tamamen.
sonra ben de flow_context nodunun kodundaki runtime alanındaki aşağıdaki satırları tamamen sileyim, sen bunları node context'i olacak biçimde kullan ki timer'lar için core kodlar değişmesin, yani node context'ine taşı bunları.
fan_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
water_pump_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
light_pulse: {val: "off", on_time: 0, done: false},
light_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
buzzer_pulse: {val: "off", on_time: 0, done: false},
buzzer_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
day_counter: {val: "off", on_time: 0, count: 21, next_time: 0},
telemetry_periodical: {val: "off", on_time: 0, next_time: 0},
not: timer_manager'ın mevcut mesaj üretme ve onları çıkış portlarına yönlendirme, timer logic'leri ve benzeri hiçbir işlevi bozulmasın.

şimdi original kodları tekrar gönderiyorum.

timer_manager:
----------
var obj = (typeof value === 'string') ? JSON.parse(value) : value;
if (obj && obj.val !== undefined) {
    return obj.val.toUpperCase();
}
return null;

dd/MM/yyyy hh:mm
-------------------
en son olarak analog_inputs kodunu yazmıştık. şimdi ise aynı context yaklaşımları ve aynı change tekniği ile energy_meter'i düzenleyelim.
zaten bu iki nod birbirine benzerdir.

önce analog_inputs'u ve flow_context'i tekrar göndereyim referans olarak, sonraki adımda da energy_meter'i göndereyim düzenleme yapman için.
hazır mısın?

analog_inputs:
{"method": "cmd", "params": {"type": "speed", "set_point": 50, "target": "roof"}}
---
timer_manager'daki değişiklik için flow_context'in runtime alanına aşağıdaki satırı ekledim.
day: {val: null},
yapmak istediğim şey; day(count) değerini runtime'da da tutup, oraya da yazılmasını sağlayıp, mqtt_manager'ın telemetry_periodical ile toplu publish'ine de dahil olmasını sağlamak.
helen tekil event olarak mqtt_manager'dan publish ediliyor, 3. porttan oraya gönderiliyor her gün azalışında.
oraya null yazdım, onun yerine 21 de yazabilirdim, hangisini yazmak daha iyi, veya fark eder mi?
zaten day_counter başlatıldığında hemen config'deki base değerini oraya yazsın.
config'te de aynı null kullanımı var:
4: {method: "evt", params: {type: "day", val: null}, port: 3} // val: count
yani açıkçası null yerine count gelecek hepsi o kadar fakat ifade edemiyorum bir türlü.
ve sanırım null konusu nedeniyle timer_manager'da gereksiz bir kod kısmı da var, tam emin değilim.
null konusunu lütfen çözelim pratik bir yoldan.
yani her iki yerde de(config, runtime) 21 yazsak doğrudan, ne problem olur?
yani 21'in bir parametrik değişken olması nedeniyle başlangıç değerini bilemediğimden tasarım zamanında null yazıyorum, kurtulalım o konudan. 

şimdi kodları gönderiyorum, timer_manager'da değişiklik için ve hatta varsa farklı bir önderin null yerine, flow_context'te de o değişikliği yapayım.

timer_manager:
if (method === "cmd") {
  if (timers[target]) {
    if (!runtime[target]) {
      runtime[target] = {};
    }
    if (type === "on") {
      timerOn(timers[target], runtime[target], Date.now(), out, target);
    } else if (type === "off") {
      timerOff(timers[target], runtime[target], out, target);
    }
  } else if (target === "all" && type === "off") {
    for (const [key, timer] of Object.entries(timers)) {
      if (!runtime[key]) {
        runtime[key] = {};
      }
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    out[1].push(msg);
  }
} else if (method === "evt" && type === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}

case "cmd" için case "fsm" değilse bir istisna hariç gelen tüm komutlar hiç dokunulmadan 1. porttan (outputs[0]) çıkacak, yani doğrudan çıkışa iletilecek.
istisna şöyle; eğer case "cmd" ve case "roof" ise:
--------------
güzel oldu.
bence, önce tekrar edip duran şu konuya bir çözüm bulalım. bir fonksiyona argüman olarak paslayalım, argümanlara baktığımızda zaten anlarız, yani okunaklı kalır yine.. tabi 1. port'tan (sanırım hep "method: "cmd" ile çıkıyor değil mi, ve 2. port'tan ise sadece "evt" ile çıkıyor diye küçük bir hatırlatma da yapmış olayım.
yani şunları:
outputs[0].push({ payload: { method: "on", params: { target: "water_pump_pwm" } } });
----------------------
actuators güzel çalışıyor.
fakat bir istisna dışında, en son üzerinde uğraşmış olduğumuz toplu off ile ilgili kod kısmı,
actuators'a gelen şu mesaj'a karşılık;
msg.payload={"method": "cmd", "params": {"type": "off", "target": "all"}}
yani kodda ilgili kısım sanırım şuradan başlayan;
// === Toplu OFF ===
if (type === "off" && target === "all") {
  .....
actuators bu mesajı aldığında 3 nolu port'tan başarılı biçimde ardarda tüm mesajları gönderiyor, method: "evt"'li olarak herbiri. 
ve 2 nolu port'tan sinamics'ler için tüm modbus mesajlarını da gönderiyor başarılı olarak.
fakat 1 nolu port'tan göndermesi gereken (relay_outputs_1 ve relay_outputs_2 ile ilgili) modbus mesajlarını göndermiyor.
yanlış test ediyor olabilir miyim bilmiyorum, lütfen sen de kodu kontrol et ve dediğim gibi bir sorun varsa çözümünü sağlayabilirsin.

Modbus Failure On State sending Get More About It By Logging


şöyle çalışsın;
önce 2 saniye beklesin, sonra  
------------------

flow_context'te sinamics altındaki restore_delay satırını sileceğim, restore'de varsa gereken süre(ler)'i hard code yapalım.
restore kodunu restore fonksiyon nodunun "on start" sekmesine yazıyoruz ki node red başladığında hemen bu kod çalışsın diye.
ben node red'in settings.js'sinde contextstorage için filememory olarak kalıcılık ayarı yapacağım. 
şöyle çalışsın.
öncelikle şu mesajı göndersin ve sisteme enerji gitsin;
msg.payload={"method": "cmd", "params": {"type": "on", "target": "emergency_contactor"}}
sonra 5 saniye bekleyip şu mesajları koddaki mevcut yöntemle zaman aralığı vererek göndermeye başlasın;
msg.payload={"method": "cmd", "params": {"type": "off", "target": "all"}}
// Eğer hız bilgisi varsa onu da ekle (sinamics'lerle ilgili)
yukarıdaki değişikliklerde mevcut koddaki yöntemleri koruyalım.
--------------
kodları flow'a yükle
restore dene
thingsboard ile dene
analog_inputs'u dene
digital_inputs'u dene
service enable yap
settings yap dosyalara bak
pi connect dene
kart kopyala
----------------------
mv flows.json flows.json.bak      # mevcut dosyayı yedekle
nano flows.json
-------------------------
actuators'un sinamics'lerle ilgili method: "evt" olarak çıkardığı mesaj yapısını değiştirmeliyim.
aktiflik/yön komutları geldiğinde şöyle çıkarıyor, bu hızı göstermiyor oluyor:
msg.payload={"method": "evt", "params": {"type": "roof", "val": "forward_on"}}
hız komutlarında ise şöyle bir şey çıkarıyor, bu da sorunlu.
msg.payload={"method": "evt", "params": {"type": "roof", "val":{"speed":{"set_point":100}}}}
benim flow'da bir de mqtt_manager fonksiyon nodu var, tekil evt'leri ve method: "evt", params: {type: "telemetry_periodical", val: null} olarak gelenleri aynı mesaj yapısyla gönderiyor, tasarımı öyledir.
acaba actuators'da nasıl bir düzenleme yapsam?
sinamics'ler için çıkan mesajlarda hem aktiflik/yön ve hem de hız bilgilerini daima birlikte mi çıkarsak, hangisi değişmiş olursa olsun fark etmeden?
yani sinamics mesajları actuators'den daima şu örnek yapıdaki gibi mi çıksa iyi olur, ne dersin?
msg.payload={"method": "evt", "params": {"type": "roof", "speed":{"set_point":100}, "val": "forward_on"}}
örneğin flow context'inde şöyle yer alıyorlar:
roof: {speed: {set_point: 100}, val: "off"}
actuators'da bu düzenlemeyi yaptıktan sonra mqtt_manager nodunu da eğer gerekiyorsa uyumlu hale getirelim, öenemli bir sorun oldu bu bana.

istersen birazdan actuators ve flow_context kodlarını tekrar göndereyim sana.
not: flow_context nodunu artık flow'da kullanmıyorum(artık context filememory2den yükleniyor, kalıcıdır), ama içeriği oradan görebiliyoruz.





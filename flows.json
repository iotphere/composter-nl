[
    {
        "id": "2d8538969c77a5df",
        "type": "tab",
        "label": "my_flow",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "0719549b97c80402",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "write_relay_outputs",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "server": "c3488bd8821ff6d8",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "10",
        "x": 1270,
        "y": 540,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "ecf66dea2db91aea",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs",
        "func": "const ctx = context;\nconst flowData = flow.get(\"flow\");\n\nconst labels = flowData.config.labels;\nconst digitalInputs = flowData.config.io.digital_inputs;\nconst channels = digitalInputs.channels;\n\n// Giriş verisi: [<number>] şeklinde array\nconst rawVal = msg.payload?.[0];\nif (typeof rawVal !== \"number\") return null;\n\n// Hafıza başlat (bit geçmişi)\nif (!ctx.get(\"history\")) {\n  ctx.set(\"history\", {});\n}\nconst history = ctx.get(\"history\");\n\n// Değişen input'lar buraya\nconst changed = [];\n\nfor (const [key, def] of Object.entries(channels)) {\n  const bitIndex = def.map;\n  const bitVal = (rawVal >> bitIndex) & 1;\n  const newVal = labels[String(bitVal === 1)]; // \"true\"/\"false\" string olarak erişim\n\n  if (!history[key]) {\n    history[key] = [newVal];\n    // İlk seferde runtime'a yaz\n    if (flowData.runtime[key].val !== newVal) {\n      flowData.runtime[key].val = newVal;\n      changed.push({\n        payload: {\n          method: \"evt\",\n          params: { type: key, val: newVal }\n        }\n      });\n    }\n    continue;\n  }\n\n  const prevStates = history[key];\n  prevStates.push(newVal);\n  if (prevStates.length > 2) prevStates.shift();\n\n  const [prev, curr] = prevStates;\n\n  if (prev === curr && flowData.runtime[key].val !== curr) {\n    flowData.runtime[key].val = curr;\n    changed.push({\n      payload: {\n        method: \"evt\",\n        params: { type: key, val: curr }\n      }\n    });\n    history[key] = [curr];\n  } else {\n    history[key] = prevStates;\n  }\n}\n\nctx.set(\"history\", history);\n\n// Runtime'ı sadece değişiklik varsa yaz\nif (changed.length > 0) {\n  flow.set(\"flow\", flowData);\n  return [changed];\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 160,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c",
                "2b810660372548f4"
            ]
        ]
    },
    {
        "id": "db72d07653f1bbe9",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs",
        "func": "const flowData = flow.get(\"flow\");\nconst analogInputs = flowData.config.io.analog_inputs;\nconst channels = analogInputs.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    const raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    let scaled = raw;\n    if (def.scale) {\n        const { in_min, in_max, out_min, out_max } = def.scale;\n        scaled = ((raw - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;\n    }\n    scaled = parseFloat(scaled.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(scaled - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'te sakla\n        lastVals[key] = scaled;\n\n        // Flow runtime'a yaz\n        flowData.runtime[key].val = scaled;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: scaled\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 240,
        "wires": [
            [
                "54a9a79a7c485b62"
            ]
        ]
    },
    {
        "id": "1b7f0d4c81a3700c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter",
        "func": "const flowData = flow.get(\"flow\");\nconst channels = flowData.config.energy_meter.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    let raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    // Çarpan uygula (ör: factor)\n    if (def.factor) {\n        raw *= def.factor;\n    }\n\n    raw = parseFloat(raw.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(raw - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'e son değeri yaz\n        lastVals[key] = raw;\n\n        // Flow context runtime'a yaz\n        flowData.runtime[key].val = raw;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: raw\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 320,
        "wires": [
            [
                "8b647d54a390a264"
            ]
        ]
    },
    {
        "id": "8d59f82c1f6e0d51",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "get_digital_inputs",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "2206e55e928c8b8f",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 160,
        "wires": [
            [
                "ecf66dea2db91aea"
            ],
            []
        ]
    },
    {
        "id": "14e917ac3699c006",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "0.1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 11, \"address\": 144 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 130,
        "y": 160,
        "wires": [
            [
                "8d59f82c1f6e0d51"
            ]
        ]
    },
    {
        "id": "532186e49e9bd932",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 12, \"address\": 160 , \"quantity\": 8}",
        "payloadType": "json",
        "x": 140,
        "y": 220,
        "wires": [
            [
                "890e808611421ece"
            ]
        ]
    },
    {
        "id": "d1db2b67e2afbffe",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 1, \"address\": 29 , \"quantity\": 2}",
        "payloadType": "json",
        "x": 130,
        "y": 320,
        "wires": [
            [
                "6f4e90bab79df245"
            ]
        ]
    },
    {
        "id": "6f4e90bab79df245",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "get_energy_meter",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 320,
        "wires": [
            [
                "1b7f0d4c81a3700c"
            ],
            []
        ]
    },
    {
        "id": "155eb5f34a3f5ca3",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "write_sinamics",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "9703a3f2808e2fa6",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1260,
        "y": 600,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "69b69a40e08aa884",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "actuators",
        "func": "const flowData = flow.get(\"flow\");\nconst config = flowData.config;\nconst runtime = flowData.runtime;\n\nconst payload = msg.payload;\nif (!payload || payload.method !== \"cmd\" || typeof payload.params !== \"object\") return null;\n\nconst { type, target, set_point } = payload.params;\nif (!type || !target) return null;\n\nconst relayChannels1 = config.io.relay_outputs_1.channels || {};\nconst relayChannels2 = config.io.relay_outputs_2.channels || {};\nconst unitid1 = config.io.relay_outputs_1.unitid;\nconst unitid2 = config.io.relay_outputs_2.unitid;\n\nlet currentArray1 = context.get(\"last_write_array_1\") || Array(8).fill(false);\nlet currentArray2 = context.get(\"last_write_array_2\") || Array(8).fill(false);\n\nfunction getRelayInfo(name) {\n  if (relayChannels1?.[name]) return { array: currentArray1, bit: relayChannels1[name].map, unitid: unitid1, arrayName: \"last_write_array_1\" };\n  if (relayChannels2?.[name]) return { array: currentArray2, bit: relayChannels2[name].map, unitid: unitid2, arrayName: \"last_write_array_2\" };\n  return null;\n}\n\nfunction createRelayMsg(array, unitid, arrayName) {\n  let word = 0;\n  for (let i = 0; i < 8; i++) {\n    if (array[i]) word |= (1 << i);\n  }\n  context.set(arrayName, array);\n  return {\n    payload: {\n      value: word,\n      fc: 6,\n      unitid,\n      address: 128,\n      quantity: 1\n    }\n  };\n}\n\nconst relayMsgs = [];\nconst sinamicsMsgs = [];\nconst evtMsgs = [];\n\n// === Toplu OFF ===\nif (type === \"off\" && target === \"all\") {\n  currentArray1 = Array(8).fill(false);\n  currentArray2 = Array(8).fill(false);\n\n  // emergency_contactor'u koru\n  const emBit = relayChannels2.emergency_contactor?.map;\n  if (emBit !== undefined) {\n    currentArray2[emBit] = runtime.emergency_contactor?.val === \"on\";\n  }\n\n  context.set(\"last_write_array_1\", currentArray1);\n  context.set(\"last_write_array_2\", currentArray2);\n\n  // runtime ve evtMsgs güncelle (emergency_contactor hariç)\n  for (const name of Object.keys({ ...relayChannels1, ...relayChannels2 })) {\n    if (name === \"emergency_contactor\") continue;\n    if (runtime[name]) {\n      runtime[name].val = \"off\";\n      evtMsgs.push({ payload: { method: \"evt\", params: { type: name, val: \"off\" } } });\n    }\n  }\n\n  // Sinamics OFF işlemleri\n  for (const [name, sin] of Object.entries(config.sinamics?.channels || {})) {\n    sinamicsMsgs.push({\n      payload: {\n        value: config.sinamics.command_words.off,\n        fc: 6,\n        unitid: sin.unitid,\n        address: 99,\n        quantity: 1\n      }\n    });\n    if (!runtime[name]) runtime[name] = {};\n    runtime[name].val = \"off\";\n\n    // Sinamics evt mesajını hem val hem speed ile gönder\n    evtMsgs.push({\n      payload: {\n        method: \"evt\",\n        params: {\n          type: name,\n          val: runtime[name].val,\n          speed: runtime[name].speed ? { set_point: runtime[name].speed.set_point } : undefined\n        }\n      }\n    });\n  }\n\n  // Loader OFF işlemleri\n  const loaderKeys = Object.entries({ ...relayChannels1, ...relayChannels2 })\n    .filter(([_, val]) => val.group === \"loader\")\n    .map(([key]) => key);\n\n  loaderKeys.forEach(key => {\n    const r = getRelayInfo(key);\n    if (r) r.array[r.bit] = false;\n  });\n  runtime.loader = { val: \"off\" };\n  evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader\", val: \"off\" } } });\n\n  // Röle mesajlarını kuyrukla\n  relayMsgs.push(createRelayMsg(currentArray1, unitid1, \"last_write_array_1\"));\n  relayMsgs.push(createRelayMsg(currentArray2, unitid2, \"last_write_array_2\"));\n\n} else {\n  // Sinamics kontrolü\n  const sinamics = config.sinamics?.channels?.[target];\n  if (sinamics) {\n    const unitid = sinamics.unitid;\n    const commandWords = config.sinamics.command_words;\n    const speedMax = config.sinamics.speed_max;\n\n    if ([\"forward_on\", \"reverse_on\", \"off\"].includes(type)) {\n      const value = commandWords[type];\n      if (value != null) {\n        sinamicsMsgs.push({\n          payload: {\n            value,\n            fc: 6,\n            unitid,\n            address: 99,\n            quantity: 1\n          }\n        });\n        if (!runtime[target]) runtime[target] = {};\n        runtime[target].val = type;\n      }\n    }\n\n    if (type === \"speed\" && typeof set_point === \"number\") {\n      const value = Math.round(set_point / 100 * speedMax);\n      sinamicsMsgs.push({\n        payload: {\n          value,\n          fc: 6,\n          unitid,\n          address: 100,\n          quantity: 1\n        }\n      });\n      if (!runtime[target]) runtime[target] = {};\n      if (!runtime[target].speed) runtime[target].speed = {};\n      runtime[target].speed.set_point = set_point;\n    }\n\n    // Sinamics evt mesajını her zaman hem val hem speed ile gönder\n    evtMsgs.push({\n      payload: {\n        method: \"evt\",\n        params: {\n          type: target,\n          val: runtime[target].val,\n          speed: runtime[target].speed ? { set_point: runtime[target].speed.set_point } : undefined\n        }\n      }\n    });\n\n  } else {\n    // Röle kontrolü\n    if ([\"on\", \"off\"].includes(type)) {\n      const relay = getRelayInfo(target);\n      if (relay) {\n        const val = type === \"on\";\n        relay.array[relay.bit] = val;\n        runtime[target] = { val: type };\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: target, val: type } } });\n      }\n    }\n\n    // Loader kontrolü\n    if (target === \"loader\" && [\"forward_on\", \"reverse_on\", \"off\"].includes(type)) {\n      const relayKeys = Object.entries({ ...relayChannels1, ...relayChannels2 })\n        .filter(([_, val]) => val.group === \"loader\")\n        .map(([key]) => key);\n\n      const relays = Object.fromEntries(\n        relayKeys.map(key => [key, getRelayInfo(key)]).filter(([_, info]) => info)\n      );\n\n      const motor = relays[\"loader_motor\"];\n      const fwd = relays[\"loader_forward_valve\"];\n      const rev = relays[\"loader_reverse_valve\"];\n\n      if (motor && fwd && rev) {\n        if (type === \"forward_on\") {\n          motor.array[motor.bit] = true;\n          fwd.array[fwd.bit] = true;\n          rev.array[rev.bit] = false;\n        } else if (type === \"reverse_on\") {\n          motor.array[motor.bit] = true;\n          fwd.array[fwd.bit] = false;\n          rev.array[rev.bit] = true;\n        } else if (type === \"off\") {\n          motor.array[motor.bit] = false;\n          fwd.array[fwd.bit] = false;\n          rev.array[rev.bit] = false;\n        }\n        runtime.loader = { val: type };\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader\", val: type } } });\n      }\n    }\n\n    // Röle mesajları yalnızca relay işlemleri yapıldıysa oluşturulsun\n    relayMsgs.push(createRelayMsg(currentArray1, unitid1, \"last_write_array_1\"));\n    relayMsgs.push(createRelayMsg(currentArray2, unitid2, \"last_write_array_2\"));\n  }\n}\n\n// flowContext güncelle\nflow.set(\"flow\", flowData);\n\n// === aralıkla mesaj gönderme ===\nconst allMsgs = [];\nrelayMsgs.forEach(m => allMsgs.push([0, m])); // port 1\nsinamicsMsgs.forEach(m => allMsgs.push([1, m])); // port 2\nevtMsgs.forEach(m => allMsgs.push([2, m])); // port 3\n\nallMsgs.forEach((item, i) => {\n  const [portIndex, msgObj] = item;\n  setTimeout(() => {\n    node.send([\n      portIndex === 0 ? msgObj : null,\n      portIndex === 1 ? msgObj : null,\n      portIndex === 2 ? msgObj : null\n    ]);\n  }, i * 50);\n});\n\n// Bu function node'dan anında bir şey döndürmüyoruz\nreturn null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 540,
        "wires": [
            [
                "0719549b97c80402"
            ],
            [
                "155eb5f34a3f5ca3"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "0defb2d453130745",
        "type": "mqtt in",
        "z": "2d8538969c77a5df",
        "name": "mqtt_in",
        "topic": "v1/devices/me/rpc/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "e1d018cea69d77b6",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 570,
        "y": 60,
        "wires": [
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "b7b87a40dd91a021",
        "type": "mqtt out",
        "z": "2d8538969c77a5df",
        "name": "mqtt_out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "e1d018cea69d77b6",
        "x": 1240,
        "y": 60,
        "wires": []
    },
    {
        "id": "c3f4a0e8f8030852",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "flow_context",
        "func": "const flowData = {\n  config: {\n    labels: {true: \"on\", false: \"off\"},\n    io: {\n      digital_inputs: {\n        config_node: \"201_115200_tcp_rtu_dig_inp\",\n        unitid: 11,\n        channels: {        \n          oxygen_detector_dig_off: {map: 0, pro: {oxygen_detector_dig: \"off\"}},\n          oxygen_detector_dig_on: {map: 1, pro: {oxygen_detector_dig: \"on\"}},\n          humidity_detector_dig_off: {map: 2, pro: {humidity_detector_dig: \"off\"}},\n          humidity_detector_dig_on: {map: 3, pro: {humidity_detector_dig: \"on\"}},\n          roof_forward_limit: {map: 4},\n          roof_reverse_limit: {map: 5},\n          cabinet_door: {map: 6},\n          emergency_button: {map: 15}\n        }      \n      },\n      analog_inputs: {\n        config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n        unitid: 12,        \n        channels: {\n          oxygen: {map: 0, change: 0.5, scale: {in_min: 400, in_max: 2000, out_min: 0, out_max: 100}, pro: {oxygen_detector_ang: {off: 30, on: 60}}},\n          humidity: {map: 1, change: 0.5, scale: {in_min: 400, in_max: 2000, out_min: 0, out_max: 100}, pro: {humidity_detector_ang: {off: 30, on: 60}}}\n        }\n      },\n      relay_outputs_1: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 13,\n        channels: {\n          light: {map: 6},\n          buzzer: {map: 7}\n        }\n      },\n      relay_outputs_2: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 14,\n        channels: {\n          loader_forward_valve: {map: 4, group: \"loader\"},\n          loader_reverse_valve: {map: 5, group: \"loader\"},\n          loader_motor: {map: 6, group: \"loader\"},\n          emergency_contactor: {map: 7}\n        }\n      }\n    },\n    energy_meter: {\n      config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n      unitid: 1,      \n      channels: {\n        kwh: {map: 0, factor: 0.01, change: 2, pro: {kwh_detector: {off: 30, on: 60}}}\n      }\n    },  \n    sinamics: {\n      config_node: \"202_9600_tcp_rtu_sinamics\",\n      command_words: {forward_on: 1279, reverse_on: 3327, off: 1278},\n      speed_max: 16384, // modbus send >> set_point / 100 * speed_max\n      channels: {\n        roof: {unitid: 11},\n        fan: {unitid: 12},\n        water_pump: {unitid: 13},\n        discharger: {unitid: 14}\n      }\n    },\n    timers: {      \n      fan_pwm: {\n        form: \"pwm\",\n        t_duty: 2, t_cycle: 3, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"forward_on\", target: \"fan\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"fan\"}, port: 2}\n        }\n      },\n      water_pump_pwm: {\n        form: \"pwm\",\n        t_duty: 2, t_cycle: 3, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"forward_on\", target: \"water_pump\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"water_pump\"}, port: 2}\n        }\n      },\n      light_pulse: {\n        form: \"delay\", duration: 2, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"light\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"light\"}, port: 2}\n        }\n      },\n      light_pwm: {\n        form: \"pwm\", t_duty: 2, t_cycle: 4, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"light\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"light\"}, port: 2}\n        }        \n      },\n      buzzer_pulse: {\n        form: \"delay\", duration: 3, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"buzzer\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"buzzer\"}, port: 2}\n        }\n      },\n      buzzer_pwm: {\n        form: \"pwm\", t_duty: 2, t_cycle: 4, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"buzzer\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"buzzer\"}, port: 2}\n        }        \n      },\n      day_counter: {\n        form: \"counter\", direction: \"down\", interval: 1, base: 21, signal: 3, unit: \"d\",\n        pass: {\n          2: {method: \"cmd\", params: {type: \"dry\", target: \"fsm\"}, port: 1},\n          3: {method: \"cmd\", params: {type: \"end\", target: \"fsm\"}, port: 1},\n          4: {method: \"evt\", params: {type: \"day\", val: 0}, port: 3} // val: count\n        }             \n      },\n      telemetry_periodical: {\n        form: \"loop\", interval: 2, unit: \"min\",\n        pass: {\n          4: {method: \"evt\", params: {type: \"telemetry_periodical\", val: null}, port: 3}\n        }        \n      }\n    }\n  },\n  runtime: {\n    oxygen_detector_dig_off: {val: \"off\"},\n    oxygen_detector_dig_on: {val: \"off\"},\n    humidity_detector_dig_off: {val: \"off\"},\n    humidity_detector_dig_on: {val: \"off\"},\n    roof_forward_limit: {val: \"on\"},\n    roof_reverse_limit: {val: \"on\"},\n    cabinet_door: {val: \"off\"},\n    emergency_button: {val: \"off\"},\n    oxygen: {val: 0},\n    humidity: {val: 0}, \n    loader_forward_valve: {val: \"off\"},\n    loader_reverse_valve: {val: \"off\"},\n    loader_motor: {val: \"off\"},\n    emergency_contactor: {val: \"off\"},\n    light: {val: \"off\"},\n    buzzer: {val: \"off\"},  \n    roof: {speed: {set_point: 100}, val: \"off\"},\n    fan: {speed: {set_point: 100}, val: \"off\"},\n    water_pump: {speed: {set_point: 100}, val: \"off\"},\n    discharger: {speed: {set_point: 100}, val: \"off\"},\n    loader: {val: \"off\"},\n    kwh: {val: 0},\n    oxygen_detector_dig: {val: \"off\"},\n    oxygen_detector_ang: {val: \"off\"},\n    humidity_detector_dig: {val: \"off\"},\n    humidity_detector_ang: {val: \"off\"},\n    kwh_detector: {val: \"off\"},\n    day: {val: 0}, // val: count\n    fsm: {state: \"stop\"}\n  }\n}\n\nflow.set(\"flow\", flowData);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "2467bf030b733b1e",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "flow_context_inject",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "c3f4a0e8f8030852"
            ]
        ]
    },
    {
        "id": "8701a07643f54a7b",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "timer_manager",
        "func": "const flowData = flow.get(\"flow\");\nconst timers = flowData.config.timers;\n\nconst method = msg?.payload?.method || msg?.method;\nconst params = msg?.payload?.params || msg?.params || {};\nconst target = params.target;\nconst type = params.type;\n\nconst out = [[], [], []]; // Port 1,2,3\n\nlet runtime = context.get(\"runtime\") || {};\n\nfunction toMs(val, unit) {\n  const map = { s: 1000, min: 60000, h: 3600000, d: 86400000 };\n  return val * (map[unit] ?? 1000);\n}\n\nfunction pushMessage(timer, passKey, out, runtime = {}, target = null) {\n  const entry = timer.pass?.[passKey];\n  if (!entry) return;\n\n  const message = RED.util.cloneMessage(entry);\n  const port = (entry.port ?? 0) - 1;\n\n  if (port < 0 || port > 2) return;\n\n  delete message.port;\n\n  // Runtime'dan dinamik parametreleri al, val her zaman runtime[target].count olsun\n  if (message.params && target && runtime[target]) {\n    for (const [key, val] of Object.entries(message.params)) {\n      if (val === null && runtime[target][key] !== undefined) {\n        message.params[key] = runtime[target][key];\n      } else if (\n        typeof val === \"object\" &&\n        val !== null &&\n        \"val\" in val\n      ) {\n        message.params[key].val = runtime[target].count;\n      }\n    }\n  }\n\n  out[port].push({ payload: message });\n}\n\nfunction timerOn(timer, rt, now, out, target) {\n  rt.state = \"on\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.on_time = now;\n      rt.done = false;\n      rt.phase_until = now + toMs(timer.duration, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"pwm\":\n      rt.on_time = now;\n      rt.phase = \"a\";\n      rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"loop\":\n      rt.on_time = now;\n      rt.next_time = now + toMs(timer.interval, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"counter\":\n      rt.on_time = now;\n      rt.count = timer.base;\n      rt.next_time = now + toMs(timer.interval, timer.unit);\n      pushMessage(timer, 1, out, runtime, target);\n      pushMessage(timer, 4, out, runtime, target);\n      break;\n  }\n}\n\nfunction timerOff(timer, rt, out, target, suppressMessages = false) {\n  rt.state = \"off\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.done = true;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"pwm\":\n      rt.phase = null;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"loop\":\n      if (!suppressMessages) pushMessage(timer, 1, out);\n      break;\n\n    case \"counter\":\n      rt.count = 0;\n      if (!suppressMessages) {\n        pushMessage(timer, 3, out, runtime, target);\n        pushMessage(timer, 4, out, runtime, target);\n      }\n      break;\n  }\n}\n\nfunction timerTick(timers, runtime, now, out) {\n  for (const [key, timer] of Object.entries(timers)) {\n    const rt = runtime[key];\n    if (!rt || rt.state !== \"on\") continue;\n\n    switch (timer.form) {\n      case \"delay\":\n        if (!rt.done && now >= rt.phase_until) {\n          rt.done = true;\n          pushMessage(timer, 2, out);\n        }\n        break;\n\n      case \"pwm\":\n        if (now >= rt.phase_until) {\n          if (rt.phase === \"a\") {\n            rt.phase = \"b\";\n            rt.phase_until = now + toMs(timer.t_cycle - timer.t_duty, timer.unit);\n            pushMessage(timer, 2, out);\n          } else {\n            rt.phase = \"a\";\n            rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n            pushMessage(timer, 1, out);\n          }\n        }\n        break;\n\n      case \"loop\":\n        if (now >= rt.next_time) {\n          rt.next_time = now + toMs(timer.interval, timer.unit);\n          pushMessage(timer, 1, out);\n        }\n        break;\n\n      case \"counter\":\n        if (now >= rt.next_time && rt.count > 0) {\n          rt.count -= 1;\n          rt.next_time = now + toMs(timer.interval, timer.unit);\n\n          if (timer.signal !== undefined && rt.count === timer.signal) {\n            pushMessage(timer, 2, out, runtime, key);\n          }\n\n          pushMessage(timer, 4, out, runtime, key);\n\n          if (rt.count === 0) {\n            rt.state = \"off\";\n            pushMessage(timer, 3, out, runtime, key);\n          }\n        }\n        break;\n    }\n  }\n}\n\nif (method === \"cmd\") {\n  if (timers[target]) {\n    if (!runtime[target]) {\n      runtime[target] = {};\n    }\n    if (type === \"on\") {\n      timerOn(timers[target], runtime[target], Date.now(), out, target);\n    } else if (type === \"off\") {\n      timerOff(timers[target], runtime[target], out, target);\n    }\n  } else if (target === \"all\" && type === \"off\") {\n    // Tüm timer'ları kapat ve sadece 1 mesaj çıkartmak için suppressMessages=true ile timerOff çağr\n    for (const [key, timer] of Object.entries(timers)) {\n      if (!runtime[key]) {\n        runtime[key] = {};\n      }\n      timerOff(timer, runtime[key], out, key, true);\n    }\n    // Ardından tek bir off all mesajını gönder\n    out[1].push({\n      payload: {\n        method: \"cmd\",\n        params: { type: \"off\", target: \"all\" }\n      }\n    });\n  } else {\n    out[1].push(msg);\n  }\n} else if (method === \"evt\" && type === \"timer_tick\") {\n  timerTick(timers, runtime, Date.now(), out);\n} else {\n  out[1].push(msg);\n}\n\ncontext.set(\"runtime\", runtime);\n\nreturn out.some(arr => arr.length) ? out : null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 440,
        "wires": [
            [
                "22442867c06e05b8"
            ],
            [
                "69b69a40e08aa884"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "1156fe8823a93a99",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "timer_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"method\": \"evt\", \"params\": {\"type\": \"timer_tick\", \"val\": null}}",
        "payloadType": "json",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "8701a07643f54a7b"
            ]
        ]
    },
    {
        "id": "22442867c06e05b8",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "fsm",
        "func": "const flowData = flow.get(\"flow\");\nconst runtime = flowData.runtime;\nlet currentState = runtime.fsm.state;\n\nconst payload = msg.payload;\nif (!payload || typeof payload !== \"object\") return null;\n\nconst method = payload.method;\nconst params = payload.params || {};\nconst type = params.type;\nconst target = params.target;\nconst val = params.val;\n\nconst outputs = [[], []];\n\nfunction transition(toState) {\n  if (toState !== currentState) {\n    currentState = toState;\n    flowData.runtime.fsm.state = currentState;\n    flow.set(\"flow\", flowData);\n    sendEvt(1, \"fsm\", { state: currentState });\n  }\n}\n\nfunction sendCmd(port, type, target, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"cmd\",\n      params: { type, target, ...extraParams }\n    }\n  };\n  outputs[port - 1].push(msg);\n}\n\nfunction sendEvt(port, type, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"evt\",\n      params: { type, ...extraParams }\n    }\n  };\n  outputs[port - 1].push(msg);\n}\n\n// --- Ana mesaj işleme ---\nif (method === \"evt\") {\n\n  if (type === \"oxygen_detector_dig\") {\n    if (currentState === \"start\") {\n      if (val === \"off\") {\n        sendCmd(1, \"on\", \"fan_pwm\");\n      } else if (val === \"on\") {\n        sendCmd(1, \"off\", \"fan_pwm\");\n      }\n    }\n\n  } else if (type === \"humidity_detector_dig\") {\n    if (currentState === \"start\") {\n      if (val === \"off\") {\n        sendCmd(1, \"on\", \"water_pump_pwm\");\n      } else if (val === \"on\") {\n        sendCmd(1, \"off\", \"water_pump_pwm\");\n      }\n    }\n\n  } else if (type === \"roof_forward_limit\") {\n    if (val === \"off\") {\n      sendCmd(1, \"off\", \"roof\");\n    }\n\n  } else if (type === \"roof_reverse_limit\") {\n    if (val === \"off\") {\n      sendCmd(1, \"off\", \"roof\");\n    }\n\n  } else if (type === \"cabinet_door\") {\n    // boş\n\n  } else if (type === \"emergency_button\") {\n    // boş\n  }\n\n} else if (method === \"cmd\") {\n\n  if (target === \"fsm\") {\n\n    if (type === \"stop\") {\n      sendCmd(1, \"off\", \"all\");\n      transition(\"stop\");\n\n    } else if (type === \"start\") {\n      if (runtime.oxygen_detector_dig.val === \"off\" && runtime.humidity_detector_dig.val === \"off\") {\n        sendCmd(1, \"on\", \"fan_pwm\");\n        sendCmd(1, \"on\", \"water_pump_pwm\");\n      } else if (runtime.oxygen_detector_dig.val === \"off\") {\n        sendCmd(1, \"on\", \"fan_pwm\");\n      } else if (runtime.humidity_detector_dig.val === \"off\") {\n        sendCmd(1, \"on\", \"water_pump_pwm\");\n      }\n      sendCmd(1, \"on\", \"day_counter\");\n      transition(\"start\");\n\n    } else if (type === \"dry\") {\n      sendCmd(1, \"on\", \"fan_pwm\");\n      sendCmd(1, \"off\", \"water_pump_pwm\");\n      transition(\"dry\");\n\n    } else if (type === \"end\") {\n      sendCmd(1, \"off\", \"all\");\n      transition(\"end\");\n    }\n\n  } else if (target === \"roof\") {\n\n    if (type === \"forward_on\") {\n      if (runtime.roof_forward_limit.val === \"off\") {\n        return;\n      }\n\n    } else if (type === \"reverse_on\") {\n      if (runtime.roof_reverse_limit.val === \"off\") {\n        return;\n      }\n    }\n    outputs[0].push(msg);\n\n  } else {\n    // default: gelen mesajı olduğu gibi 1. porta ilet\n    outputs[0].push(msg);\n  }\n}\n\nreturn outputs;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 260,
        "wires": [
            [
                "8701a07643f54a7b"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "0b3654ab51cfd27c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager",
        "func": "// Sabitler\nconst TELEMETRY_TOPIC = \"v1/devices/me/telemetry\";\nconst RPC_RESPONSE_PREFIX = \"v1/devices/me/rpc/response/\";\n\nconst topic = msg.topic || \"\";\nconst payload = msg.payload || {};\nconst method = payload?.method || \"\";\nconst params = payload?.params || {};\n\nconst flowData = flow.get(\"flow\") || {};\n\n// Güvenli msgId (topic beklenen formatta değilse 'unknown' kullan)\nconst msgId = (topic.split(\"/\").pop()) || \"unknown\";\n\nfunction getValueAtPath(obj, path) {\n    if (!Array.isArray(path) || path.length === 0) return obj;\n    return path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : null), obj);\n}\n\nfunction setValueAtPath(obj, path, value) {\n    if (!Array.isArray(path) || path.length === 0) {\n        throw new Error(\"Invalid path for set\");\n    }\n    let current = obj;\n    for (let i = 0; i < path.length - 1; i++) {\n        const key = path[i];\n        if (!(key in current) || typeof current[key] !== 'object' || current[key] === null) {\n            current[key] = {};\n        }\n        current = current[key];\n    }\n    current[path[path.length - 1]] = value;\n}\n\nfunction buildRpcResponse(id, content) {\n    return {\n        topic: RPC_RESPONSE_PREFIX + id,\n        payload: content\n    };\n}\n\nfunction buildTelemetryMsg(content) {\n    return {\n        topic: TELEMETRY_TOPIC,\n        payload: content\n    };\n}\n\n// 1) evt\nif (method === \"evt\") {\n    const subType = params?.type;\n    if (subType === \"telemetry_periodical\") {\n        return [buildTelemetryMsg(flowData.runtime || {}), null];\n    } else {\n        const key = params?.type;\n\n        // Hem val hem speed varsa\n        if (params?.val !== undefined && params?.speed !== undefined) {\n            const formatted = { [key]: { val: params.val, speed: params.speed } };\n            return [buildTelemetryMsg(formatted), null];\n        }\n        // Sadece val varsa\n        else if (params?.val !== undefined) {\n            const formatted = { [key]: { val: params.val } };\n            return [buildTelemetryMsg(formatted), null];\n        }\n        // Sadece speed varsa (garanti olsun)\n        else if (params?.speed !== undefined) {\n            const formatted = { [key]: { speed: params.speed } };\n            return [buildTelemetryMsg(formatted), null];\n        }\n\n        return [null, null];\n    }\n}\n\n// 2) cmd\nif (method === \"cmd\") {\n    return [buildRpcResponse(msgId, { response: true }), { payload }];\n}\n\n// 3) set/get tipi dot-path'li method'lar\nconst [action, ...pathParts] = method.split(\".\");\n\nif (action === \"get\") {\n    try {\n        const value = getValueAtPath(flowData, pathParts);\n        return [buildRpcResponse(msgId, { value: value === undefined ? null : value }), null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null];\n    }\n}\n\nif (action === \"set\") {\n    try {\n        if (!pathParts || pathParts.length === 0) {\n            return [buildRpcResponse(msgId, { error: \"Invalid set path\" }), null];\n        }\n        const newValue = params?.value;\n        setValueAtPath(flowData, pathParts, newValue);\n        flow.set(\"flow\", flowData);\n        return [buildRpcResponse(msgId, { response: true }), null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null];\n    }\n}\n\n// Bilinmeyen method'lar\nreturn [null, null];\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 60,
        "wires": [
            [
                "b7b87a40dd91a021"
            ],
            [
                "22442867c06e05b8"
            ]
        ]
    },
    {
        "id": "54a9a79a7c485b62",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst analogChannels = flowData.config.io.analog_inputs.channels;\nconst runtime = flowData.runtime;\n\n// analog_inputs'tan gelen tekil mesaj\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;  // DEĞİŞTİRİLDİ: method → params.type\nconst val = m.params?.val;\nif (typeof key !== \"string\" || typeof val !== \"number\") return null;\n\nconst analogDef = analogChannels[key];\nif (!analogDef || !analogDef.pro) return null;\n\nconst changed = [];\n\nfor (const [detectorKey, detector] of Object.entries(analogDef.pro)) {\n  if (\n    typeof detector === \"object\" &&\n    detector !== null &&\n    typeof detector.on === \"number\" &&\n    typeof detector.off === \"number\"\n  ) {\n    const prevVal = runtime[detectorKey]?.val ?? \"off\";\n\n    // Durum değişikliği mantığı (hysteresis)\n    const newVal =\n      prevVal === \"on\"\n        ? val <= detector.off\n          ? \"off\"\n          : \"on\"\n        : val >= detector.on\n        ? \"on\"\n        : \"off\";\n\n    if (newVal !== prevVal) {\n      // runtime güncelle\n      runtime[detectorKey].val = newVal;\n      flow.set(\"flow\", flowData);\n\n      // Çıkış mesajı\n      changed.push({\n        payload: {\n          method: \"evt\",\n          params: { type: detectorKey, val: newVal },\n        },\n      });\n    }\n  }\n}\n\n// Değişiklik yoksa çıkış verme\nreturn changed.length === 0 ? null : [changed];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 280,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "8b647d54a390a264",
        "type": "function",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst runtime = flowData.runtime;\nconst channels = flowData.config.energy_meter.channels;\n\n// energy_meter'dan gelen tekil mesaj\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || typeof val !== \"number\") return null;\n\nconst chDef = channels[key];\nif (!chDef || !chDef.pro) return null;\n\nconst changed = [];\n\nfor (const [detectorKey, detector] of Object.entries(chDef.pro)) {\n  if (\n    typeof detector === \"object\" &&\n    detector !== null &&\n    typeof detector.on === \"number\" &&\n    typeof detector.off === \"number\"\n  ) {\n    // runtime'da başlatılmamışsa başlat\n    if (!runtime[detectorKey]) {\n      runtime[detectorKey] = { val: \"off\" };\n    }\n\n    const prevVal = runtime[detectorKey].val;\n\n    const newVal =\n      prevVal === \"on\"\n        ? val <= detector.off\n          ? \"off\"\n          : \"on\"\n        : val >= detector.on\n        ? \"on\"\n        : \"off\";\n\n    if (newVal !== prevVal) {\n      runtime[detectorKey].val = newVal;\n      flow.set(\"flow\", flowData);\n\n      changed.push({\n        payload: {\n          method: \"evt\",\n          params: { type: detectorKey, val: newVal },\n        },\n      });\n    }\n  }\n}\n\nif (changed.length === 0) return null;\n\nreturn [changed];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 360,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "a218a71fd357ab14",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "restore",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// Flow verilerini çek\nconst flowData = flow.get(\"flow\") || {};\nconst runtime = flowData.runtime || {};\nconst config = flowData.config || {};\n\n// bekle ve emergency_contactor'u ON yap\nsetTimeout(() => {\n\n    node.send({\n        payload: {\n            method: \"cmd\",\n            params: { type: \"on\", target: \"emergency_contactor\" }\n        }\n    });\n\n    // bekle ve ALL OFF gönder (emergency_contactor hariç)\n    setTimeout(() => {\n\n        node.send({\n            payload: {\n                method: \"cmd\",\n                params: { type: \"off\", target: \"all\" }\n            }\n        });\n\n        // bekle ve yalnızca sinamics speed komutları restore et\n        setTimeout(() => {\n\n            const cmds = [];\n\n            for (const [target, sin] of Object.entries(config.sinamics?.channels || {})) {\n                const state = runtime[target];\n                if (state?.speed && typeof state.speed.set_point === \"number\") {\n                    cmds.push({\n                        payload: {\n                            method: \"cmd\",\n                            params: {\n                                type: \"speed\",\n                                target: target,\n                                set_point: state.speed.set_point\n                            }\n                        }\n                    });\n                }\n            }\n\n            // Tüm sinamics speed komutlarını sırayla gönder\n            function sendSequentially(messages, delayMs) {\n                messages.forEach((msg, index) => {\n                    setTimeout(() => {\n                        node.send(msg);\n                    }, index * delayMs);\n                });\n            }\n\n            sendSequentially(cmds, 100);\n\n        }, 5000);\n\n    }, 10000);\n\n}, 5000);\n",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 540,
        "wires": [
            [
                "69b69a40e08aa884"
            ]
        ]
    },
    {
        "id": "2b810660372548f4",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "digital_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst digitalChannels = flowData.config.io.digital_inputs.channels;\nconst runtime = flowData.runtime;\n\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || (val !== \"on\" && val !== \"off\")) return null;\n\nconst digitalDef = digitalChannels[key];\nif (!digitalDef || !digitalDef.pro) return null;\n\n// Ortak alarm anahtarı (pro objesindeki ilk key)\nconst commonAlarmKeys = Object.keys(digitalDef.pro);\nif (commonAlarmKeys.length === 0) return null;\nconst commonAlarmKey = commonAlarmKeys[0];\n\n// Bireysel girişlerin runtime güncellemesi ve mesaj çıkışı yok (diger nod yapıyor)\n\n// Şimdi aynı ortak alarm anahtarına sahip tüm kanalları bulalım\nconst relatedKeys = [];\nfor (const [chanKey, chanDef] of Object.entries(digitalChannels)) {\n  if (chanDef.pro && Object.keys(chanDef.pro).includes(commonAlarmKey)) {\n    relatedKeys.push(chanKey);\n  }\n}\n\n// runtime’dan bu ilgili kanalların değerlerini al\n// Burada beklenen pro objesi tek bir key-value, örn {oxygen_detector_dig: \"off\"} ya da {\"on\"}\n// bu yüzden değerlerine göre karar veriyoruz\n\nlet newCommonVal = runtime[commonAlarmKey]?.val ?? \"off\";\n\nconst offExists = relatedKeys.some(k => {\n  return digitalChannels[k].pro[commonAlarmKey] === \"off\" && runtime[k]?.val === \"off\";\n});\n\nconst onExists = relatedKeys.some(k => {\n  return digitalChannels[k].pro[commonAlarmKey] === \"on\" && runtime[k]?.val === \"on\";\n});\n\n// Hysteresis kuralı\nif (offExists) {\n  newCommonVal = \"off\";\n} else if (onExists) {\n  newCommonVal = \"on\";\n}\n\n// Eğer değiştiyse runtime güncelle ve mesaj üret\nif (newCommonVal !== runtime[commonAlarmKey]?.val) {\n  runtime[commonAlarmKey].val = newCommonVal;\n  flow.set(\"flow\", flowData);\n\n  return [[{\n    payload: {\n      method: \"evt\",\n      params: { type: commonAlarmKey, val: newCommonVal },\n    },\n  }]];\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 200,
        "wires": [
            [
                "22442867c06e05b8"
            ]
        ]
    },
    {
        "id": "890e808611421ece",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "get_analog_inputs",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 220,
        "wires": [
            [
                "db72d07653f1bbe9"
            ],
            []
        ]
    },
    {
        "id": "c3488bd8821ff6d8",
        "type": "modbus-client",
        "name": "203_115200_tcp_rtu_rel_out",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.203",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "2206e55e928c8b8f",
        "type": "modbus-client",
        "name": "201_115200_tcp_rtu_dig_inp",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.201",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e707d8a8f03b29cf",
        "type": "modbus-client",
        "name": "204_9600_tcp_rtu_ang_inp_eng_met",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.204",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "9703a3f2808e2fa6",
        "type": "modbus-client",
        "name": "202_9600_tcp_rtu_sinamics",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.202",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e1d018cea69d77b6",
        "type": "mqtt-broker",
        "name": "mqtt_broker",
        "broker": "54.208.96.163",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]
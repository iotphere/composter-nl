[
    {
        "id": "plc_tab",
        "type": "tab",
        "label": "plc_tab",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c3488bd8821ff6d8",
        "type": "modbus-client",
        "name": "203_115200_tcp_rtu_rel_out",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.203",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 100,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "2206e55e928c8b8f",
        "type": "modbus-client",
        "name": "201_115200_tcp_rtu_dig_inp",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.201",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "9703a3f2808e2fa6",
        "type": "modbus-client",
        "name": "202_9600_tcp_rtu_sinamics",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.202",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 100,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e1d018cea69d77b6",
        "type": "mqtt-broker",
        "name": "mqtt_broker",
        "broker": "46.224.43.158/",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e707d8a8f03b29cf",
        "type": "modbus-client",
        "name": "204_9600_tcp_rtu_ang_inp_eng_met",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.204",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": "100",
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": false,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "relays_writer",
        "type": "modbus-flex-write",
        "z": "plc_tab",
        "name": "relays_writer",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "c3488bd8821ff6d8",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "10",
        "x": 1210,
        "y": 240,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "digital_inputs_getter",
        "type": "modbus-flex-getter",
        "z": "plc_tab",
        "name": "digital_inputs_getter",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "2206e55e928c8b8f",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 380,
        "y": 120,
        "wires": [
            [
                "plc_function"
            ],
            []
        ]
    },
    {
        "id": "digital_inputs_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "digital_inputs_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.1",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "digital_inputs",
        "payload": "{\"fc\": 3, \"unitid\": 11, \"address\": 144 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 140,
        "y": 120,
        "wires": [
            [
                "digital_inputs_getter"
            ]
        ]
    },
    {
        "id": "analog_inputs_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "analog_inputs_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "10",
        "topic": "analog_inputs",
        "payload": "{\"fc\": 3, \"unitid\": 12, \"address\": 160 , \"quantity\": 8}",
        "payloadType": "json",
        "x": 140,
        "y": 180,
        "wires": [
            [
                "analog_and_energy_getter"
            ]
        ]
    },
    {
        "id": "energy_meter_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "energy_meter_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "30",
        "topic": "energy_meter",
        "payload": "{\"fc\": 3, \"unitid\": 2, \"address\": 29 , \"quantity\": 2}",
        "payloadType": "json",
        "x": 140,
        "y": 240,
        "wires": [
            [
                "analog_and_energy_getter"
            ]
        ]
    },
    {
        "id": "sinamics_writer",
        "type": "modbus-flex-write",
        "z": "plc_tab",
        "name": "sinamics_writer",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "9703a3f2808e2fa6",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1220,
        "y": 180,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "mqtt_in",
        "type": "mqtt in",
        "z": "plc_tab",
        "name": "mqtt_in",
        "topic": "v1/devices/me/rpc/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "e1d018cea69d77b6",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 330,
        "y": 60,
        "wires": [
            [
                "plc_function"
            ]
        ]
    },
    {
        "id": "mqtt_out",
        "type": "mqtt out",
        "z": "plc_tab",
        "name": "mqtt_out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "e1d018cea69d77b6",
        "x": 1200,
        "y": 60,
        "wires": []
    },
    {
        "id": "timer_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "timer_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "timer",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 480,
        "wires": [
            [
                "plc_function"
            ]
        ]
    },
    {
        "id": "analog_and_energy_getter",
        "type": "modbus-flex-getter",
        "z": "plc_tab",
        "name": "analog_and_energy_getter",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 400,
        "y": 180,
        "wires": [
            [
                "plc_function"
            ],
            []
        ]
    },
    {
        "id": "power_on_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "power_on_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "power_on",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 420,
        "wires": [
            [
                "plc_function"
            ]
        ]
    },
    {
        "id": "sinamics_12_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "sinamics_12_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "unitid",
                "v": "12",
                "vt": "num"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": "20",
        "topic": "sinamics",
        "payload": "{\"fc\": 3, \"unitid\": 12, \"address\": 109 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 140,
        "y": 300,
        "wires": [
            [
                "sinamics_getter"
            ]
        ]
    },
    {
        "id": "sinamics_getter",
        "type": "modbus-flex-getter",
        "z": "plc_tab",
        "name": "sinamics_getter",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "9703a3f2808e2fa6",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 360,
        "y": 300,
        "wires": [
            [
                "plc_function"
            ],
            []
        ]
    },
    {
        "id": "plc_function",
        "type": "function",
        "z": "plc_tab",
        "name": "plc_function",
        "func": "/************************************************************\n * PLC (Single Function Node) — V30\n * - v223 tabanlı\n * - Fault Recovery: sinamics status fault:\"on\" gelince\n *   * helpers.sinamics.channels.<ch>.fault_retry sayacı (config.sinamics.fault_ack_retry, yoksa 3)\n *   * ack-set (fault_ack_set) + önceki sağlıklı duruma (work/direction) göre komut (forward/reverse/off)\n *   * fault:\"off\" görülünce lastHealthy güncellenir ve sayaç resetlenir\n * - speed_set_point CONFIG altında; set.* ile yazılır, telemetry YOK (yalnız Modbus speed write)\n * - runtime.sinamics.channels.<ch>.val = {work,fault,warning,direction}\n *   * yalnız status değişince güncellenir ve telemetry çıkar\n * - fsm: { val: \"...\" } olarak tutulur\n * - plc_switch yok; loop() iç çağrı\n ************************************************************/\n\n// ---------- micro utils ----------\nconst K   = context.get(\"kernel\") || {};\nconst cfg = K.config || {};\nK.runtime = K.runtime || {};\nK.helpers = K.helpers || {};\nconst rt  = K.runtime;\nconst hp  = K.helpers;\n\nconst out = []; // single port: we push all messages here\nconst LABELS = (cfg.labels || { true: \"on\", false: \"off\" });\n\nfunction now(){ return Date.now(); }\nfunction clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }\n\nfunction toMs(val, unit) {\n  const u = (unit || \"s\").toLowerCase();\n  if (u === \"ms\")  return val;\n  if (u === \"s\")   return val * 1000;\n  if (u === \"min\") return val * 60000;\n  if (u === \"h\")   return val * 3600000;\n  if (u === \"d\")   return val * 86400000;\n  return val * 1000;\n}\n\nfunction ensure(o, pathArr) {\n  let cur = o;\n  for (const k of pathArr) {\n    if (cur[k] == null || typeof cur[k] !== \"object\") cur[k] = {};\n    cur = cur[k];\n  }\n  return cur;\n}\n\n// ---------- telemetry & rpc ----------\nfunction tel(obj, nested=false) {\n  // telemetry payload’larını runtime benzeri {key:{val:...}} formunda üret\n  if (!obj || !Object.keys(obj).length) return;\n  const formatted = {};\n  for (const [k,v] of Object.entries(obj)) {\n    if (v && typeof v === \"object\" && (\"val\" in v)) {\n      formatted[k] = v;            // zaten {val:...}\n    } else {\n      formatted[k] = { val: v };   // string/number -> {val:...}\n    }\n  }\n  const payload = nested ? { data: formatted } : formatted;\n  out.push({ topic:\"v1/devices/me/telemetry\", payload });\n}\n\nfunction rpcResp(id, content) {\n  out.push({ topic: \"v1/devices/me/rpc/response/\" + id, payload: content });\n}\n\n// ==========================================================\n// [no self-loop] loop(): iç yönlendirme\n// ==========================================================\nfunction loop(evt) {\n  if (!evt || !evt.type) return;\n  if (evt.type === \"evt.din\") {\n    fsm_event_from_digital(evt.key, evt.val);\n  }\n  else if (evt.type === \"cmd.power_on_delay\") {\n    sin_all_off_and_speed();\n  }\n}\n\n// ==========================================================\n// RELAYS\n// ==========================================================\nfunction relays_packAndSend() {\n  const hpio = ensure(hp, [\"io\"]);\n  const bank1 = ensure(hpio, [\"relay_outputs_1\"]);\n  const bank2 = ensure(hpio, [\"relay_outputs_2\"]);\n  if (!Array.isArray(bank1.last_write_array)) bank1.last_write_array = Array(8).fill(false);\n  if (!Array.isArray(bank2.last_write_array)) bank2.last_write_array = Array(8).fill(false);\n\n  const r1 = bank1.last_write_array;\n  const r2 = bank2.last_write_array;\n  const unit1 = cfg.io?.relay_outputs_1?.unitid ?? null;\n  const unit2 = cfg.io?.relay_outputs_2?.unitid ?? null;\n  const arrToWord = a => a.reduce((w,b,i)=> b ? (w|(1<<i)) : w, 0);\n\n  if (unit1 != null) out.push({ topic:\"relays\", payload:{ value:arrToWord(r1), fc:6, unitid:unit1, address:128, quantity:1 }});\n  if (unit2 != null) out.push({ topic:\"relays\", payload:{ value:arrToWord(r2), fc:6, unitid:unit2, address:128, quantity:1 }});\n}\nfunction relay_info(name){\n  const ch1 = cfg.io?.relay_outputs_1?.channels?.[name];\n  if (ch1) return { bank:1, bit:ch1.map, unitid: cfg.io.relay_outputs_1.unitid };\n  const ch2 = cfg.io?.relay_outputs_2?.channels?.[name];\n  if (ch2) return { bank:2, bit:ch2.map, unitid: cfg.io.relay_outputs_2.unitid };\n  return null;\n}\nfunction relay_set(name, onOffBool) {\n  const info = relay_info(name);\n  if (!info) return;\n  const arrKey = (info.bank === 1) ? \"relay_outputs_1\" : \"relay_outputs_2\";\n  const container = ensure(hp, [\"io\", arrKey]);\n  if (!Array.isArray(container.last_write_array)) container.last_write_array = Array(8).fill(false);\n  container.last_write_array[info.bit] = !!onOffBool;\n  setIfChanged(rt, [\"io\", arrKey, \"channels\"], name, LABELS[onOffBool], name);\n}\nfunction relays_reset({ preservePower=false, setPower=null }={}) {\n  const hpio = ensure(hp, [\"io\"]);\n  const bank1 = ensure(hpio, [\"relay_outputs_1\"]);\n  const bank2 = ensure(hpio, [\"relay_outputs_2\"]);\n  if (!Array.isArray(bank1.last_write_array)) bank1.last_write_array = Array(8).fill(false);\n  if (!Array.isArray(bank2.last_write_array)) bank2.last_write_array = Array(8).fill(false);\n  bank1.last_write_array.fill(false);\n  bank2.last_write_array.fill(false);\n\n  const chAll = { ...(cfg.io?.relay_outputs_1?.channels||{}), ...(cfg.io?.relay_outputs_2?.channels||{}) };\n  for (const name of Object.keys(chAll)) {\n    if (name === \"power_contactor\" && preservePower) continue;\n    relay_set(name,false);\n  }\n  if (cfg.io?.relay_groups?.walking_floor) {\n    setIfChanged(rt, [\"io\",\"relay_groups\"], \"walking_floor\",\"off\",\"walking_floor\");\n    for (const k of Object.keys(cfg.io.relay_groups.walking_floor)) relay_set(k,false);\n  }\n  if (cfg.io?.relay_groups?.roof) {\n    setIfChanged(rt, [\"io\",\"relay_groups\"], \"roof\",\"off\",\"roof\");\n    for (const k of Object.keys(cfg.io.relay_groups.roof)) relay_set(k,false);\n  }\n  const pInfo = relay_info(\"power_contactor\");\n  if (pInfo) {\n    let newPow;\n    if (preservePower) {\n      const prev = rt.io?.relay_outputs_2?.channels?.power_contactor?.val;\n      newPow = (prev === \"on\");\n    } else if (typeof setPower===\"boolean\") newPow=setPower; else newPow=false;\n    relay_set(\"power_contactor\", newPow);\n  }\n  relays_packAndSend();\n}\nfunction walking_floor_cmd(type) {\n  const keys = Object.keys(cfg.io?.relay_groups?.walking_floor || {});\n  if (keys.length<3) return;\n  const motor = keys.find(k=>k.includes(\"motor\"))||keys[0];\n  const fwd   = keys.find(k=>k.includes(\"forward\"))||keys[1];\n  const rev   = keys.find(k=>k.includes(\"reverse\"))||keys[2];\n  relay_set(motor,false); relay_set(fwd,false); relay_set(rev,false);\n  if (type===\"forward\"){ relay_set(motor,true); relay_set(fwd,true); }\n  else if (type===\"reverse\"){ relay_set(motor,true); relay_set(rev,true); }\n  setIfChanged(rt,[\"io\",\"relay_groups\"],\"walking_floor\",type,\"walking_floor\");\n  relays_packAndSend();\n}\nfunction roof_cmd(type){\n  const keys = Object.keys(cfg.io?.relay_groups?.roof||{});\n  if (keys.length<2) return;\n  const fwd=keys.find(k=>k.includes(\"forward\"))||keys[0];\n  const rev=keys.find(k=>k.includes(\"reverse\"))||keys[1];\n  relay_set(fwd,false); relay_set(rev,false);\n  if (type===\"forward\") relay_set(fwd,true);\n  else if (type===\"reverse\") relay_set(rev,true);\n  setIfChanged(rt,[\"io\",\"relay_groups\"],\"roof\",type,\"roof\");\n  relays_packAndSend();\n}\n\n// ==========================================================\n// SINAMICS\n// ==========================================================\nfunction sin_address(){ return { wordAddr:99, speedAddr:100 }; }\nfunction sin_speedToValue(spPct){\n  const max=cfg.sinamics?.speed_max??16384;\n  const sp=Number.isFinite(spPct)?clamp(spPct,0,100):100;\n  return Math.round(sp/100*max);\n}\nfunction sin_write(unitid,address,value){\n  out.push({ topic:\"sinamics\", payload:{ value,fc:6,unitid,address,quantity:1 }});\n}\nfunction sin_cmd(target,type){\n  // NOTE: hız artık cmd ile yönetilmiyor; yalnız set.* ile (aşağıdaki set hook)\n  const ch=cfg.sinamics?.channels?.[target];\n  if(!ch) return;\n  const {wordAddr}=sin_address();\n  const cmdWords=cfg.sinamics?.command_words||{};\n  if([\"forward\",\"reverse\",\"off\"].includes(type)){\n    const w=cmdWords[type];\n    if(w!=null){\n      sin_write(ch.unitid,wordAddr,w);\n      // runtime güncellenmez; status getter değişince runtime & telemetry üretilecek\n    }\n  }\n}\nfunction sin_all_off_and_speed(){\n  // OFF -> SPEED sırası (senin v223 düzenin korunuyor)\n  const {wordAddr,speedAddr}=sin_address();\n  const cmdWords=cfg.sinamics?.command_words||{};\n  for(const [name,ch] of Object.entries(cfg.sinamics?.channels||{})){\n    if(cmdWords.off!=null) sin_write(ch.unitid,wordAddr,cmdWords.off);\n    const sp=cfg.sinamics?.channels?.[name]?.speed_set_point ?? 100;\n    sin_write(ch.unitid, speedAddr, sin_speedToValue(sp));\n  }\n}\nfunction sin_fault_ack_all(){\n  const {wordAddr}=sin_address();\n  const set=cfg.sinamics?.command_words?.fault_ack_set;\n  const res=cfg.sinamics?.command_words?.fault_ack_res;\n  if(set==null||res==null) return;\n  for(const [,ch] of Object.entries(cfg.sinamics?.channels||{})) sin_write(ch.unitid,wordAddr,set);\n  for(const [,ch] of Object.entries(cfg.sinamics?.channels||{})) sin_write(ch.unitid,wordAddr,res);\n}\nfunction deepEqual(a,b){\n  if(a===b) return true;\n  if(!a || !b) return false;\n  const ka=Object.keys(a), kb=Object.keys(b);\n  if(ka.length!==kb.length) return false;\n  for(const k of ka){\n    if(typeof a[k]===\"object\" && typeof b[k]===\"object\"){\n      if(!deepEqual(a[k],b[k])) return false;\n    }else{\n      if(a[k]!==b[k]) return false;\n    }\n  }\n  return true;\n}\n\n// ---- Fault Recovery helpers ----\nconst DEFAULT_FAULT_RETRY = Number.isFinite(cfg.sinamics?.fault_ack_retry) ? cfg.sinamics.fault_ack_retry : 3;\nfunction desiredCmdFromStatus(stat){\n  // stat: {work:\"on/off\", direction:\"on/off\"} -> \"forward\" | \"reverse\" | \"off\"\n  if (!stat || stat.work !== \"on\") return \"off\";\n  // direction bit: \"on\" -> forward, \"off\" -> reverse (basit ve belirgin sözleşme)\n  return (stat.direction === \"on\") ? \"forward\" : \"reverse\";\n}\n\nfunction sin_evt_from_status(msg){\n  // Modbus status word çözümle -> {work,fault,warning,direction} ve sadece değişimde runtime&telemetry\n  const rawVal=Array.isArray(msg.payload)?msg.payload[0]:msg.payload;\n  const unitid=msg.unitid??msg?.payload?.unitid??msg?.modbusRequest?.unitid;\n  if(typeof rawVal!==\"number\"||unitid==null) return;\n\n  let target=null;\n  for(const [name,ch] of Object.entries(cfg.sinamics?.channels||{})){ if(ch.unitid===unitid){ target=name; break; } }\n  if(!target) return;\n\n  const getBit=(v,i)=>( (v&(1<<i))!==0 );\n  const map=cfg.sinamics?.status_word||{};\n  const statusObj={};\n  for(const [k,def] of Object.entries(map)) statusObj[k]=LABELS[getBit(rawVal,def.map)];\n\n  // helpers channel bucket\n  const hch = ensure(hp, [\"sinamics\",\"channels\",target]);\n  if (typeof hch.fault_retry !== \"number\") hch.fault_retry = DEFAULT_FAULT_RETRY;\n  // runtime önceki değer (karşılaştırma ve lastHealthy güncellemesi için)\n  const rroot=ensure(rt,[\"sinamics\",\"channels\"]);\n  const prev = rroot[target]?.val || null;\n\n  // Runtime değişim varsa güncelle + telemetry\n  const changed = !prev || !deepEqual(prev, statusObj);\n  if (changed){\n    ensure(rroot,[target]);\n    rroot[target].val = statusObj;\n    tel({ [target]: { val: statusObj } });\n  }\n\n  // ----- Fault handling -----\n  if (statusObj.fault === \"on\") {\n    // Fault ON: recovery denemesi\n    const { wordAddr } = sin_address();\n    const cmdWords = cfg.sinamics?.command_words || {};\n    const ch = cfg.sinamics?.channels?.[target];\n    if (!ch) return;\n\n    // Son sağlıklı (fault:\"off\") durumumuz yoksa, prev içinde fault off olan son hal olabilir;\n    // garantiye almak için helpers.lastHealthy yoksa \"off\" kabul et.\n    const lastHealthy = hch.lastHealthy && hch.lastHealthy.fault === \"off\"\n      ? hch.lastHealthy\n      : (prev && prev.fault === \"off\" ? prev : { work:\"off\", fault:\"off\", warning:\"off\", direction:\"on\" });\n\n    // Retry varsa ack-set + lastHealthy komutu gönder\n    if (hch.fault_retry > 0) {\n      // 1) fault ack set\n      if (cmdWords.fault_ack_set != null) {\n        sin_write(ch.unitid, wordAddr, cmdWords.fault_ack_set);\n      }\n      // 2) eski durumu yansıt (forward/reverse/off)\n      const cmdType = desiredCmdFromStatus(lastHealthy);\n      if ([\"forward\",\"reverse\",\"off\"].includes(cmdType) && cmdWords[cmdType] != null) {\n        sin_write(ch.unitid, wordAddr, cmdWords[cmdType]);\n      }\n      hch.fault_retry -= 1;\n    }\n    // Retry yoksa artık bir şey yapmıyoruz; sonraki fault off’da resetlenecek.\n  } else {\n    // Fault OFF: bu durumu \"sağlıklı\" olarak işaretle ve retry resetle\n    hch.lastHealthy = statusObj;\n    hch.fault_retry = DEFAULT_FAULT_RETRY;\n  }\n}\n\n// ==========================================================\n// DIGITAL INPUTS\n// ==========================================================\nfunction setIfChanged(obj, pathArr, key, newVal, telemetryKey) {\n  const bucket = ensure(obj, pathArr);\n  const prev = bucket[key]?.val;\n  if (prev !== newVal) {\n    bucket[key] = { val: newVal };\n    if (telemetryKey) tel({ [telemetryKey]: newVal });\n    return true;\n  }\n  return false;\n}\n\nfunction handle_digital_inputs(msg){\n  const channels=cfg.io?.digital_inputs?.channels||{};\n  const raw=Array.isArray(msg.payload)?msg.payload[0]:msg.payload;\n  if(typeof raw!==\"number\") return;\n  const hroot=ensure(hp,[\"io\",\"digital_inputs\",\"channels\"]);\n  const rroot=ensure(rt,[\"io\",\"digital_inputs\",\"channels\"]);\n  for(const [key,def] of Object.entries(channels)){\n    const bit=!!((raw>>def.map)&1);\n    const label=LABELS[bit];\n    if(!hroot[key]) hroot[key]={history:[]};\n    const hist=hroot[key].history;\n    hist.push(label);\n    if(hist.length>2) hist.shift();\n    if(hist.length===2&&hist[0]===hist[1]){\n      const prev=rroot[key]?.val;\n      if(prev!==hist[1]){\n        rroot[key]={val:hist[1]};\n        tel({[key]:hist[1]});\n        loop({type:\"evt.din\", key, val:hist[1]}); // iç çağrı\n      }\n    }\n  }\n}\n\n// ==========================================================\n// ANALOG INPUTS + analog_pro thresholds\n// ==========================================================\nfunction handle_analog_inputs(msg){\n  const arr=msg.payload; if(!Array.isArray(arr)) return;\n  const channels=cfg.io?.analog_inputs?.channels||{};\n  const hroot=ensure(hp,[\"io\",\"analog_inputs\",\"channels\"]);\n  const rroot=ensure(rt,[\"io\",\"analog_inputs\",\"channels\"]);\n\n  for(const [key,def] of Object.entries(channels)){\n    const i=def.map; if(!Number.isFinite(arr[i])) continue;\n    let v=arr[i];\n    if(Number.isFinite(def.factor)) v*=def.factor;\n    if(def.scale){\n      const {in_min,in_max,out_min,out_max}=def.scale;\n      v=((v-in_min)/(in_max-in_min))*(out_max-out_min)+out_min;\n    }\n    v=Number.parseFloat(v.toFixed(3));\n\n    if(!hroot[key]) hroot[key]={lastVal:null};\n    const last=hroot[key].lastVal;\n    const chg=def.change??0;\n\n    if(last===null||Math.abs(v-last)>=chg){\n      hroot[key].lastVal=v;\n      rroot[key]={val:v};\n      tel({[key]:v});\n\n      // analog_pro türetilmiş dijitaller (varsa)\n      if(def.pro){\n        for(const [det,th] of Object.entries(def.pro)){\n          if(!th || !Number.isFinite(th.low) || !Number.isFinite(th.high)) continue;\n          const lowKey  = det + \"_low\";\n          const highKey = det + \"_high\";\n          const prevL=rroot[lowKey]?.val??\"on\";\n          const prevH=rroot[highKey]?.val??\"on\";\n          const newL=(v<th.low) ?\"off\":\"on\";\n          const newH=(v>th.high)?\"off\":\"on\";\n          if(newL!==prevL){\n            rroot[lowKey]={val:newL};\n            tel({[lowKey]:newL});\n            loop({type:\"evt.din\", key:lowKey,  val:newL});\n          }\n          if(newH!==prevH){\n            rroot[highKey]={val:newH};\n            tel({[highKey]:newH});\n            loop({type:\"evt.din\", key:highKey, val:newH});\n          }\n        }\n      }\n    }\n  }\n}\n\n// ==========================================================\n// ENERGY METER\n// ==========================================================\nfunction handle_energy_meter(msg){\n  const arr=msg.payload; if(!Array.isArray(arr)) return;\n  const kDef={map:0,factor:0.01,change:2};\n  let v=arr[kDef.map]*kDef.factor;\n  v=Number.parseFloat(v.toFixed(3));\n  const hpen=ensure(hp,[\"energy\"]);\n  const last=(typeof hpen.kwh_last===\"number\")?hpen.kwh_last:null;\n  if(last===null||Math.abs(v-last)>=kDef.change){\n    hpen.kwh_last=v;\n    setIfChanged(rt,[], \"kwh\",v,\"kwh\");\n  }\n}\n\n// ==========================================================\n// TIMERS\n// ==========================================================\nfunction t_rt(name){ const root=ensure(rt,[\"timers\"]); if(!root[name]) root[name]={state:\"off\"}; return root[name]; }\n\nfunction timer_on(name, forcedCount=null) {\n  const t = cfg.timers?.[name]; if (!t) return;\n  const r = t_rt(name);\n  r.state = \"on\";\n  r.on_time = now();\n  r.phase = null; r.phase_until = null; r.next_time = null;\n\n  if (t.form === \"delay\") {\n    r.done = false;\n    r.phase_until = now() + toMs(t.duration, t.unit);\n    timer_apply_phase(name, \"a\");\n  }\n  else if (t.form === \"pwm\") {\n    r.phase = \"a\";\n    r.phase_until = now() + toMs(t.t_duty, t.unit);\n    timer_apply_phase(name, \"a\");\n  }\n  else if (t.form === \"counter\") {\n    r.count = (forcedCount != null) ? forcedCount : t.base;\n    r.next_time = now() + toMs(t.interval, t.unit);\n    tel({ [name]: r.count });\n    if (name === \"day_counter\") tel({ day: r.count });\n  }\n}\n\nfunction timer_off(name) {\n  const t = cfg.timers?.[name]; if (!t) return;\n  const r = t_rt(name);\n  r.state = \"off\";\n\n  if (t.form === \"delay\") {\n    r.done = true;\n    timer_apply_phase(name, \"b\");\n  }\n  else if (t.form === \"pwm\") {\n    r.phase = null;\n    timer_apply_phase(name, \"b\");\n  }\n  else if (t.form === \"counter\") {\n    r.count = 0;\n    tel({ [name]: 0 });\n    if (name === \"day_counter\") tel({ day: 0 });\n  }\n\n  r.on_time = r.next_time = r.phase_until = null;\n  r.phase = null;\n}\n\nfunction timers_tick() {\n  const nowt = now();\n  for (const [name, t] of Object.entries(cfg.timers || {})) {\n    const r = t_rt(name);\n    if (r.state !== \"on\") continue;\n\n    if (t.form === \"delay\") {\n      if (!r.done && nowt >= r.phase_until) {\n        r.done = true;\n        timer_apply_phase(name, \"b\");\n      }\n    }\n    else if (t.form === \"pwm\") {\n      if (nowt >= r.phase_until) {\n        if (r.phase === \"a\") {\n          r.phase = \"b\";\n          r.phase_until = nowt + toMs(t.t_cycle - t.t_duty, t.unit);\n          timer_apply_phase(name, \"b\");\n        } else {\n          r.phase = \"a\";\n          r.phase_until = nowt + toMs(t.t_duty, t.unit);\n          timer_apply_phase(name, \"a\");\n        }\n      }\n    }\n    else if (t.form === \"counter\") {\n      if (nowt >= r.next_time && r.count > 0) {\n        r.count -= 1;\n        r.next_time = nowt + toMs(t.interval, t.unit);\n        tel({ [name]: r.count });\n\n        if (name === \"day_counter\") {\n          const sig = cfg.timers.day_counter.signal;\n          if (sig != null && r.count === sig) fsm_cmd({ type: \"dry\" });\n          if (r.count === 0) fsm_cmd({ type: \"complete\" });\n          tel({ day: r.count });\n        }\n        else if (name === \"walking_floor_counter\") {\n          fsm_cmd({ type: \"walking_floor_counter\", val: r.count });\n          if (r.count === 0) timer_off(\"walking_floor_counter\");\n        }\n      }\n    }\n  }\n}\n\nfunction timer_apply_phase(name, phase) {\n  if (name === \"fan_pwm\") {\n    if (phase === \"a\") sin_cmd(\"fan\", \"forward\");\n    else               sin_cmd(\"fan\", \"off\");\n  }\n  else if (name === \"water_valve_pwm\") {\n    if (phase === \"a\") relay_set(\"water_valve\", true);\n    else               relay_set(\"water_valve\", false);\n    relays_packAndSend();\n  }\n  else if (name === \"light_pulse\") {\n    if (phase === \"a\") { relay_set(\"light\", true); relays_packAndSend(); }\n    else               { relay_set(\"light\", false); relays_packAndSend(); }\n  }\n}\n\n// ==========================================================\n// FSM  (fsm:{val:\"...\"})\n// ==========================================================\nfunction fsm_state(){ if(!rt.fsm) rt.fsm = { val:\"completed\" }; return rt.fsm; }\nfunction fsm_transition(to){\n  const f=fsm_state();\n  if (f.val !== to) { f.val = to; tel({ fsm: to }); }\n}\n\nfunction fsm_event_from_digital(key, val) {\n  const st = fsm_state().val;\n  if (key === \"oxygen_detector_dig_low\" && val === \"off\") {\n    if (st === \"processing\") { timer_on(\"walking_floor_counter\"); }\n  } else if (key === \"oxygen_detector_dig_high\" && val === \"off\") {\n    if (st === \"processing\") {\n      timer_off(\"walking_floor_counter\");\n      walking_floor_cmd(\"off\");\n      timer_off(\"fan_pwm\");\n    }\n  }\n}\n\nfunction fsm_cmd(cmd) {\n  const type = cmd?.type;\n  if (!type) return;\n\n  if (type === \"process\") {\n    const digHigh = rt.io?.digital_inputs?.channels?.oxygen_detector_dig_high?.val || \"on\";\n    if (digHigh === \"on\") timer_on(\"walking_floor_counter\");\n    else {\n      timer_off(\"walking_floor_counter\");\n      walking_floor_cmd(\"off\");\n      timer_off(\"fan_pwm\");\n    }\n    timer_on(\"water_valve_pwm\");\n    timer_on(\"day_counter\");\n    fsm_transition(\"processing\");\n  }\n  else if (type === \"dry\") {\n    timer_on(\"fan_pwm\");\n    timer_off(\"water_valve_pwm\");\n    const sig = cfg.timers?.day_counter?.signal ?? null;\n    timer_on(\"day_counter\", sig);\n    fsm_transition(\"drying\");\n  }\n  else if (type === \"complete\") {\n    for (const name of Object.keys(cfg.timers || {})) timer_off(name);\n    relays_reset({ preservePower: true });\n    sin_all_off_and_speed();\n    fsm_transition(\"completed\");\n  }\n  else if (type === \"walking_floor_counter\") {\n    const n = Number(cmd?.val);\n    if (Number.isFinite(n)) {\n      if (n > 0) {\n        if (n % 2 === 0) walking_floor_cmd(\"forward\");\n        else             walking_floor_cmd(\"reverse\");\n      } else {\n        walking_floor_cmd(\"off\");\n        timer_on(\"fan_pwm\");\n      }\n    }\n  }\n}\n\n// ==========================================================\n// RPC & POWER-ON\n// ==========================================================\nfunction handle_rpc(msg){\n  const id=(msg.topic||\"\").split(\"/\").pop();\n  let p=msg.payload;\n  try{ if(typeof p===\"string\") p=JSON.parse(p); }catch(e){}\n  const method=p?.method;\n  const params=p?.params||{};\n\n  if(method===\"cmd\"){\n    const {target,type} = params;\n\n    if (target===\"fsm\") { fsm_cmd({ type, val: params?.val }); }\n    else if (target===\"timers\" && type===\"off\") { for (const n of Object.keys(cfg.timers||{})) timer_off(n); }\n    else if (target===\"actuators\" && type===\"off\") { relays_reset({ preservePower:true }); sin_all_off_and_speed(); }\n    else if (target===\"walking_floor\") { walking_floor_cmd(type); }\n    else if (target===\"roof\") { roof_cmd(type); }\n    else if (cfg.io?.relay_outputs_1?.channels?.[target] || cfg.io?.relay_outputs_2?.channels?.[target]) {\n      // tekil röle kontrolü\n      const onOff = (type === \"on\");\n      relay_set(target, onOff);\n      relays_packAndSend();\n    }\n    else if (target===\"power\") {\n      if (type===\"off\") {\n        relays_reset({ setPower:false });\n      } else if (type===\"on\") {\n        relays_reset({ setPower:true });\n        out.push({ topic:\"power_on_delay\", payload:{ type:\"cmd.power_on_delay\" } });\n      }\n    }\n    else if (target===\"day_counter\" && type===\"skip\") {\n      const sig = cfg.timers?.day_counter?.signal ?? null;\n      timer_on(\"day_counter\", sig);\n    }\n    else if (cfg.sinamics?.channels?.[target]) { sin_cmd(target,type); } // speed YOK; sadece forward/reverse/off\n    else if (target===\"sinamics\" && type===\"fault_ack\") { sin_fault_ack_all(); }\n\n    rpcResp(id, { response: true });\n    return;\n  }\n\n  // get.*  (kernel tamamına erişim)\n  if (typeof method === \"string\" && method.startsWith(\"get.\")) {\n    const path = method.split(\".\").slice(1);\n    let cur = { config: cfg, runtime: rt, helpers: hp };\n    for (const k of path) { cur = (cur && cur[k] !== undefined) ? cur[k] : undefined; }\n    rpcResp(id, { value: cur ?? null });\n    return;\n  }\n\n  // set.*  (kernel tamamına yazma) + HOOK: speed_set_point -> Modbus speed write & NO telemetry\n  if (typeof method === \"string\" && method.startsWith(\"set.\")) {\n    const path = method.split(\".\").slice(1); // [\"config\",\"sinamics\",\"channels\",\"fan\",\"speed_set_point\"]\n    let cur = { config: cfg, runtime: rt, helpers: hp };\n    for (let i=0;i<path.length-1;i++){\n      const k = path[i];\n      if (cur[k] == null || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[path[path.length-1]] = params?.value;\n\n    // HOOK: speed_set_point mi?\n    if (path.length===5 &&\n        path[0]===\"config\" && path[1]===\"sinamics\" && path[2]===\"channels\" &&\n        path[4]===\"speed_set_point\") {\n      const target = path[3];\n      const ch = cfg.sinamics?.channels?.[target];\n      const sp = Number(params?.value);\n      if (ch && Number.isFinite(sp)) {\n        const { speedAddr } = sin_address();\n        sin_write(ch.unitid, speedAddr, sin_speedToValue(sp));\n        // Telemetry YOK; runtime dokunulmaz\n      }\n    }\n\n    rpcResp(id, { response: true });\n    return;\n  }\n\n  rpcResp(id, { error: \"unknown method\" });\n}\n\nfunction handle_power_on(){\n  relays_reset({ setPower:true });\n  out.push({ topic:\"power_on_delay\", payload:{ type:\"cmd.power_on_delay\" } });\n}\n\n// ==========================================================\n// MAIN DISPATCH\n// ==========================================================\nswitch (msg.topic) {\n  case \"digital_inputs\":   handle_digital_inputs(msg); break;\n  case \"analog_inputs\":    handle_analog_inputs(msg);  break;\n  case \"energy_meter\":     handle_energy_meter(msg);   break;\n  case \"sinamics\":         sin_evt_from_status(msg);   break;\n  case \"timer\":            timers_tick();              break;\n  case \"power_on\":         handle_power_on();          break;\n  case \"power_on_delay\":   sin_all_off_and_speed();    break;\n  default:\n    if (typeof msg.topic === \"string\" && msg.topic.indexOf(\"v1/devices/me/rpc/request/\") === 0) {\n      handle_rpc(msg);\n    }\n    break;\n}\n\n// persist & emit\ncontext.set(\"kernel\", K);\n\n// SINGLE OUTPUT: multiple messages as an array on port#1\nreturn [ out.length ? out : null ];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 60,
        "wires": [
            [
                "telemetry_switch",
                "rpc_switch",
                "relays_switch",
                "power_on_delay_switch",
                "info_debug",
                "sinamics_switch"
            ]
        ]
    },
    {
        "id": "sinamics_14_inject",
        "type": "inject",
        "z": "plc_tab",
        "name": "sinamics_14_inject",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "unitid",
                "v": "14",
                "vt": "num"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": "20",
        "topic": "sinamics",
        "payload": "{\"fc\": 3, \"unitid\": 14, \"address\": 109 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 140,
        "y": 360,
        "wires": [
            [
                "sinamics_getter"
            ]
        ]
    },
    {
        "id": "telemetry_switch",
        "type": "switch",
        "z": "plc_tab",
        "name": "telemetry_switch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "v1/devices/me/telemetry",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 990,
        "y": 60,
        "wires": [
            [
                "mqtt_out"
            ]
        ]
    },
    {
        "id": "rpc_switch",
        "type": "switch",
        "z": "plc_tab",
        "name": "rpc_switch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "v1/devices/me/rpc/response/",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 120,
        "wires": [
            [
                "mqtt_out"
            ]
        ]
    },
    {
        "id": "sinamics_switch",
        "type": "switch",
        "z": "plc_tab",
        "name": "sinamics_switch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "sinamics",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 980,
        "y": 180,
        "wires": [
            [
                "sinamics_writer"
            ]
        ]
    },
    {
        "id": "relays_switch",
        "type": "switch",
        "z": "plc_tab",
        "name": "relays_switch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "relays",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 980,
        "y": 240,
        "wires": [
            [
                "relays_writer"
            ]
        ]
    },
    {
        "id": "power_on_delay_switch",
        "type": "switch",
        "z": "plc_tab",
        "name": "power_on_delay_switch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "power_on_delay",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 300,
        "wires": [
            [
                "power_on_delay"
            ]
        ]
    },
    {
        "id": "power_on_delay",
        "type": "delay",
        "z": "plc_tab",
        "name": "power_on_delay",
        "pauseType": "delay",
        "timeout": "15",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1220,
        "y": 300,
        "wires": [
            [
                "plc_function"
            ]
        ]
    },
    {
        "id": "info_debug",
        "type": "debug",
        "z": "plc_tab",
        "name": "info_debug",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 650,
        "y": 180,
        "wires": []
    }
]
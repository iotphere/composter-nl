Tamam, senin senaryonu netleÅŸtirelim:

Raspberry Pi Ã§alÄ±ÅŸÄ±yor

Kendi microSDâ€™si (OS kurulu, Pi Connect dahil) ana yuvasÄ±nda takÄ±lÄ±

BoÅŸ microSD USB kart okuyucuya takÄ±lÄ±, Piâ€™ye baÄŸlÄ±

SSH ile baÄŸlandÄ±n, ekran yok, sadece terminal var

AmacÄ±mÄ±z: kaynak kartÄ± â†’ hedef karta birebir kopyalamak (byte-by-byte)

Bunu yapmanÄ±n en pratik yolu Pi OSâ€™in kendi iÃ§inde zaten bulunan sdcard kopyalama yÃ¶ntemi â€” ama ekran olmadÄ±ÄŸÄ± iÃ§in GUI â€œSD Card Copierâ€ yok. Biz komut satÄ±rÄ± Ã¼zerinden dd ile yapacaÄŸÄ±z.

1ï¸âƒ£ Hangi disk hangi cihaz?
Ã–nce cihaz isimlerini bulmamÄ±z lazÄ±m:

bash
Kopyala
DÃ¼zenle
lsblk
Ã‡Ä±ktÄ±da ÅŸuna benzer bir ÅŸey gÃ¶receksin:

pgsql
Kopyala
DÃ¼zenle
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
mmcblk0     179:0    0 29.8G  0 disk 
â”œâ”€mmcblk0p1 179:1    0 256M   0 part /boot
â””â”€mmcblk0p2 179:2    0 29.5G  0 part /
sda           8:0    1 29.8G  0 disk 
â”œâ”€sda1        8:1    1 256M   0 part
â””â”€sda2        8:2    1 29.5G  0 part
mmcblk0 â†’ Piâ€™nin kendi OS kartÄ± (kaynak)

sda â†’ USB Ã¼zerinden takÄ±lan boÅŸ kart (hedef)

Burada isimler deÄŸiÅŸebilir, o yÃ¼zden kopyalamadan Ã¶nce hangi kartÄ±n hangisi olduÄŸunu kesin olarak doÄŸrula. YanlÄ±ÅŸ yaparsan kendi sistemi silebilirsin.

2ï¸âƒ£ Kopyalama iÅŸlemi
Terminalde:

bash
Kopyala
DÃ¼zenle
sudo dd if=/dev/mmcblk0 of=/dev/sda bs=4M conv=fsync status=progress
AÃ§Ä±klama:

if= â†’ input file = kaynak kartÄ±n cihaz adÄ±

of= â†’ output file = hedef kartÄ±n cihaz adÄ±

bs=4M â†’ 4 MB blok boyutu (hÄ±z iÃ§in)

conv=fsync â†’ yazma iÅŸlemini gÃ¼venli ÅŸekilde bitirir

status=progress â†’ ilerlemeyi gÃ¶sterir

3ï¸âƒ£ Bitince veri senkronizasyonu
bash
Kopyala
DÃ¼zenle
sync
Bu komut RAMâ€™de bekleyen tÃ¼m disk yazmalarÄ±nÄ± tamamlar.

4ï¸âƒ£ Test (opsiyonel)
Hedef kartÄ± Ã§Ä±kar, Piâ€™ye tak ve Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± gÃ¶r. EÄŸer Pi Connect kuruluyduysa hiÃ§bir ÅŸey deÄŸiÅŸmemiÅŸ gibi baÄŸlanacaksÄ±n.

ğŸ’¡ Notlar:

Kopyalama iÅŸlemi kartÄ±n kapasitesine gÃ¶re uzun sÃ¼rebilir (16â€“32 GB iÃ§in 5â€“15 dakika).

Hedef kart, kaynak karttan en az aynÄ± boyutta olmalÄ± (marka farkÄ± yÃ¼zÃ¼nden bazÄ± 32 GB kartlar aslÄ±nda 31.8 GB oluyor, bu uyumsuzluk olabilir).

EÄŸer daha kÃ¼Ã§Ã¼k karta kopyalamak istersen, Ã¶nce kaynak karttaki partitionâ€™u kÃ¼Ã§Ã¼ltÃ¼p imajÄ± alman gerekir.


------------------
msg.payload={
  method: <string>,
  params: {
    subject: <string>,
    body: <misc>,
    attach: <misc>
  }
}
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}

{
  "method": "settings",
  "params": {
    "subject": null,
    "body": "body": {"timers": {"fsm": {"end_timer": {"pulse": {"t_on": 10}}}}},
    attach: null
  }
}


{"subject": null, "body": {"timers": {"fsm": {"end_timer": {"pulse": {"t_on": 10}}}}}}
-------------------------------------------------------------
tekrar merhaba,

sinamic motor sÃ¼rÃ¼cÃ¼lerinde motorun hÄ±zÄ± 0-16384 arasÄ± bir deÄŸeri modbus'tan anlÄ±k olark gÃ¶ndererilerek belirlenebiliyor.

flow_context'te ÅŸunlar vardÄ±;
settings>sinamics>sinamics-actuator-name>speeds>low (8192 vardÄ±)
settings>sinamics>sinamics-actuator-name>speeds>full (16384 vardÄ±)
Ã¶rneÄŸin sinamics-actuator-name olarak hatch iÃ§in aÅŸaÄŸÄ±daki mesaj Ã§Ä±kÄ±yordu;
{
  "method": "default",
  "params": {
    "subject": "hatch",
    "body": "speed",
    "attach": "low"
  }
}
flow_context'te;
ÅŸu eklemeyi yaptÄ±m;
config>actuators>sinamics>max_speed (sinamics'lere Ã¶zgÃ¼ 16384 deÄŸerini yazdÄ±m)
ayrÄ±ca speeds alanÄ±nÄ± kaldÄ±rdÄ±m ve onun yerine ÅŸunu koydum;
settings>sinamics>sinamics-actuator-name>speed (0-100 arasÄ± bir deÄŸer).

0-100'e karÅŸÄ±lÄ±k 0-max_speed scale edilecek.
mesaj ÅŸÃ¶yle Ã§Ä±kacak;
{
  "method": "default",
  "params": {
    "subject": "hatch",
    "body": "speed",
    "attach": <0-max_speed arasÄ± deÄŸer>
  }
}

const flowData = flow.get("flow");
const max_speed = flowData.config?.actuators?.sinamics?.max_speed ?? 16384;
const hatch_speed = ((flowData.settings?.sinamics?.hatch?.speed ?? 100) / 100) * max_speed;
const fan_speed = ((flowData.settings?.sinamics?.fan?.speed ?? 100) / 100) * max_speed;
const water_pump_speed = ((flowData.settings?.sinamics?.water_pump?.speed ?? 100) / 100) * max_speed;
const discharger_speed = ((flowData.settings?.sinamics?.discharger?.speed ?? 100) / 100) * max_speed;


Ã¶zel durum.

{
  "method": "settings",
  "params": {
    "subject": "get",
    "body": <json>,
    "attach": null
  }
} bunun responsu mu
{
  "method": "settings",
  "params": {
    "subject": "set",
    "body": <json>,
    "attach": null
  }
} bud rumda neler yapmalÄ±?

{
  "method": "settings",
  "params": {
    "subject": "set",
    "body": <json>,
    "attach": "speed"
  }
} bud rumda neler yapmalÄ±?

payload: {
    method: "default",
    params: {
        subject: actuatorName,
        body: "speed",
        attach: realSpeed
    }
}

ÅŸimdiye kadar thingsboard'dan gelen settings method'lu mesajlarda subject kÄ±smÄ± hep null deÄŸerindeydi, doÄŸru mudur? ekleyeceÄŸimiz Ã¶zellik sayesinde thingsboard bizim flow context'ten veri isteyebilecek. bundan bÃ¶yle thingsboard'dan gelen settings method'lu mesajlarÄ±n subject'inde set veya get olacak mutlaka.
Ã¶ncelikle ÅŸunu yapalÄ±m, settings method'lularda ÅŸimdiye kadar yaptÄ±ÄŸÄ± iÅŸleri yalnÄ±zca gelen mesajÄ±n subject'tinde set varsa yapsÄ±n, koda bunu ekleyelim. bir sonraki adÄ±mda get ile ne yapacaÄŸÄ±na bakalÄ±m.. 
--------------------------------
merhaba, raspberry pi'de node red yÃ¼klÃ¼ ve node-red-contrib-modbus paketi yÃ¼klÃ¼. mqtt de kullanÄ±yorum.
ÅŸu ana kadar 8 adet fonksiyon nodu kullandÄ±m, kodlarÄ± Ã§alÄ±ÅŸÄ±yor.
fakat mesaj yapÄ±sÄ±nda ve bazÄ± yaklaÅŸÄ±mlarda kÃ¶klÃ¼ deÄŸiÅŸim yaptÄ±m.
ya kodlarÄ± sÄ±fÄ±rdan yazalÄ±m ya da revize edelim.
bu konuda yol gÃ¶stereceÄŸim. Ã¶ncelikle sana flow_context adlÄ± fonksiyon nodunun js kodunu gÃ¶nderiyorum, esas herÅŸey burada tanÄ±mlÄ± ve Ã¼zerinden iÅŸleyecek.
genel kural olarak nodlarda kÃ¼Ã§Ã¼k geÃ§ici runtime iÅŸlerdeki hafÄ±za gereksinimi iÃ§in nod context'i kullanalÄ±m.
diÄŸer faydalÄ± runtime deÄŸerler'i flow_context'in runtime kÄ±smÄ± ile etkileÅŸimli olarak Ã§Ã¶zelim.
bir nod mesaj Ã§Ä±karmadan Ã¶nce flow context'te varsa yapmasÄ± gereken gÃ¼ncellemeyi yapar.
flow'daki 8 fonksiyon nodunun listesi:
flow_context; 
giriÅŸine baÄŸlÄ± olan bir inject ile her node red restartÄ±nda flow context'ini elle yÃ¼klÃ¼yorum.
daha sonra settings.js'de diske yazan kalÄ±cÄ±lÄ±k ayarÄ±nÄ± yaptÄ±ÄŸÄ±mda bu noda gerek kalmayacak. 
digital_inputs_modbus 
analog_inputs_modbus
energy_meter_modbus
fsm
fsm_timer
actuators_timer
actuators_modbus
flow genelinde geÃ§erli olacak sabit bir mesaj yapÄ±mÄ±z var, hiÃ§ topic kullanmÄ±yoruz.
msg.payload={
  method: <string>, // settings | runtime
  params: <json> // full path in flow context
}  
bir kaÃ§ istisna dÄ±ÅŸÄ±nda daima bu mesaj yapÄ±sÄ± olacak, istisna durumlarÄ± Ã¶nceden bildireceÄŸim sana.
hazÄ±r mÄ±sÄ±n?





actuators_modbus

snake_case yazÄ±m kullanÄ±yorum, sen kendi Ã¼rettiÄŸin/geÃ§ici terimlerde camelCase kullan, bÃ¶ylece birbirimizi ayÄ±rabilelim.
flow'da supervisor olarak Ã§alÄ±ÅŸan context_manager ve mqtt_manager fonksiyon nodlarÄ± bulunur.
flow context'inin config alanÄ±na asla yazÄ±lmaz, settings ve live alanlarÄ±na da yalnÄ±zca context_manager yazabilir.
context_manager'Ä±n gerekli nodlara baÄŸlantÄ±larÄ± var, onlardan gelen mesajlara gÃ¶re settings ve live alanlarÄ±na yazar.
settings alanÄ±na yazÄ±lacak olanlar yalnÄ±zca mqtt_manager'dan gelir.
genel kural olarak flow context'i asla boÅŸyere ve sÄ±k meÅŸgul edilmez, hiÃ§bir periyodik yazma iÅŸlemi olmamalÄ±dÄ±r.
nodlar asla flow context'ine yazamazlar, yalnÄ±zca config ve settings kÄ±sÄ±mlarÄ±ndan okuyabilirler, live'de okuyamazlar.
nodlar kendi iÃ§ iÅŸleri iÃ§in, hafÄ±za gereksinimleri iÃ§in, yalnÄ±zca kendi node context'lerini kullanÄ±rlar.

---------------------------------------------
tamamdÄ±r, sÄ±fÄ±rdan yazalÄ±m. digital_inputs ile baÅŸlayalÄ±m.
giriÅŸine bir modbus flex getter nodu baÄŸlÄ± ve her 100ms'de bir mesaj geliyor. 
gelen mesaj 16 bitlik tek bir sayÄ± iÃ§eren array.
config alanÄ±ndaki bit_map ve label_map'e bakarak mesajÄ± Ã§Ä±karacak.
Ã§Ä±kacak Ã¶rnek mesaj payload'u(1 bit iÃ§in);
{
  method: "runtime",
  params: {
    io: {
      digital_inputs: {
        oxygen: "on"
      }
    }
  }
}
Ã¶nce bir double-check parazit filtresi yapar ve yalnÄ±zca deÄŸiÅŸim olan bit(ler) varsa o durumda mesaj Ã§Ä±karÄ±r, aynÄ± anda birden fazla bit deÄŸiÅŸmiÅŸse, ardarda ayrÄ± ayrÄ± mesajlar Ã§Ä±karÄ±r her bit iÃ§in, bit_map sÄ±rasÄ±na gÃ¶re.
yani bir deÄŸiÅŸimin geÃ§erli sayÄ±lmasÄ± iÃ§in en az ardarda 2 mesajda deÄŸerinin aynÄ± gelmesi gerekir, bir tÃ¼r validation onayÄ± diyelim, parazit deÄŸilmiÅŸ anlamÄ±nda. 
ve bu periyodik iÅŸteki hafÄ±za gereksinimi iÃ§in kendi nod context'ini kullanÄ±r, ger 100ms'de bir flow context'ini meÅŸgul etmez, zaten geÃ§ici bir kullanÄ±m, faydalÄ± bilgi deÄŸeri yok.
eÄŸer mesaj Ã§Ä±kacaksa yani en az bir bitlik deÄŸiÅŸim varsa Ã¶nce flow context'te runtime alanÄ±ndaki biti(leri) gÃ¼nceller, sonra mesajÄ±nÄ± Ã§Ä±karÄ±r.
flow context'ini full path kullanarak kolayca gÃ¼nceller umuyorum. 
genel not: gÃ¶nderdiÄŸim flox_context'te ÅŸu an aynÄ± Ã¶geler iÃ§in deÄŸerler hep aynÄ± ama bunlarÄ±n sonra elbette gerÃ§ek farklÄ± deÄŸerini yazcaÄŸÄ±m. 
---------------------------------------
tamamdÄ±r, kodlarÄ± daha sonra test edeceÄŸim.
aynÄ± yaklaÅŸÄ±mla analog_inputs_modbus'a geÃ§elim ÅŸimdi.
analog_inputs_modbus'a modbus flex getter'dan 8 sayÄ±sal deÄŸer geliyor array olarak, register_map ve label_map kullan.
parazit filtresi ve deÄŸiÅŸim onayÄ± iÃ§in tolerans kullanalÄ±m analog deÄŸerler olduklarÄ±na gÃ¶re.
ayrÄ±ca bir de factor ile Ã§arpalÄ±m, tÃ¼m registerler iÃ§in aynÄ±dÄ±r. 
-----------------------------------------
flow'da Ã¶nemli deÄŸiÅŸikler yapmak istiyorum.
1.
flow mesaj akÄ±ÅŸÄ± iÃ§in bir adres sistemi belirledim.
bundan bÃ¶yle payload'larÄ±n method alanÄ±nda mesajÄ±n ulaÅŸmasÄ±nÄ± istediÄŸim fonksiyon nodunun adÄ± olacak.
{
  method: <nod_adÄ±>,
  params: {...}
}
adÄ±na gÃ¶nderilmediyse Ã§Ä±kÄ±ÅŸa paslayÄ±p return ile Ã§Ä±kacak.
adÄ±na ise kodu devam ettirecek.
2.
flow context'ini daha sade ve kullanÄ±ÅŸlÄ± hale getirmeye Ã§alÄ±ÅŸtÄ±m, daha fazla runtime odaklÄ±.
Ã¶rneÄŸin bit_map, register_map gibi kÄ±sÄ±mlara ayrÄ±ca gerek yok.

eski flow_context js kodunu tamamen unut, yenisini gÃ¶nderiyorum.
daha Ã¶nce yazdÄ±ÄŸÄ±n digital_inputs, analog_inputs, energy_meter fonksiyon kodlarÄ±nÄ± da yeni_flow_context'e gÃ¶re revize etmeliyiz sonraki adÄ±mlarda.
ve hatta bu kodlarÄ± gerekirse bir de optimize et hazÄ±r dokunmuÅŸken.

ilk olarak flow_context kodunu gÃ¶ndereceÄŸim hazÄ±r mÄ±sÄ±n..
-----------------------------------
genel olarak flow'un node red restart'Ä±ndan(restart/power reset/boot) etkilenmiyor olmasÄ±nÄ±, restore olmasÄ±nÄ± istiyorum, olabildiÄŸince.
node red settings.js'de contextStorage iÃ§in localfilesystem aktif edeceÄŸim, bÃ¶ylece node red context'leri arka planda her flushinterval periyodu geldiÄŸinde (default 30s) diske diske yazÄ±p periyodik olarak saklar.
biz bir context'e Ã¶rneÄŸin her saniye yazsak da flushinterval periyodu gelmeden diske yazÄ±lmÄ±yor, yani en kÃ¶tÃ¼ 30 saniyelik bir sapma olur restore'larda, makuldur.
bunu belirttim Ã§Ã¼nkÃ¼ genel olarak flow'daki timer'larÄ± da kendimiz ve kalÄ±cÄ± olarak tasarlamalÄ±yÄ±z.
Ã§Ã¼nkÃ¼ uzun sÃ¼reli zamanlamalar iÃ§in kalÄ±cÄ±lÄ±k gerekli.
inject veya delay gibi node red'in kendi nod'larÄ± restart durumunda kalÄ±cÄ± deÄŸiller. 
ve artÄ±k tek bir timer fonksiyon nodu olacak, sana Ã¶nceden isimlerini belirtmiÅŸ olduÄŸum actuators_timer ve fsm_timer nodlarÄ±nÄ± iptal ettim.
timer nodu fsm noduyla mesaj alÄ±ÅŸveriÅŸi, actuators_modbus'a ise yalnÄ±zca gÃ¶nderecek.
kÄ±saca yapacaÄŸÄ± iÅŸ; gelen mesajÄ± zamanlayÄ±p Ã§Ä±kÄ±ÅŸtan iletir.
biliyorsun flow'daki mesaj yapÄ±mÄ±zda params kÄ±smÄ±nda flow context'indeki full path'i belirtmeye Ã¶zen gÃ¶steriyoruz.
bÃ¶ylece mesajÄ± alan nodun yapacaÄŸÄ± iÅŸ ve gÃ¼ncellenecek flow context ile ilgili bilgi iletmiÅŸ oluyoruz, sanÄ±rÄ±m bÃ¶yle sÃ¶ylemek yanlÄ±ÅŸ olmaz evet.
neyse genellemeler bazen hatalÄ± olabilir biz net adÄ±mlarla ilerleyelim.

timer noduna gelecek olan Ã¶rnek bir mesaj ve yapÄ±lacak iÅŸler:
{
  method: "fsm",
  params: {actuators: {timers: {timer_1: {action: "stop"}, timer_2: {action: "stop"}, timer_3: {action: "stop"}, timer_4: {action: "run"}}}}
}
flow context'teki diÄŸer hatch timer'larÄ±(timer_1,2,3) kapatÄ±lacak, onlarÄ±n herbiri iÃ§in flow_context'te action: "stop" olarak gÃ¼ncellenecek.
timer_4 iÃ§in flow context'te action: "run" olarak gÃ¼ncellenip, timer_4 baÅŸlatÄ±lacak.
timer_4 bir pwm timer olduÄŸundan ilk olarak on phase'ine geÃ§ecek.
hemen ÅŸu mesaj Ã§Ä±kacak;
{
  method: "fsm",
  params: {actuators: {sinamics: {hatch: {action: "forward_run"}}}}
}
on sÃ¼resi dolduÄŸunda ÅŸu mesaj Ã§Ä±kacak;
{
  method: "fsm",
  params: {actuators: {sinamics: {hatch: {action: "forward_run"}}}}
}

bir baÅŸka Ã¶rnek mesaj:
{
  method: "fsm",
  params: {fsm: {timers: {timer_2: {active: true}}}}
}
timer nodu 2 Ã§Ä±kÄ±ÅŸlÄ± olacak, 1 nolu Ã§Ä±kÄ±ÅŸ fsm'ye, 2 nolu Ã§Ä±kÄ±ÅŸ ise actuators_modbus'a mesaj gÃ¶nderecek biÃ§imde baÄŸlÄ±lar.



iki port Ã§Ä±kÄ±ÅŸlÄ±.
aÅŸaÄŸÄ±da timer tiplerini (type) gÃ¶rebilirsin.
always; gelen mesajÄ± anÄ±nda iletir.
pulse; gelen mesajÄ± anÄ±nda iletir ve t_on sÃ¼resi sonunda 

, pulse, delay, pwm. 
kÃ¼Ã§Ã¼k iÅŸler nod context, diÄŸerleri dÄ±ÅŸardan takip edilsin.
thingsboard rpc initial.

---- timer on start context'te map yap, ÅŸu an 35 adet
flow context'e yeni timer ekle/Ã§Ä±kar yapÄ±p node red restart yaptÄ±ÄŸÄ±mda on start sayesinde bu map oluÅŸur ve timer koduna hiÃ§ dokunmama gerek kalmaz.

flow'da yalnÄ±zca fsm_timer ve actuators_timer nodlarÄ± timer iÃ§eriyor olacak.
4 ayrÄ± timer tipi olacak; always, pulse, loop, pwm.
zamanlamalara gÃ¶re ve tipine gÃ¶re phase deÄŸiÅŸimlerinde mesaj Ã§Ä±karacaklar.
gelen baÅŸlat/durdur mesajlarÄ± ile ilk mesaj Ã§Ä±kÄ±ÅŸÄ± baÅŸlar.
esnek dÃ¼ÅŸÃ¼n.
fsm_timer run/stop komutlarÄ± alÄ±r, actuators_timer ise run/forward_run/reverse_run/stop komutlarÄ± alÄ±r.

genel kuralÄ±mÄ±z ÅŸÃ¶yledir; timer nod'larÄ±ndan Ã§Ä±kan mesajlar, gelen baÅŸlat/durdur komutunu  
always aslÄ±nda timer olmasa da timer kategorisine almÄ±ÅŸ oldum, elbette kendiliÄŸinden stop olmaz.
pulse, bir sÃ¼re sonunda stop mesajÄ± Ã§Ä±karÄ±r.
loop, periyodik olarak run mesajÄ± Ã§Ä±karÄ±r.
pwm, phase geÃ§iÅŸlerinde mesaj Ã§Ä±karÄ±r(yeni phase'i Ã§Ä±karÄ±r).
flow_context'in settings kÄ±smÄ±ndaki timer deÄŸerleri saniye birimindedir, yani saniye'lik hassasiyet benim iÃ§in yeterli.
kalÄ±cÄ± timer tasarlamak iÃ§in aklÄ±mda 3-4 farklÄ± yol var ama sana bÄ±rakÄ±yorum, istediÄŸin gibi yap.
eÄŸer dÄ±ÅŸardan timer tick mesajÄ± da gelmesini istiyorsan bana bildir, flow'a 1 saniye periyod'lu bir inject nodu eklerim, hem actuators_timer'Ä±n ve hem de fsm_timer'Ä±n giriÅŸine baÄŸlarÄ±m.
inject'ten nod'lara her saniye giden mesaj ÅŸÃ¶yle olur;
{
  method: "runtime",
  params: {
    tick: true
  }
}
timer'larda on/off terimleri kullanma.


benim iÃ§im ÅŸu yeterlidir; timer'lar her baÅŸlatÄ±ldÄ±ÄŸÄ±nda flow context'e bir timestamp yazalÄ±m, power reset sonrasÄ± timestamp'ten geÃ§en sÃ¼reye baksÄ±n.
tabi Ã§ok uzun elektrik kesilmelerinde, geride kalan ve yapmasÄ± gerekip de yapmamÄ±ÅŸ olacaÄŸÄ± zamanlamalÄ± iÅŸleri yok saymÄ±ÅŸ olur, olsun mÃ¼him deÄŸil.
yani aklÄ±mda 3-4 Ã§eÅŸit ve daha hassas/detaylÄ± kalÄ±cÄ± timer yaklaÅŸÄ±mÄ± var ama bu sÃ¶ylediÄŸim en basit olanÄ± yeterlidir.
bu timestamp alanlarÄ±nÄ± Ã¶zellikle flow context'inde oluÅŸturdum ki kalan sÃ¼re dÄ±ÅŸardan kalan sÃ¼re vb. 


fsm_timer'a 2 yerden mesaj geliyor;
1) 1hzlik tick mesajÄ±(payload), ÅŸÃ¶yle kabul edelim, yeterlidir.
{
  method: "runtime",
  params: {
    tick: true
  }
}
2) fsm nodundan, Ã¶rnek.
{
  method: "runtime",
  params: {
    fsm: {      
      timers: {
        end_timer: {
          actions: "stop" // stop | run
  }
}
timer'larÄ± kalÄ±cÄ± olarak tasarlamalÄ±yÄ±z, recovery olabilmeli.
bunun iÃ§in 3-4 yÃ¶ntem var aklÄ±mda.
fakat en sade olanÄ± yapalÄ±m, evet elektrik uzun sÃ¼re kesildiÄŸinde, yapmasÄ± gereken iÅŸi atlamÄ±ÅŸ olacak o timer'la Ã§alÄ±ÅŸan Ã¶geler ama sorun deÄŸil.
"forever" tipi zaten timer sayÄ±lmaz. 
pulse tipi baÅŸlatÄ±ldÄ±ÄŸÄ±nda, pwm tipi ise her on/off faz geÃ§iÅŸinde olmak Ã¼zere, bir timestamp kaydetsin, yani her tick'te kaydetmeye gerek yok.
flow context'in runtime'Ä±na ben ilave timer'lar iÃ§in timestamp alanlarÄ± ekleyeceÄŸim birazdan, ÅŸu alanlar uygun mudur?
(hatÄ±rlatma: herhangi bir actuator iÃ§in aynÄ± anda yalnÄ±zca 1 timer Ã§alÄ±ÅŸabilir.)

sanÄ±rÄ±m date.now() ve elapsed time

ister javascript'teki settimeout vb. fonksiyonlarÄ± kullanalÄ±m isterse date.now() ve elapsed time olsun, timer'larÄ± kalÄ±cÄ± olarak tasarlamalÄ±yÄ±z.
gelen her tick'te context'te kayÄ±t tutmalÄ±yÄ±z, ki recovery olabilsin.
bu kaydÄ± flow context'te tutalÄ±m ki  
---------------------------------------
merhaba, 
raspberry pi node red ile bir flow oluÅŸturmak istiyorum.
node-red-contrib-modbus paketi yÃ¼klÃ¼.

genel aÃ§Ä±klama yapmak isterdim fakat Ã§ok uzun sÃ¼recek.
o nedenle flow'daki fonksiyon nodlarÄ±nÄ± adÄ±m adÄ±m oluÅŸturalÄ±m.
ilk olarak hazÄ±r haldeki flow_context'i gÃ¶ndereyim ki iÃ§erik anlaÅŸÄ±lsÄ±n.
daha sonra bazÄ±larÄ± iÃ§in Ã¶nceki tecrÃ¼bemden kodlar gÃ¶nderip revize etmeni isteyeceÄŸim flow_context'e gÃ¶re.
bazÄ±larÄ±nÄ± ise sÄ±fÄ±rdan yazmanÄ±.

hazÄ±rsan flow context'i gÃ¶ndereyim..
----------------
tamamdÄ±r, tÃ¼m fonksiyon nodlarÄ±nda genel yaklaÅŸÄ±mÄ±mÄ±z ÅŸÃ¶yle olsun.
kÃ¼Ã§Ã¼k iÅŸlerde hafÄ±za gereksinimi node context ile karÅŸÄ±lanÄ±r, tÃ¼m faydalÄ± bilgiler ve Ã¶n plana Ã§Ä±kacak olanlar runtime Ã¼zerinde iÅŸlem gÃ¶rÃ¼r.
flow context yapÄ±sÄ± korunur, nested yapÄ±, iÃ§indeki datakey'ler, hiÃ§bir ÅŸey deÄŸiÅŸmez, eklenmez, Ã§Ä±karÄ±lmaz. 
ileriki adÄ±mlarda, Ã¶rneÄŸin kalÄ±cÄ± (persistence) timer'lar iÃ§in runtime alanÄ±na ilave datakey'ler eklenecek. 
gÃ¶nderdiÄŸim kodlardaki notasyon iptal edilip, tÃ¼mÃ¼yle flow_context'teki notasyon kullanÄ±lacak, Ã¶rneÄŸin, bit, map, register notasyonlarÄ± yerine channels notasyonu gibi.
flow'da hiÃ§bir zaman topic kullanÄ±lmayacak.
tÃ¼m mesajlarda yapÄ± aÅŸaÄŸÄ±daki gibidir, method daima string, params daima object:
msg.payload={
  method: <string>,
  params: {....}
} 

ÅŸimdi digital_inputs_modbus fonksiyon nodu ile baÅŸlayalÄ±m.
bu noda her 100ms'de bir flex getter'dan array iÃ§inde tek bir sayÄ± gelir.
gÃ¶receÄŸin gibi ardarda 2 deÄŸerin aynÄ± olmasÄ± istenerek bir parazit filtresi var.
ve deÄŸiÅŸen channel(s) varsa her biri iÃ§in ayrÄ± mesaj Ã§Ä±kar.
deÄŸiÅŸim yoksa asla mesaj Ã§Ä±kmaz.
Ã§Ä±kacak mesaj yapÄ±sÄ± ÅŸu Ã¶rnek gibi olsun:
msg.payload={
  method: "oxygen_detector",
  params: {state: "on"}
}

digital_inputs_modbus fonksiyon nodu:
-------------------------------------------------
Ã¶nce ÅŸu bilgiyi senle paylaÅŸmalÄ±yÄ±m.
evet flow'un node red restart'Ä±ndan(power reset/reboot) mÃ¼mkÃ¼n olduÄŸunca etkilenmemesini istiyorum.
bir miktar zaman sapmasÄ± makul kabul edilir.
settings.js'de ÅŸunu yapacaÄŸÄ±m:
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
node red tÃ¼m context'lerin global(kullanmÄ±yoruz)/flow/node, her 30 saniyede bir(flushinterval) anlÄ±k gÃ¼ncel halini diske kaydeder.
bu iÅŸlemi arka planda yapar, kendi baÄŸÄ±msÄ±z zamanlamasÄ±yla.
Ã¶rneÄŸin flow contet her 1 saniyede gÃ¼ncelleniyor da olsa, diske yalnÄ±zca bir sonraki flushinterval geldiÄŸinde en gÃ¼ncel hali kaydedilir.
node red restart olduÄŸunda, flow en kÃ¶tÃ¼ senaryoda power down'dan 30 saniye Ã¶ncesindeki runtime deÄŸerleri ile yeniden Ã§alÄ±ÅŸmaya baÅŸlayacaktÄ±r.
bu benim iÃ§in makul bir sÃ¼redir. 
peki ya timer'lar?
node red'in timer Ã¶zelliÄŸi olan inject/delay gibi nodlarÄ± restart durumunda sÄ±fÄ±rlanÄ±r, kalÄ±cÄ± deÄŸiller.
ÅŸimdi timer_manager adlÄ± fonksiyon noduna geÃ§elim.
zamanla alakalÄ± tÃ¼m iÅŸler bu nodda olacak.
ileride kurguladÄ±ÄŸÄ±m fsm adlÄ± fonksiyon nodunun yÃ¼kÃ¼ almak iÃ§in, timer_manager'Ä± dummy delay timer olarak deÄŸil de bir gÃ¶rev zamanlayÄ±cÄ± gibi tasrlamanÄ± istiyorum.
delay/pwm/loop olarak 3 tipte ve birbirlerinden baÄŸÄ±msÄ±z, Ã¶zel adlarÄ± olan, Ã¶n tanÄ±mlÄ± gÃ¶revleri olan, kalÄ±cÄ± timer'lar iÅŸleyecek bu nodda.
bu nod bir injenct tarafÄ±ndan tick biÃ§iminde her 1 saniyede tetikleniyor olacak.
date.now yÃ¶ntemi ile kalÄ±cÄ± timer'lar gerÃ§ekleÅŸtirilecek.
her tick'te, o an state="on" olan timer'lar flow context'in runtime kÄ±smÄ±nda kendi alanlarÄ±ndaki anlÄ±k zaman deÄŸerlerini gÃ¼ncelleyecek.  
Ã¶rneÄŸin flow_context'teki fan_pwm_mid: {state: "off", phase: null, x: 0, y: 0,...} alanÄ±na.
bu alanlara eklenecek x,y... key'leri bana da bildir lÃ¼tfen.
pwm iÃ§in phase_a, phase_b notasyonunu kullanalÄ±m, phase_a ile baÅŸlar.
t_duty deÄŸeri phase_a sÃ¼residir. t_cycle deÄŸeri ise phase_a + phase_b yani toplam tekrar periyodu sÃ¼residir.
timer'lar on/of ve phase_a, phase_b deÄŸiÅŸimleri ve diÄŸer kalÄ±cÄ±lÄ±k/takip bilgilerini daima runtime alanÄ±nda kendileri gÃ¼nceller.
peki timer_manager nodu nasÄ±l mesajlaÅŸacak, tick haricinde gelen diÄŸer mesajlarda ne yapacak?
Ã¶zetle gelen mesajdaki method'a karÅŸÄ±lÄ±k, Ã¶n tanÄ±mlÄ± methodlarÄ± olan zamanlanmÄ±ÅŸ mesajlar Ã¼retecek. 
delay tipi 2 defa mesaj Ã§Ä±karÄ±r; baÅŸladÄ±ÄŸÄ±nda ve duration sÃ¼resi dolduÄŸunda.
loop tipi; baÅŸladÄ±ÄŸÄ±nda ve her intervalde.
pwm tipi; baÅŸladÄ±ÄŸÄ±nda ve her phase geÃ§iÅŸinde mesaj Ã§Ä±karmaya devam ederek.

bu durumda sanÄ±rÄ±m sana bir tablo halinde gelen mesaj ve karÅŸÄ±lÄ±ÄŸÄ±nda Ã§Ä±kan mesajlarÄ± aÃ§Ä±k aÃ§Ä±k yazmalÄ±yÄ±m.
ÅŸimdilik konsept bu, tabloyu hazÄ±rlamaya Ã§alÄ±ÅŸÄ±yorum..
----------------------------
ÅŸimdi timer_manager konusunda Ã¶nÃ¼mde 2 seÃ§enek var;
A) senin Ã¶nerdiÄŸin dummy timer yaklaÅŸÄ±mÄ±.
msg.payload = {
  method: "<timer_ismi>",       // Ã¶rn: fan_pwm_mid
  params: { state: "on" | "off", phase?: "phase_a" | "phase_b" }
}
yani yalnÄ±zca kendinden bahseden mesajlar Ã§Ä±karan timer.
B) mesaj(gÃ¶rev) zamanlayÄ±cÄ±, bir tÃ¼r time base driver gibi, veya node red'in delay nodu gibi dÃ¼ÅŸÃ¼nelim Ã¶n tanÄ±mlÄ± mesaj var, bu mesajÄ± zamanlÄ±yor.

SEÃ‡Ä°M:
Ben B seÃ§eneÄŸi diyorum;
yani mesaj zamanlayÄ±cÄ±, benim fsm nodunda ve ileride mqtt nodunda, timer_manager'dan gelen mesajlarÄ± timer konusundan soyutlanmÄ±ÅŸ ve tÄ±pkÄ± diÄŸer event'lar gibi deÄŸerlendirebilmemi saÄŸlacak olan, ve zamanla alakalÄ± tÃ¼m iÅŸlevleri timer_manager'da tutan, bir driver/scheduler gibi Ã§alÄ±ÅŸÄ±p diÄŸer nodlarÄ± yÃ¼kten kurtaran.
zaten timer isimlerini gÃ¶rÃ¼yosun, hep Ã¶zel iÅŸlere gÃ¶re isimlendirdim.

ÅŸimdi yol haritam ÅŸÃ¶yle;
1)
Ã¶nce timer tiplerine gÃ¶re verdiÄŸin yeni key'leri her bir timer iÃ§in flow_context koduna yerleÅŸtireceÄŸim.
benim B seÃ§eneÄŸine geÃ§memden sonra bu ilave key'lerde bir deÄŸiÅŸiklik sÃ¶z konusu ise bana bildir lÃ¼tfen.
2)
config>timers alanÄ±nda her bir timer'Ä±n kendi alanÄ±nda bir pass: {} objesi iÃ§inde o timer'a Ã¶zel olarak, timer'Ä±n hangi durumunda hangi mesaj Ã§Ä±kacaÄŸÄ±nÄ± Ã¶n tanÄ±mlÄ± hale getireceÄŸim.
timer'a bir start komutu gelecek ve timer kendini state="on" yapÄ±p gÃ¶reve baÅŸlayacak. 
delay tipi timerlarda 2 mesaj olacak, bunlar birer defa Ã§Ä±kmÄ±ÅŸ olacak;
pass: {on: {method:<method>, params: {<params>}}, off: {method:<method>, params: {<params>}}}
pwwm tipi timerlarda 2 mesaj olacak, bunlar dÃ¶ngÃ¼ halinde Ã§Ä±kmaya devam edecek;
pass: {phase_a: {method:<method>, params: {<params>}}, phase_b : {method:<method>, params: {<params>}}}
loop tipi timerlarda 1 mesaj olacak, bu dÃ¶ngÃ¼ halinde Ã§Ä±kmaya devam edecek;
pass: {loop: {method:<method>, params: {<params>}}}

ÅŸu ayrÄ±ntÄ±larÄ± da tekrar vericem.
timer start'ta hemen ilk mesaj Ã§Ä±ksÄ±n mÄ±, ÅŸu an iÃ§in evet diyorum.
bir timer state="on" iken zorla durdurmak iÃ§in stop mesajÄ± gelirse ne mesajÄ± Ã§Ä±karsÄ±n, buna da bakarÄ±m.

unuttuÄŸum bir ÅŸey var mÄ± bilmiyorum, bu planÄ±ma ne dersin, kullanÄ±ÅŸlÄ± mÄ±?







method kÄ±smÄ± aynen korunacak.

harika,
ve benim aÅŸaÄŸÄ±daki timer'larda dÃ¼zeltme yapmam gerekiyor, Ã§Ã¼nkÃ¼ aslÄ±nda bunlar type: "down_counter" olmalÄ±ydÄ±.
ve her decriment'te mesaj Ã§Ä±karmalÄ±ydÄ±.
config>timers alanÄ±nda bunlar iÃ§in ÅŸÃ¶yle deÄŸiÅŸiklik yaptÄ±m:
end_day_counter: {type: "down_counter", interval: 1, base: 21, unit: "d"},
dry_day_counter: {type: "down_counter", interval: 1, base: 3, unit: "d"},
runtime alanÄ±nda ise ÅŸÃ¶yle deÄŸiÅŸiklik yaptÄ±m:
end_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
dry_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
Ã¶rneÄŸin end_day_counter 21'den aÅŸaÄŸÄ± sayÄ±yor ve her sayÄ±da bir mesaj Ã§Ä±karÄ±yor olacak, yani down_counter'Ä±n mesajÄ± dinamik.
start verildiÄŸinde iÃ§inde 21 olan mesaj Ã§Ä±karacak, son mesaj'Ä±n iÃ§inde sÄ±fÄ±r olacak ve timer kendini kapatacak(state: "off").
config ve runtime olarak key'ler doÄŸru mu, uygun mu?
tabi tÃ¼m timer'lar iÃ§in config kÄ±smÄ±ndaki pass mesajlarÄ±nÄ± hazÄ±rlamaya devam ediyorum.
delay, pwm, loop, down_counter olarak 4 tip timer oldu bÃ¶ylece.

config>timers:
end_day_counter: {type: "counter", direction: "down", interval: 1, base: 21, unit: "d"},
dry_day_counter: {type: "counter", direction: "down", interval: 1, base: 3, unit: "d"},
runtime alanÄ±nda ise ÅŸÃ¶yle deÄŸiÅŸiklik yaptÄ±m:
end_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
dry_day_counter: {state: "off", start_time: 0, count: 0, next_time: 0},
------------------------------
tekrar merhaba,
birazdan flow_contex'i yeni haliyle sana gÃ¶ndereceÄŸim.
not: config>io alanÄ±nda bazÄ± geliÅŸtirmeler yaptÄ±m.
ÅŸimdilik o alanÄ± hiÃ§ dikkate alma, Ã§Ã¼nkÃ¼ Ã¶ncelikle timer_manager'a odaklanmalÄ±yÄ±z.
hazÄ±rsan flow_contex'i gÃ¶ndereyim.
ve hemen bir sonraki adÄ±mda timer_manager aÃ§Ä±klamasÄ±nÄ± gÃ¶ndereceÄŸim.

timer_manager aÃ§Ä±klamasÄ±:
iyice dÃ¼ÅŸÃ¼nÃ¼p gereksiz timer'larÄ± sildim, tabi yine; delay, pwm, loop, counter olarak 4 tip var.
timer'lar birer mesaj(gÃ¶rev) zamanlayÄ±cÄ± yani scheduler gibi Ã§alÄ±ÅŸacak.
config>timers alanÄ±nda her bir timer iÃ§in Ã¶n tanÄ±mlÄ± mesajlar var, pass alanlarÄ±nda.
timer_manager 3 Ã§Ä±kÄ±ÅŸ portlu bir fonksiyon nodudur, pass alanlarÄ±nda hangi mesajÄ±n hangi porttan gÃ¶nderileceÄŸini belirttim.
tabi ki gÃ¶nderilecek mesajda port: keyleri olmayacak.
timer_manager noduna timerlar iÃ§in start mesajlarÄ± gelecek ve nod zamanlanmÄ±ÅŸ mesajlar gÃ¶ndermeye baÅŸlayacak, Ã¶rneÄŸin;
{
  method: "timer_start",
  params: {target: "water_pump_pwm"}
}
timer_start o timerÄ± resetleyip baÅŸlatÄ±r.
gÃ¶reve devam ediyorken timerlara dÄ±ÅŸardan zorla stop mesajlarÄ± da gelebilecek, Ã¶rneÄŸin;
{
  method: "timer_stop",
  params: {target: "water_pump_pwm"}
}
timer_stop o timerÄ± resetlenip durdurur.
yani timer_managera yalnÄ±zca iki farklÄ± methodla mesaj gelir; timer_start, timer_stop.
pass alanÄ±nda mesajlarÄ± doÄŸal olay akÄ±ÅŸ sÄ±rasÄ±na gÃ¶re yazmaya Ã§alÄ±ÅŸtÄ±m.
delay tipinde:
timer_start geldiÄŸinde pass.1 gÃ¶nderecek.
duration sÃ¼resi dolduÄŸunda pass.2 gÃ¶nderecek.
timer_stop geldiÄŸinde pass.2 gÃ¶nderecek.
pwm tipinde:
timer_start geldiÄŸinde ve her phase_a fazÄ±na geÃ§iÅŸte pass.1 gÃ¶nderecek.
her phase_b fazÄ±na geÃ§iÅŸte pass.2 gÃ¶nderecek.
timer_stop geldiÄŸinde pass.2 gÃ¶nderecek.
loop tipinde:
timer_start geldiÄŸinde ve her intervalde pass.1 gÃ¶nderecek.
timer_stop geldiÄŸinde pass.1 gÃ¶nderecek.
counter tipinde:
timer_start geldiÄŸinde pass.1 gÃ¶nderecek.
bitime signal sÃ¼resi kaldÄ±ÄŸÄ±nda (count=signal olduÄŸunda) pass.2 gÃ¶nderecek, bu Ã¶zelliÄŸi yeni ekledim.
bittiÄŸinde (Ã¶rneÄŸin fsm_day_counter iÃ§in count=0 olduÄŸunda) pass.3 gÃ¶nderecek.
istisnasÄ±z olarak her mesajla birlikte(timer_start geldiÄŸinde dahil) pass.4 mesajÄ± da gÃ¶nderecek.
pass.4 dinamik deÄŸer iÃ§eriyor, her defasÄ±nda fsm_day=count yaparak gÃ¶nderecek.
timer_stop geldiÄŸinde pass.3 gÃ¶nderecek.
-------------------------
her bir mesajÄ± ilgili portunu hesaba katarak bir mesaj buffer'Ä±na push edip, fonksiyondan tek defada return msg; ile Ã§Ä±kmak en iyisi olur, doÄŸru mudur? tabi eÄŸer gÃ¶nderilecek mesaj varsa.
pwm iÃ§in sÃ¼re hesabÄ± ÅŸÃ¶yleydi, hatÄ±rlayalÄ±m:
timer_start geldiÄŸinde pwm dÃ¶ngÃ¼sÃ¼ phase_a ile baÅŸlar.
phase_a sÃ¼resi t_duty kadardÄ±r.
phase_b sÃ¼resi t_cycle - t_duty kadardÄ±r.
yani t_cycle dÃ¶ngÃ¼sel sÃ¼redir. 
----------------------
Ã¶nce digital_inputs_modbus nodunu hem flow_context ile uyumlu hale getirelim ve hem de 2 Ã§Ä±kÄ±ÅŸ portlu hale getirelim.
1 no'lu porttan mevcut koddaki mesaj yapÄ±sÄ± Ã§Ä±ksÄ±n, ve 1 nolu porttan her ne zaman mesaj Ã§Ä±karsa 2 no'lu port'tan da aÅŸaÄŸÄ±daki Ã¶rnek yapÄ±daki gibi mesaj Ã§Ä±ksÄ±n;
{
  method: "publish_on_change",
  params: {oxygen_detector: "off"}
}
daha sonra analog_inputs_modbus ve energy_meter_modbus fonksiyon nodlarÄ±nda yapÄ±lacak revizyonlarÄ± sÃ¶yleyeceÄŸim.
Ã§Ã¼nkÃ¼ onlarÄ±nki biraz farklÄ±.

digital_inputs_modbus kodunu gÃ¶ndereceÄŸim hazÄ±r mÄ±sÄ±n?
--------------------
ÅŸimdi analog_inputs_modbus noduna geÃ§elim.
mevcut mantÄ±k ve mesaj yapÄ±sÄ±nda kalÄ±p flow_context'e uyumlu hale getirilecek.
not: factor ve tolerans deÄŸerleri Ã¶zelleÅŸtirildi.
tek Ã§Ä±kÄ±ÅŸlÄ± olarak kalacak.
config'deki material_detector: {off: 30, on: 60}} deÄŸerlerini hiÃ§ dikkate almayacak.
Ã§Ã¼nkÃ¼ daha sonra Ã§Ä±kÄ±ÅŸÄ±na analog_detector adlÄ± bir nod baÄŸlayacaÄŸÄ±z ve detector deÄŸerleri analog_detector'da kullanÄ±lacak.

hazÄ±r mÄ±sÄ±n analog_inputs_modbus'Ä± gÃ¶ndereyim mi?


analog_inputs_modbus nodunun Ã§Ä±kÄ±ÅŸÄ± analog_detector adlÄ± bir fonksiyon nodunun giriÅŸine baÄŸlÄ±.
ÅŸimdi analog_detector kodunu sÄ±fÄ±rdan yazmanÄ± istiyorum.
2 Ã§Ä±kÄ±ÅŸ portlu olacak.
analog_inputs_modbus'dan gelen mesajlardaki analog deÄŸerlere gÃ¶re(material_level, water_level gibi) ve config kÄ±smÄ±ndaki material_detector: {off: 30, on: 60}} hysteresis eÅŸik seviyelerine gÃ¶re, material_detector ve water_detector adlÄ± on/off deÄŸerli mesajlar Ã§Ä±karacak, tabi ki deÄŸiÅŸimlerinde.
bu mesajlar tÄ±pkÄ± diÄŸer nodlardaki gibi her zamanki mesaj yapÄ±sÄ±nda olacak ve 1 nolu porttan Ã§Ä±kacak.
ve tabi ki Ã¶nce runtime'daki material_detector, water_detector alanlarÄ±ndaki on/off deÄŸerleri de gÃ¼ncelleyerek.
her ne zaman 1 nolu porttan mesaj Ã§Ä±kacaksa, tÄ±pkÄ± diÄŸer nodlarda olduÄŸu gibi aÅŸaÄŸÄ±daki Ã¶rnek yapÄ±daki bir mesaj da 2 nolu porttan Ã§Ä±kacak.
{
  method: "publish_on_change",
  params: {material_detector: "off"}
}

hazÄ±rsan analog_detector fonksiyon nodunun kodunu yaz lÃ¼tfen.



gelen analog deÄŸerlerine gÃ¶re ve 
tabi ileride eklenecek yeni hsyteresis detector'leri iÃ§in gereken esnek yapÄ±da olacak kodu.
hysteresis iÃ§in flow_context'in runtime alanÄ±ndaki material_detector ve water_detector alanlarÄ±na yeni key'ler eklemedim, gerekiyorsa hafÄ±za ihtiyacÄ±nÄ± node context ile karÅŸÄ±larsÄ±n diye dÃ¼ÅŸÃ¼ndÃ¼m, ne dersin?
bu detector'ler iÃ§in tÄ±pkÄ± digital_inputs_modbus'taki mantÄ±kla yalnÄ±zca deÄŸiÅŸim olduÄŸunda(tabi bu defa detector'leri biz Ã¼retiyoruz, parazit filtresi yok) mesaj Ã§Ä±kacak.
ve tÄ±pkÄ± digital_input_modbus'taki on/off'lar gibi aynÄ± mesaj yapÄ±sÄ±nda, fakat burada 2 nolu porttan Ã§Ä±kacaklar.
her ne zaman 2 no'lu porttan mesaj Ã§Ä±karsa, 3 nolu porttan da aÅŸaÄŸÄ±daki Ã¶rnek yapÄ±da mesaj Ã§Ä±kacak.
{
  method: "publish_on_change",
  params: {material_detector: "off"}
}

aÃ§Ä±klamamda eksik veya uyumsuz yerler varsa revize etmeye baÅŸlamadan beni uyar lÃ¼tfen.
hazÄ±r mÄ±sÄ±n analog_inputs
---------------
analog_detector''deki:
const detectorMap = {
  material_level: "material_detector",
  water_level: "water_detector"
};
energy_meter_detectordeki;
const detectorKey = "kwh_detector";
gereken mapleri karÅŸÄ±lÄ±k gelen, yani origin'i olan map'lerden alabilirsin.
channels: {
  material_level: {map: 0, factor: 0.01, tolerance: 0.1, material_detector: {off: 30, on: 60}},
  water_level: {map: 1, factor: 0.01, tolerance: 0.1, water_detector: {off: 30, on: 60}}
}
ve
channels: {
  kwh: {map: 0, factor: 0.01, tolerance: 0.1, kwh_detector: {off: 30, on: 60}}
}

uygun mudur? hazÄ±rsan Ã¶nce analog_detector'de gerekli dÃ¼zenlemeyi yap lÃ¼tfen.

mevcut actuators_modbus kodu eski bir flow_context'e gÃ¶re ve actuators adlÄ± bir Ã¼st katman grubuna gÃ¶re mesaj bekliyor ve iÅŸliyordu.
ÅŸimdi ise bu actuators katmanÄ± iptal edilmiÅŸ gibi dÃ¼ÅŸÃ¼nelim.

Ã¶ncelikle, loader konusunda bir karÄ±ÅŸÄ±klÄ±k vardÄ±, flow_context'te yeni bir dÃ¼zenleme yaptÄ±m, birazdan flow_context'in son halini(referansÄ±mÄ±z artÄ±k bu son halidir) gÃ¶ndereceÄŸim.
yalnÄ±zca loader sÃ¶zcÃ¼ÄŸÃ¼nÃ¼n geÃ§tiÄŸi yerlere bakman yeterli, diÄŸer her ÅŸey aynÄ±.
ve hemen ardÄ±ndan aÃ§Ä±klamam gelecek, sonra kodlamaya baÅŸlayabilirsin.
flow_context'i gÃ¶ndereceÄŸim hazÄ±r mÄ±sÄ±n?


aslÄ±nda genellemeler Ã¼zerinden anlatmak yerine doÄŸrudan gelebilecek mesaj Ã§eÅŸitlerini Ã¶rnekler halinde sana iletsem daha net ve isabetli olabilir.

1.
sinamics mesajlarÄ±:
{
  method: "forward_run", // forward_run | reverse_run | stop
  params: {
    target: "hatch" // esnek yapÄ±da olmalÄ±, tÃ¼m sinamics'ler iÃ§in yapÄ±lacak iÅŸ standart, yalnÄ±zca unitid'leir farklÄ±, sinamics adlarÄ± hard code olmamalÄ±dÄ±r. 
  }
}
{
  method: "change_speed",
  params: {
    target: "hatch", // esnek yapÄ±da olmalÄ±, tÃ¼m sinamics'ler iÃ§in yapÄ±lacak iÅŸ standart, yalnÄ±zca unitid'leri farklÄ±, sinamics adlarÄ± hard code olmamalÄ±dÄ±r. 
    speed: 16384 // set_point / 100 * speed_max
  }
}
2.
genel olarak relay mesajlarÄ±:
{
  method: "relay_on", // relay_on | relay_off
  params: {
    target: "light" // esnek yapÄ±da olmalÄ±, tÃ¼m relay'ler iÃ§in yapÄ±lacak iÅŸ standart, yalnÄ±zca unitid'leri(relay_outputs_*) farklÄ± ve bit map'lerine gÃ¶redir, relay adlarÄ±(light, buzzer vb.) hard code olmamalÄ±dÄ±r. 
  }
}
Ã¶zel olarak loader mesajlarÄ±:
{
  method: "forward_run", // forward_run | reverse_run | stop
  params: {
    target: "loader" 
  }
}
ve ÅŸimdi sana revize edilecek olan actuators_modbus fonksiyon noduna ait kodu tekrar gÃ¶ndereceÄŸim.  
loader methodlarÄ±nda (forward_run | reverse_run | stop) hangi relay'lerin etkileneceÄŸini de kodda gÃ¶rebilirsin.

hazÄ±rsan actuators_modbus'Ä± gÃ¶ndereyim.

-------------------------

ÅŸimdilik her node red restart'Ä±nda flow_context nodunu bir inject yardÄ±mÄ±yla elle tetikleyerek flow context'ini yÃ¼klÃ¼yorum. 

mqtt_manager nodu thingsboard iot platformu ile ve flow'un Ã§eÅŸitli nodlarÄ±yla haberleÅŸir.
thingsboard ile rpc ve telemetry prosedÃ¼rlerini iÅŸleterek haberleÅŸir.
node red'teki mqtt configuration (gizli nod) nodu thingsboard iÃ§in ayarlandÄ±.
mqtt_in nodu (mqtt in tipi nod) rpc prosedÃ¼rÃ¼ iÃ§in thingsboard'un v1/devices/me/rpc/request/+ topic'ine abone olarak ayarlandÄ±.
mqtt_out nodu (mqtt out tipi nod) thingsboard'un rpc ve telemetry prosedÃ¼rlerine uygunluk iÃ§in topic kÄ±smÄ± boÅŸ bÄ±rakÄ±lmÄ±ÅŸ olarak ayarlandÄ±, dinamik olarak deÄŸiÅŸtirilir.
rpc prosedÃ¼rÃ¼nde mqtt_in nodundan mqtt_manager'a v1/devices/me/rpc/request/$request_id topic'li gelen her mesajÄ±n karÅŸÄ±lÄ±ÄŸÄ±nda v1/devices/me/rpc/response/$request_id topic'ine mqtt_out nodu Ã¼zerinden mutlaka thingsboard'a response mesajÄ± gÃ¶nderilir, bÃ¶ylece prosedÃ¼r baÅŸarÄ±yla tamamlanmÄ±ÅŸ olur.
telemetry prosedÃ¼rÃ¼ tek yÃ¶nlÃ¼, mqtt_manager'dan thingsboard'a, v1/devices/me/telemetry topicine mqtt_out nodu Ã¼zerinden mesaj gÃ¶nderilir.  
mqtt_manager 2 Ã§Ä±kÄ±ÅŸ portlu bir fonksiyon nodudur, 1 nolu port mqtt_out noduna gider, 2 nolu port fsm noduna gider.
mqtt_in nodunun Ã§Ä±kÄ±ÅŸÄ±, mqtt_manager'Ä±n giriÅŸine baÄŸlÄ±dÄ±r.
gelen ve giden olan mesajlarda, ve zaten esas olarak tÃ¼m flow'da mesaj payload yapÄ±sÄ± ÅŸÃ¶yledir:
msg.payload={
  method: <string>,
  params: {<object iÃ§eriÄŸi>}
}
mesaj yapÄ±sÄ±, rpc prosedÃ¼rÃ¼, telemetry prosedÃ¼rÃ¼ aÃ§Ä±klanmÄ±ÅŸ olduÄŸuna gÃ¶re ÅŸimdi mqtt_manager'a gelen mesajlardaki method'lara gÃ¶re neler yapacaÄŸÄ±nÄ± aÃ§Ä±klamak istiyorum.
TELEMETRY PROSEDÃœRÃœ iÅŸletilecek olanlar.
method: "telemetry" olarak gelen mesajlar iÃ§in geÃ§erlidir.
1.
gelen mesaj;
msg.payload={
  method: "telemetry",
  params: {<boÅŸ>}
}
1 nolu porttan giden mesaj;
msg.payload={
  method: "telemetry",
  params: {<flow_context'in tÃ¼m runtime iÃ§eriÄŸi, "runtime" root adÄ± olmayacak>}
}
2.
gelen mesaj;
msg.payload={
  method: "telemetry",
  params: {<dolu>}
}
1 nolu porttan giden mesaj, gelen mesajÄ±n aynÄ±sÄ±dÄ±r.
RPC PROSEDÃœRÃœ iÅŸletilecek olanlar.
not: 2 nolu porttan giden mesajlarda topic olmayacak.
gelen mesajda method: "telemetry" deÄŸilse rpc prosedÃ¼rÃ¼ geÃ§erlidir.  
1.
gelen mesaj;
msg.payload={
  method: "rpc_set",
  params: {<flow context'te gÃ¼ncellenecek alan ve deÄŸeri>}
}
1 nolu porttan giden mesaj, gelen mesajÄ±n aynÄ±sÄ±dÄ±r, yani gÃ¼ncelleme yapÄ±ldÄ±.
2.
gelen mesaj;
msg.payload={
  method: "rpc_get",
  params: {<flow context'te sorgulanan alan, deÄŸeri null olarak belirtilmiÅŸ>}
}
1 nolu porttan giden mesaj;
msg.payload={
  method: "rpc_get",
  params: {<flow context'te sorgulanan alan ve deÄŸeri(null yerine)>}
}
3.
not: rpc prosedÃ¼rÃ¼nde, gelen diÄŸer tÃ¼m methodlar iÃ§in hem 1 nolu port'tan, hem de 2 nolu porttan gelen mesajÄ±n aynÄ±sÄ± gÃ¶nderilecek.
hatÄ±rlatma: rpc prosedÃ¼rÃ¼nde 2 nolu porttan giden mesajlarda topic olmayacak.
gelen rpc_set methodu flow_context'te bir gÃ¼ncelleme yapÄ±lmasÄ±nÄ± istiyor.
gelen rpc_get methodu ise bir sorgulama yapÄ±yor, null yazan yerleri deÄŸerleri flow_context'ten okunacak.
cevaplar daima gelen mesajla aynÄ± yapÄ±dadÄ±r. 
----------------------------

PATH KONUSU rpc prosedÃ¼rÃ¼ndeki rpc_set ve rpc_get methodlarÄ± iÃ§in:
gelen Ã¶rnek mesajlar;
msg.payload={
  method: "rpc_set",
  params: {kwh_detector: {off: 35}} // on: <deÄŸer> aynÄ± kalacak, yalnÄ±zca off: 35 olarak gÃ¼ncellenecek. 
}
msg.payload={
  method: "rpc_set",
  params: {kwh_detector: {off: 35, on: 65}}
}
msg.payload={
  method: "rpc_set",
  params: {light: {map: 1}}
}
msg.payload={
  method: "rpc_get",
  params: {kwh: {val: null}}
}
msg.payload={
  method: "rpc_get",
  params: {kwh_detector: {off: null}}
}
not: rpc_set ve rpc_get iÃ§in, gelen mesajdaki path flow context'te yoksa, "rpc_error" cevap mekanizmasÄ± uygulanacak.
rpc prosedÃ¼rÃ¼nde hangi method olursa olsun daima cevap gÃ¶nderilir. 
ÅŸimdilik logger gerekmez. 





flow context'in runtime alanÄ±ndaki tÃ¼m iÃ§eriÄŸi params'Ä±n iÃ§inde telemetry prosedÃ¼rÃ¼ ile gÃ¶nderecek, tabi root olarak runtime key'i olmayacak, iÃ§eriÄŸi gÃ¶nderilecek.
eÄŸer params boÅŸ bir object deÄŸil ise 
method: "telemetry" olacak.



ÅŸu prosedÃ¼rlerle haberleÅŸecek;
thingsboard rpc // dashboard'dan komut ve context ayar mesajlarÄ± gelecek.
telemetry prosedÃ¼rÃ¼ // on_change ve periodical olarak mesajlar gidecek.


set_context
get_context
publish_on_change
publish_period (telemetry)

------------------------
tekrardan merhaba, timer_manager fonksiyon nodu ile ilgili bir strateji deÄŸiÅŸikliÄŸi yapmak istiyorum.

fsm_day_counter: {
  type: "counter", direction: "down", interval: 1, base: 21, signal: 3, unit: "d",
  pass: {
    1: {method: "fsm_start", params: {}, port: 1},
    2: {method: "fsm_dry", params: {}, port: 1},
    3: {method: "fsm_end", params: {}, port: 1},
    4: {method: "telemetry", params: {fsm_day: {val: null}}, port: 3},
  }             
},

actuators_modbus nodunda iki geliÅŸtirme yapmak istiyorum.
ilki ÅŸÃ¶yle;
sanÄ±rÄ±m ÅŸu an kod gelen mesaja gÃ¶re target'Ä±n state'ini gÃ¼ncellemiyor, gÃ¶nderenin gÃ¼ncellemiÅŸ olduÄŸunu kabul ediyor, ÅŸu an mevcut kod Ã¶yle mi Ã§alÄ±ÅŸÄ±yor diye bakar mÄ±sÄ±n?
oysa ben taget'Ä±n runtime'daki tÃ¼m gÃ¼ncellemesini actuators_modbus'Ä±n yapmasÄ±nÄ± istiyorum, Ã§Ã¼nkÃ¼ gÃ¶nderici olan fsm nodu bunu yapmadam yalnÄ±zca mesajÄ±nÄ± gÃ¶nderiyor actuators_modbus'a.
ben yine Ã¶nce flow_context'i gÃ¶ndereyim mi sana sonra da actuators_modbus'Ä±?
-------------------
gelen komutlar aÅŸaÄŸÄ±dakilerle ilgili, fakat aslÄ±nda bu bilgiyi vermeme de gerek yok, gelen mesajda target runtime alanÄ± gÃ¼ncellenecek.
loader_forward_valve: {state: "off"},
loader_reverse_valve: {state: "off"},
loader_motor: {state: "off"},
light: {state: "off"},
buzzer: {state: "off"},  
hatch: {speed: {set_point: 100}, state: "off"},
fan: {speed: {set_point: 100}, state: "off"},
water_pump: {speed: {set_point: 100}, state: "off"},
discharger: {speed: {set_point: 100}, state: "off"},
loader: {state: "stop"},

{
  method: "stop",
  params: {target: "all"}
}
--------------------------------------
merhaba, raspberry pi'de node red ile bir flow oluÅŸturuyorum.
node-red-contrib-modbus paketi de yÃ¼klÃ¼.
flow biraz plc'ye benziyon olacak.

sana Ã¶ncelikle flow'u gÃ¶ndermek istiyorum.
10 adet fonksiyon nodu var, baÄŸlantÄ±larÄ± gÃ¶rmen iÃ§in, nod'larÄ±n js kodlarÄ±nÄ± boÅŸ bÄ±raktÄ±m ÅŸimdilik, ve hepsi disabled.
daha sonra flow_contex nodunu gÃ¶ndereceÄŸim ve sonraki adÄ±mda da aÃ§Ä±klamalara baÅŸlayacaÄŸÄ±m.
fonksiyon nodlarÄ±nÄ±n kodlarÄ± daha Ã¶nceki sohbetlerimizde yazÄ±ldÄ±, var, fakat ben sÃ¼rekli fikir deÄŸiÅŸtirdiÄŸimden ÅŸimdi hepsinin epey bir dÃ¼zenlenmesi gerekiyor.
hazÄ±r mÄ±sÄ±n flows.json dosyasÄ±nÄ± gÃ¶ndereyim mi?
--------------------------------
flow'da aÅŸaÄŸÄ±daki standart mesaj yapÄ±sÄ± var, ve topic kullanÄ±lmÄ±yor.
msg.payload={
  method: <string>,
  params: <json>
}
istisna durumlar ÅŸÃ¶yle;
modbus iÃ§in kullanÄ±lan flex getter'dan gelen ve flex writer'a gÃ¶nderilen mesajlar mecburen kendi payload formatÄ±nda.
ve ileride gÃ¶receÄŸimiz gibi thingsboard rpc ve telemetry prosedÃ¼rlerinde topic elbette kullanÄ±lÄ±yor olacak.
diÄŸer bir konu ise flow_context.
her node red restart'Ä±nda ÅŸimdilik bir inject yardÄ±mÄ±yla tetikleyip flow context'inin yÃ¼klenmesini saÄŸlÄ±yorum.
flow'un elektrik kesintisinden mÃ¼mkÃ¼n olduÄŸunda az etkilenip Ã¶nceki durumuna yakÄ±n bir yerden devam etmesini istiyorum elektrik geldiÄŸinde, tÄ±pkÄ± bir plc gibi.
o nedenle settings.js'de aÅŸaÄŸÄ±daki ayarÄ± yapacaÄŸÄ±m daha sonra;
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
bÃ¶ylece en son kesinti Ã¶ncesindeki en yakÄ±n deÄŸerler ile devam etmesi iÃ§in.
bununla birlikte timerlarÄ± da kalÄ±cÄ± olarak tasarlÄ±yoruz, node red'in timer Ã¶zelliÄŸi olan delay, inject vb. kendi nodlarÄ±nÄ± kullanmÄ±yoruz, uzun sÃ¼reli iÅŸler iÃ§in.
ÅŸimdi flow'daki fonksiyon nodlarÄ±nÄ±n bir listesini yap ve sonra ben mqtt_manager kodunu gÃ¶ndereceÄŸim ve nasÄ±l revize etmeni istediÄŸimin aÃ§Ä±klamasÄ±nÄ± gÃ¶ndereceÄŸim ardÄ±ndan.
genel olarak bÃ¶yle ilerleriz adÄ±m adÄ±m.
---------------------
doÄŸru liste bu:
flow_contex
digital_inputs
analog_inputs
analog_detector
energy_meter
energy_meter_detector
actuators_modbus
timer_manager
mqtt_manager
fsm
-------------------
mqtt_manager'Ä± 3 Ã§Ä±kÄ±ÅŸ portlu istiyorum.
gelen mesajlara gÃ¶re neler yapÄ±lacaÄŸÄ±na aÅŸaÄŸÄ±da bakalÄ±m:
TELEMETRY PROSEDÃœRÃœ
method: "telemetry" ile gelen mesajlar iÃ§in kod aynÄ± kalacak.
RPC PROSEDÃœRÃœ
gelen method: "telemetry" deÄŸil ise rpc prosedÃ¼rÃ¼ iÅŸletilecek.
dolayÄ±sÄ±yla aÅŸaÄŸÄ±dakiler yalnÄ±zca rpc prosedÃ¼rÃ¼ ile ilgilidir.
rpc prosedÃ¼rÃ¼nde requestId ve topic tekniÄŸiyle cevap mutlaka gÃ¶nderilir, her gelen mesaj iÃ§in.
cevap daima gelen mesajÄ±n aynÄ±dÄ±r, bir tek istisna dÄ±ÅŸÄ±nda, "get" methodunda null olan deÄŸereler flow'dan okunan deÄŸerler ile deÄŸiÅŸtirilip cevap Ã¶yle gÃ¶nderiliyor.  
mevcut kod zaten bunlarÄ± yapabiliyor gÃ¶rdÃ¼ÄŸÃ¼m kadarÄ±yla, bunlar 1 nolu Ã§Ä±kÄ±ÅŸ portu ile ilgili, mqtt_out noduna baÄŸlantÄ±lÄ±.
gelen rpc mesajlarÄ±nda bundan bÃ¶yle params alanÄ± iÃ§inde type alanÄ± da olacak, "context", "fsm", "manual" deÄŸerlerinde.
"set" ve "get" method'larÄ± type: "context" ile birlikte gelir ve ilgili cevaplar 1 nolu porttan Ã§Ä±kar.
diÄŸer tÃ¼m methodlar iÃ§in type "fsm" veya "manual" olarak gelecek.
"fsm" ile gelenler hiÃ§ deÄŸiÅŸikliÄŸe uÄŸramadan 2 nolu porttan Ã§Ä±kacak, tabi ki topic iptal edilerek.
"manual" ile gelenler hiÃ§ deÄŸiÅŸikliÄŸe uÄŸramadan 3 nolu porttan Ã§Ä±kacak, tabi ki topic iptal edilerek.
tekrar hatÄ±rlatma: tÃ¼m rpc prosedÃ¼rlerinde 1 nolu porttan cevap mutlaka Ã§Ä±kar, ki prosedÃ¼r thingsboard tarafÄ±nda onaylansÄ±n ve baÅŸarÄ±lÄ± kabul edilsin.
-------------
flow'da genel kural olarak; bir nod, flow_context'te gÃ¼ncelleme yaptÄ±ysa mutlaka bir telemetry mesajÄ± da Ã§Ä±karmalÄ±, bu mesaj mqtt_manager'a gider. actuators_modbus halen 2 port Ã§Ä±kÄ±ÅŸlÄ±. onu 3 port Ã§Ä±kÄ±ÅŸlÄ± yapalÄ±m ve flow_context'in runtime alanÄ±nÄ± her gÃ¼ncellediÄŸinde, yani aslÄ±nda mesaj geldiyse, mesaj Ã§Ä±karacaksa 1 ve 2 nolu portlardan, yani bu nod Ã§alÄ±ÅŸtÄ±ysa bir gÃ¼ncelleme de mutlaka olacaktÄ±r, Ã¶yleyse 3 nolu porttan ve yine flow'un standart mesaj yapÄ±sÄ±na uygun, gÃ¼ncellediÄŸi alanÄ± belirten mesaj Ã§Ä±karsÄ±n. sanÄ±rÄ±m timer_manager benzerini yapÄ±yordu. 
-------------------
analog_detector ve energy_meter_detector isimlerindeki fonksiyon nodlarÄ±nÄ±n digital_inputs iÃ§indeki oygen_detector ve humidity_detector alanlarÄ±yla hiÃ§bir ilgisi yok.
dinamik bulucuya ihtiyaÃ§ var mÄ±?
Ã¶rneÄŸin analog_detector nodu gelen aÅŸaÄŸÄ±daki Ã¶rnek mesaj iÃ§in:
msg.payload={
  method: "water_level",
  params: {val: <number>}
}
ÅŸu mesajÄ± Ã§Ä±karacak, tabi ki eÄŸer hysteresis olarak bir deÄŸiÅŸim varsa:
1 nolu porttan;
msg.payload={
  method: "water_detector",
  params: {state: on | off}
}
2 nolu porttan;
msg.payload={
  method: "telemetry",
  params: {water_detector: {state: on | off}}
}
ve runtime'de key bulmak iÃ§in config'den faydalanabilir.
yani zaten aÅŸaÄŸÄ±daki kÄ±sÄ±mda gÃ¶rÃ¼lebileceÄŸi gibi water_level ile water_detector aynÄ± object'in iÃ§indeler ve aynÄ± map: 0 olarak.
yani water_level'a karÅŸÄ±lÄ±k runtime'da water_detector verisi gÃ¼ncellenir.
material_level'a karÅŸÄ±lÄ±k runtime'da material_detector verisi gÃ¼ncellenir.
aynÄ± teknik energ_meter_detector nodu iÃ§in de geÃ§erlidir.
kwh'a karÅŸÄ±lÄ±k kwh_detector.
tabi burada yazdÄ±klarÄ±mÄ±z hysteresis eÅŸik seviyelerine gÃ¶re hesaplanÄ±r. 
------------------------



daha fazla genel aÃ§Ä±klama yapmam uzun sÃ¼rer, onun yerine her adÄ±mda bir fonksiyon kodu ve ardÄ±ndan gelen-giden mesaj Ã¶rnekleri, bazÄ± deÄŸiÅŸiklikler, yeni flow_context'e uygunluk Ã¼zerinden revizyonu yapabilmen iÃ§in bilgi vereceÄŸim.
hazÄ±rsan ilk fonksiyon nodu olarak flow_contex'i gÃ¶ndereyim.
-------------------
sÄ±ra actutors fonksiyon nodunda.
3 Ã§Ä±kÄ±ÅŸ portlu olarak kalacak.
1 ve 2 nolu Ã§Ä±kÄ±ÅŸlarÄ±n mesaj yapÄ±sÄ± aynen kalacak, Ã§Ã¼nkÃ¼ modbus flex writer nodlarÄ± bu yapÄ±da mesaj bekliyor actuators'dan.
3 nolunun mesajlarÄ±nÄ± yeni mesaj yapÄ±sÄ±yla Ã§Ä±karÄ±yoruz, method: "evt" olarak Ã§Ä±kacak.
Ã¶rnek olarak mesajlar ÅŸÃ¶yle gelecek:
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "hatch"} // bu bir sinamics mesajÄ±
}
msg.payload={
  method: "cmd",
  params: {type: "forard_on", target: "loader"} // bu bir loader mesajÄ±, 3 relay'i iÃ§eriyor.
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir relay mesajÄ±
}
not: "relay_on", "relay_off" olarak gelmesini beklemesin, daha generic biÃ§imde "on", "off" olarak gelecek, target'a bakÄ±ldÄ±ÄŸÄ±nda relay olup olmadÄ±ÄŸÄ± anlaÅŸÄ±lsÄ±n.
sanÄ±rÄ±m bu nod yeni flow_contex'e uyum ve mesaj yapÄ±sÄ± bakÄ±mÄ±ndan epey deÄŸiÅŸiklik istiyor.
hazÄ±r mÄ±sÄ±n gÃ¶ndereyim mi?
------------------
sÄ±rada timer_manager fonksiyon nodu var.
aynÄ± revizyon yÃ¶ntemleri uygulanacak, flow_contex ve gelen-giden mesajlar iÃ§in yeni mesaj yapÄ±sÄ±yla %100 uyumlu olmalÄ±.
3 portlu olarak kalacak.
ÅŸÃ¶yle bir kod kÄ±smÄ± var:
// Ana mesaj iÅŸleme
if (method === "timer_on") {
  timerOn(timers[target], runtime[target], Date.now(), out, target);

} else if (method === "timer_off") {
  if (target === "all") {
    for (const [key, timer] of Object.entries(timers)) {
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    timerOff(timers[target], runtime[target], out, target);
  }
} else if (method === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}
ve yine bunda da "timer_on", "timer_off" yerine "on", "off" gelecek, target target'ta bir timer adÄ± olup olmadÄ±ÄŸÄ±na gÃ¶re ayrÄ±m yapÄ±lacak.
msg.payload={
  method: "cmd",
  params: {type: "on", target: "water_pump_pwm"} // bu bir timer mesajÄ±
}
ve tabi target'ta bir timer adÄ± yoksa gelen mesaj 2 nolu porttan (out[1]) aynen gÃ¶nderilecek.
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir timer mesajÄ± deÄŸil, 2 nolu porttan aynen Ã§Ä±kacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu da bir timer mesajÄ± deÄŸil, 2 nolu porttan aynen Ã§Ä±kacak.
}
hazÄ±r mÄ±sÄ±n timer_managerÄ± gÃ¶ndereyim mi?
-----------------------------------
sÄ±rada mqtt_manager fonksiyon nodu var.
yine aynÄ± revizyon Ã§erÃ§evesinde.
3 portlu olarak kalacak.
gelen mesajlarÄ± farklÄ± iÅŸlevler iÃ§in aÅŸaÄŸÄ±dakiler gibi beklesin:
TELEMETRY PROSEDÃœRÃœ method: "evt":
msg.payload={
  method: "evt",
  params: {type: <string>, val: <misc>} // telemetry prosedÃ¼rÃ¼ ile gÃ¶ndermek iÃ§in
}
msg.payload={
  method: "evt",
  params: {type: <telemetry_periodical>, val: null} // tÃ¼m runtime'Ä± telemetry prosedÃ¼rÃ¼ ile gÃ¶ndermek iÃ§in
}
RPC PROSEDÃœRÃœ method: "cmd":
msg.payload={
  method: "cmd",
  params: {type: "set", target: {aynÄ± path,value sistemi}} // set iÃ§in
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {aynÄ± path,null sistemi}} // get iÃ§in
}
msg.payload={
  method: "cmd",
  params: {type: <string>, target: "fsm"} // fsm iÃ§in
}
eski "manual" iÃ§in ise aÅŸaÄŸÄ±daki gibidir.
eÄŸer method: "cmd" iken type: "set" veya type: "get" deÄŸilse o zaman bir de target'a baksÄ±n target: "fsm" deÄŸilse gelen mesajÄ± 3 nolu port'tan Ã§Ä±karsÄ±n.

hazÄ±r mÄ±sÄ±n gÃ¶ndereyim mi?





-----------------
merhaba, raspberry pi ve node red ile plc gibi Ã§alÄ±ÅŸan bir flow oluÅŸturmaya devam ediyorum.

senden istediÄŸim her defasÄ±nda aynÄ± gÃ¶nderecek olduÄŸum fonksiyon nodunun flow_context ile tam uyumlu olup olmadÄ±ÄŸÄ±nÄ± denetlemen.
not: node-red-contrib-modbus paketi de yÃ¼klÃ¼. hazÄ±r mÄ±sÄ±n?
---------------------------------------------
merhaba,
raspberry pi ve node red ile plc gibi Ã§alÄ±ÅŸan bir flow oluÅŸturmaya devam ediyorum.
node-red-contrib-modbus paketi de yÃ¼klÃ¼.
yeni flow context ve mesaj yapÄ±sÄ± iÃ§in mevcut 10 adet fonksiyon nodlarÄ±nÄ±n kodlarÄ±nÄ± revize etmiÅŸtin.
henÃ¼z test etmedim.
flow_contex
digital_inputs
analog_inputs
analog_pro
energy_meter
energy_meter_pro
actuators
timer_manager
mqtt_manager
fsm
flow genelinde mesajlarda topic yok, istisna olarak mqtt_in ve mqtt_out nodlarÄ±yla Ã§alÄ±ÅŸÄ±rken thingsboard rpc ve telemetry prosedÃ¼rleri iÃ§in topic kullanÄ±lÄ±yor.
flow genelinde yeni mesaj yapÄ±sÄ± ÅŸÃ¶yle;
msg.payload={
  method: <string>, // evt | cmd
  params: <json>, // evt iÃ§in {type: <string>, val: <misc>} | cmd iÃ§in {type: <string>, target: <misc>}
}
istisna olarak modbus flex getter nodlarÄ±ndan Ã§Ä±kan ve modbus flex writer nodlarÄ±na gide mesajlar mecburen kendine Ã¶zgÃ¼ payload formatÄ±ndalar.
yeni mesaj yapÄ±sÄ± (method: <string>, params: <json>) aynÄ± zamanda thingsboard rpc prosedÃ¼rÃ¼ mesaj payload yapÄ±sÄ±yla da aynÄ±.
flow context'ini ÅŸimdilik her node red restart'Ä±ndan sonra bir inject nodu yardÄ±mÄ±yla elle tetikleyerek flow_context nodu ile yÃ¼klemiÅŸ oluyorum.
ileride settings.js'de aÅŸaÄŸÄ±daki ayarÄ± yapÄ±p diskte kalÄ±cÄ± dosya halinde arka planda periyodik olarak kaydediliyor olmasÄ±nÄ± saÄŸlayacaÄŸÄ±m.
sonra da flow_context nodunu flow'dan kaldÄ±racaÄŸÄ±m.
flow bir plc'ye benziyor demiÅŸtim, elektrik kesintisinden sonr tekrar Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda kesintiden Ã¶nceki diske kaydedilmiÅŸ en son runtime deÄŸerleri ile kaldÄ±ÄŸÄ± yerden devam edebilmesini hedefliyoruz.
o yÃ¼zden timer'larÄ± bile date.now gibi bir teknikle kalÄ±cÄ± olarak tasarlÄ±yoruz, node red'in kendi inject, delay vb. nodlarÄ± kalÄ±cÄ± deÄŸiller, uzun zamanlamalar iÃ§in kullanamazdÄ±k, kesintiden sonra resetleniyorlar.

ÅŸimdi senden istediÄŸim; revize edilmiÅŸ bu fonksiyon kodlarÄ±nÄ±n flow_context ve yeni mesaj yapÄ±sÄ± ile tam uyumluluÄŸunu son defa kontrol etmen, eksik/fazla/hatalÄ± kodlar var mÄ± diye bakman.
kodlar ileride flow_context'te yapÄ±lacak deÄŸiÅŸiklikler iÃ§in yeterince esnek mi.
Ã¶nce flow_context kodunu referansÄ±mÄ±z olarak gÃ¶nderip daha sonra her adÄ±mda bir tane olmak Ã¼zere 9 fonksiyon kodu gÃ¶ndermek istiyorum.
fakat daha Ã¶nceki sohbetlerimizde ÅŸunu gÃ¶rdÃ¼m, birkaÃ§ adÄ±m sonra flow_context'i unutmuÅŸ olabiliyorsun.
yoksa her kodla birlikte flow_context'i de yanÄ±nda mÄ± gÃ¶ndersem, ne dersin?
notlar;
kodlarÄ± file upload olarak deÄŸil, iÃ§eriklerini sohbette gÃ¶ndereceÄŸim.
modbus flex getter tipi nodlar her 100ms'de bir mesaj gÃ¶nderir.
timer_tick her 1 saniyede gelir.

benim de kontrol edebilmem iÃ§in her kodun beklediÄŸi mesajlarÄ± ve bu mesajlara karÅŸÄ±lÄ±k yaptÄ±ÄŸÄ± iÅŸleri ve Ã§Ä±kardÄ±ÄŸÄ± port mesajlarÄ±nÄ± kÄ±saca listelemeni istiyorum, her adÄ±mda.
-----------------------------
tahmin ettiÄŸim gibi actuators belki de revize edilmemiÅŸ !!

3 Ã§Ä±kÄ±ÅŸ portlu olarak kalacak.
1 ve 2 nolu Ã§Ä±kÄ±ÅŸlarÄ±n mesaj yapÄ±sÄ± aynen kalacak, Ã§Ã¼nkÃ¼ modbus flex writer nodlarÄ± bu yapÄ±da mesaj bekliyor actuators'dan.
3 nolunun mesajlarÄ±nÄ± yeni mesaj yapÄ±sÄ±yla Ã§Ä±karÄ±yoruz, method: "evt" olarak Ã§Ä±kacak.
Ã¶rnek olarak mesajlar ÅŸÃ¶yle gelecek:
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "hatch"} // bu bir sinamics mesajÄ±
}
msg.payload={
  method: "cmd",
  params: {type: "speed", set_point: 50, target: "hatch"} // bu bir sinamics mesajÄ±, sadece speed'e Ã¶zel olarak set_point adÄ±nda bir key daha eklemiÅŸ olduk.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu bir loader mesajÄ±, 3 relay'i iÃ§eriyor.
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir relay mesajÄ±
}
istersen actuators ve referansÄ±mÄ±z olan flow_context'i tekrardan ve birlikte olarak gÃ¶ndereyim mi?
---------------------------------
sÄ±rada timer_manager fonksiyon nodu var.
aynÄ± revizyon yÃ¶ntemleri uygulanacak, flow_contex ve gelen-giden mesajlar iÃ§in yeni mesaj yapÄ±sÄ±yla %100 uyumlu olmalÄ±.
3 portlu olarak kalacak.
ÅŸÃ¶yle bir kod kÄ±smÄ± var:
// Ana mesaj iÅŸleme
if (method === "timer_on") {
  timerOn(timers[target], runtime[target], Date.now(), out, target);

} else if (method === "timer_off") {
  if (target === "all") {
    for (const [key, timer] of Object.entries(timers)) {
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    timerOff(timers[target], runtime[target], out, target);
  }
} else if (method === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}
ve yine bunda da "timer_on", "timer_off" yerine "on", "off" gelecek, target target'ta bir timer adÄ± olup olmadÄ±ÄŸÄ±na gÃ¶re ayrÄ±m yapÄ±lacak.
-------------------------------------------------------------
merhaba, raspberry pi'de node red ile plc gibi Ã§alÄ±ÅŸan bir flow oluÅŸturduk daha Ã¶nceki sohbetlerimizde.
ÅŸimdi timer_manager ve mqtt_manager adlÄ± fonksiyon nodlarÄ±nÄ±n kodlarÄ±nÄ± son bir defa daha kontrol etmeni istiyorum, henzÃ¼ test etmedim.
flow genelinde esas referansÄ±mÄ±z flow_context nodudur ve hazÄ±r haldedir.
flow'un context'ini ÅŸimdilik her node red restart'Ä±ndan sonra bir inject nodu yardÄ±mÄ±yla elle tetikleyerek flow_context nodu ile yÃ¼klemiÅŸ oluyorum.
ileride settings.js'de aÅŸaÄŸÄ±daki ayarÄ± yapÄ±p diskte kalÄ±cÄ± dosya halinde arka planda periyodik olarak kaydediliyor olmasÄ±nÄ± saÄŸlayacaÄŸÄ±m.
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
sonra da flow_context nodunu flow'dan kaldÄ±racaÄŸÄ±m.
flow bir plc'ye benziyor demiÅŸtim, elektrik kesintisinden sonr tekrar Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda kesintiden Ã¶nceki diske kaydedilmiÅŸ en son runtime deÄŸerleri ile kaldÄ±ÄŸÄ± yerden devam edebilmesini hedefliyoruz.
o yÃ¼zden timer'larÄ± bile date.now gibi bir teknikle kalÄ±cÄ± olarak tasarlÄ±yoruz, node red'in kendi inject, delay vb. nodlarÄ± kalÄ±cÄ± deÄŸiller, uzun zamanlamalar iÃ§in kullanamazdÄ±k, kesintiden sonra resetleniyorlar.
flow genelinde mesajlarda topic yok, mqtt_manager adlÄ± nod iÃ§in istisna olarak mqtt_in ve mqtt_out nodlarÄ±yla Ã§alÄ±ÅŸÄ±rken thingsboard rpc ve telemetry prosedÃ¼rleri iÃ§in topic kullanÄ±lÄ±yor.
flow genelinde mesaj yapÄ±sÄ± ÅŸÃ¶yle;
msg.payload={
  method: <string>, // evt | cmd
  params: <json>, // evt iÃ§in {type: <string>, val: <misc>} | cmd iÃ§in {type: <string>, target: <misc>}
}
Ã¶ncelikle esas referansÄ±mÄ±z olan flow_context nodunun kodunu gÃ¶ndereceÄŸim, gereken alanlarÄ± analiz edersin.
daha sonra timer_manager'Ä± kontrol etmen iÃ§in Ã¶nce aÃ§Ä±klamasÄ±nÄ± ve ardÄ±ndan mevcut kodunu gÃ¶ndereceÄŸim.
daha sonra da mqtt_manager'Ä± kontrol etmen iÃ§in Ã¶nce aÃ§Ä±klamasÄ±nÄ± ve ardÄ±ndan mevcut kodunu gÃ¶ndereceÄŸim.
aÃ§Ä±klamalarÄ±mda Ã¶rnek mesajlar gÃ¶stereceÄŸim.
kodlarÄ± flow_context ve mesaj yapÄ±sÄ± ve varsa dÃ¼zeltilmesi gereken yerler bakÄ±mÄ±ndan kontrol edersin ve gerekirse kodlarÄ± revize edersin.
hazÄ±rsan flow_context ile baÅŸlayalÄ±m..


daha sonra da adÄ±m adÄ±m flow_contex ve mesaj yapÄ±sÄ± ile uyumlarÄ±nÄ± ve varsa dÃ¼zeltilmesi gereken kÄ±sÄ±mlarÄ±.

ardÄ±ndan timer_manager kodunu gÃ¶ndereceÄŸim bir gÃ¶z atarsÄ±n.
sonra da timer_manager iÃ§in nasÄ±l kontrol etmeni istediÄŸimi aÃ§Ä±klayacaÄŸÄ±m, varsa gereken dÃ¼zeltmeleri yapman iÃ§in.




-------------------------
method: "evt":
--------------
params: {type: "oxygen_detector", val: "off"}
params: {type: "oxygen_detector", val: "on"}
params: {type: "humidity_detector", val: "off"}
params: {type: "humidity_detector", val: "on"}
----------------------
energy_meter_pro'yu test ediyorum baÄŸÄ±msÄ±z olarak.
giriÅŸine 3 inject baÄŸladÄ±m, hysteresis yapacak mÄ± diyerek.
inject_80:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 80}
}
inject_50:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 50}
}
inject_20:
msg.payload={
  method: "evt",
  params: {type: "kwh", val: 20}
}
farklÄ± sÄ±ralarla hysteresis'i tetiklemeye Ã§alÄ±ÅŸÄ±yorum fakat energy_meter_pro'nun Ã§Ä±kÄ±ÅŸÄ±nda mesaj gÃ¶rmÃ¼yorum.
flow_context'te kwh_detector deÄŸerini Ã¼retmek iÃ§in gereken hysteresis eÅŸiklerinin 30 ve 60 olduÄŸunu gÃ¶rebilirsin.
kwh: {map: 0, factor: 0.01, pro: {kwh_detector: {off: 30, on: 60}}}
fakat Ã§alÄ±ÅŸmÄ±yor.

benzer yapÄ±daki analog_pro gayet gÃ¼zel Ã§alÄ±ÅŸÄ±yor, prensibe oradan bakabilirsin.

energy_meter_pro:





analog_pro:
{"method": "evt", "params": {"type": "kwh", "val": 80}}

{"method": "cmd", "params": {"type": "forward_on", "target": "hatch"}}
80 0 96
-----------------------------
actuators fonksiyon nodunu test ediyorum, genel olarak Ã§ok gÃ¼zel Ã§alÄ±ÅŸÄ±yor, mantÄ±k ve Ã§Ä±kÄ±ÅŸ portlarÄ±na yÃ¶nlendirmeler tamamdÄ±r.
fakat ÅŸu 2 detayÄ± da Ã§Ã¶zersek daha iyi olur.
1. detay:
ÅŸu 3 kÄ±sÄ±mÄ± dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zde; sinamics, relay_outputs_1, relay_outputs_2.
hangisinde deÄŸiÅŸim varsa yalnÄ±zca onun iÃ§in mesaj Ã§Ä±ksÄ±n, deÄŸiÅŸmeyeni tekrar gÃ¶ndermeye gerek yok.
2. detay:
3 nolu Ã§Ä±kÄ±ÅŸ porttundan Ã§Ä±kan mesajlar konusunda, sinamics'te 3 nolu Ã§Ä±kÄ±ÅŸ portundan Ã§Ä±kan mesajlarda original mesaj type korunmalÄ±, mevcut kodda Ã¶rneÄŸin forward_X korunmuyor ve X olarak Ã§Ä±kÄ±yor.
loader'da bu sorun yok, forward_X olarak Ã§Ä±kÄ±yor. (X ifadesi on|off anlamÄ±nda). light, buzzer tabi tam anlaÅŸÄ±lmÄ±yor, zaten sadecec on|off olduklarÄ±ndan, sanÄ±rÄ±m sorun yoktur. 
----------------------
evet gÃ¶nderdiÄŸin kod tam olarak talep etmiÅŸ olduÄŸum gibi Ã§alÄ±ÅŸtÄ±, tamamen runtime Ã¼zerinden durum deÄŸiÅŸikliÄŸine bakÄ±yor, deÄŸiÅŸmeyen hiÃ§bir ÅŸeyi Ã§Ä±karmÄ±yor.
fakat ÅŸimdi test ederken ÅŸunu anladÄ±m ki, tasarÄ±m olarak bÃ¶yle yapmasa daha iyi olacak, Ã§Ã¼nkÃ¼ biraz riskli, runtime ile modbus ve mqtt arasÄ±nda, yani dÄ±ÅŸ dÃ¼nyadaki gerÃ§ek durumlar bakÄ±mÄ±ndan tutarsÄ±zlÄ±klar oluÅŸabilir.
Ã¶zellikle sinamics'lerde runtime'daki mevcut durumuna (val) hiÃ§ bakÄ±lmaksÄ±zÄ±n gelen komutu yerine getirsin, mesajÄ±nÄ± Ã¼retsin.
yani kod eski hali gib Ã§alÄ±ÅŸsÄ±n, ve sadece sinamics'ler ile relay_outputs_x'in birbirinden izole edilmesi saÄŸlansÄ±n yeterlidir.
loader, light, buzzer gibileri iÃ§in yine hem relay_outputs_1'i hem de relay_outputs_2'yi gÃ¶ndersin, zararÄ± yok, rÃ¶leler tazelenmiÅŸ olur. runtime ile modbus cihazlarÄ±ndaki gerÃ§ek durum hep tutarlÄ± kalsÄ±n.
yani Ã¶zetle; her ÅŸey iÃ§in komut ezici Ã¼stÃ¼nlÃ¼ÄŸe sahiptir, runtime'daki mevcut duruma bakmaz, mutlaka mesajlarÄ± gÃ¶nderir.
runtime'a hiÃ§ bakÄ±lmadan aynÄ± komut tekrar tekrar bile Ã§alÄ±ÅŸabilsin, tabi ki runtime'Ä± da arka planda gÃ¼nceller daima.
ve tabi ki relay_outputs_x iÃ§in Ã¶nceki bitleri koruyan node contex sistemi aynen devam edecek.
not: sinamics 3 nolu Ã§Ä±kÄ±ÅŸ portu original type korunamÄ±yordu, bu sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ tamamdÄ±r.

ÅŸimdi actuators'u bu tasarÄ±ma gÃ¶re revize et lÃ¼tfen, sanÄ±rÄ±m kÃ¼Ã§Ã¼k bir deÄŸiÅŸiklik istiyor hepsi o kadar.
------------------------
tam Ã§Ã¶zÃ¼me Ã§ok yakÄ±nÄ±z.
ÅŸimdi actuators'un en beÄŸendiÄŸim sÃ¼rÃ¼mÃ¼nÃ¼ sana gÃ¶nderiyorum ve sadece aÅŸaÄŸÄ±daki deÄŸiÅŸiklikleri uygula lÃ¼tfen.
1) sinamics'lerin relay_outputs_X'lerle hiÃ§ ilgisi olmadÄ±ÄŸÄ±ndan, dolayÄ±sÄ±yla sinamics komutlarÄ± geldiÄŸinde relay_output_X'ler iÃ§in iÅŸlem yapÄ±lmasÄ±n ve onlar iÃ§in mesaj da Ã§Ä±kmasÄ±n, zaten iÅŸlem yapÄ±lmÄ±yor.
2) sinamics'lerin 3 nolu Ã§Ä±kÄ±ÅŸ porttundan gÃ¶nderilecek mesajlarÄ±nda original type korunsun, Ã¶rneÄŸin "forward_on" gibi("on" Ã§Ä±kmasÄ± yanlÄ±ÅŸ), bunu yeni sÃ¼rÃ¼mlerde Ã§Ã¶zdÃ¼ÄŸÃ¼n gibi Ã§Ã¶z yine.

actuators:
-----------------------------------------------
timer_mnager iÃ§in aÃ§Ä±klama ve gelen mesajlardan bazÄ± Ã¶rnekler:
msg.payload={
  method: "evt",
  params: {type: "timer_tick", val: null} // bu bir timer_tick mesajÄ±
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "water_pump_pwm"} // bu bir timer mesajÄ±
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "day_counter"} // bu bir timer mesajÄ±
}
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light"} // bu bir timer mesajÄ± deÄŸil, 2 nolu porttan aynen Ã§Ä±kacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "loader"} // bu da bir timer mesajÄ± deÄŸil, 2 nolu porttan aynen Ã§Ä±kacak.
}
msg.payload={
  method: "cmd",
  params: {type: "forward_on", target: "water_pump"} // bu da bir timer mesajÄ± deÄŸil, 2 nolu porttan aynen Ã§Ä±kacak.
}
Ã¶zetle;
method: "evt" olarak sadece type: "timer_tick", val: null olarak mesaj gelir, timer'larÄ± yÃ¼rÃ¼tmek iÃ§in her saniyede bir gelir, bu mesajÄ±n kendi doÄŸrudan mesaj Ã¼retmez, gÃ¶ndermez.
diÄŸer tÃ¼m mesajlar method: "cmd" ile gelir, yani aÅŸaÄŸÄ±daki aÃ§Ä±klamalarÄ±n hepsi method: "cmd" ile gelen mesajlar iÃ§indir.
gelen mesajda Ã¶nce target'a bakÄ±lÄ±r eÄŸer bir timer (timer adÄ±) deÄŸilse, gelen mesaj hiÃ§bir iÅŸleme uÄŸramadan port 2'den aynen gÃ¶nderilir.
eÄŸer target bir timer ise o timer iÃ§in iÅŸlem yapÄ±lacak demektir.
her timer'Ä±n kendi pass alanÄ±nda mesajlar bulunur, mesajlarÄ±n Ã§Ä±kacaÄŸÄ± port nolarÄ± metadata olarak port: X biÃ§imindedir. 
tabi ki pass alanÄ±ndaki mesajlar gÃ¶nderilirken port: X metadata yok edilerek gÃ¶nderilir.
her timer formu iÃ§in pass alanÄ±ndaki mesajlarÄ± gÃ¶ndermenin ayrÄ± kurallarÄ± vardÄ±r.
gerekirse bu kurallarÄ± da tek tek aÃ§Ä±k olarak sana yazarÄ±m fakat ben kodda gereken kurallarÄ±n zaten bulunduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum.

teste geÃ§erken fan_pwm ve light_pulse iÃ§in config'de sÃ¼releri kÃ¼Ã§Ã¼lttÃ¼m ki Ã§abuk gÃ¶rebileyim diye.
timer_tick de aktif ve saniyede bir mesaj gÃ¶nderiyor timer_manager'a.
inject'lerle yaptÄ±ÄŸÄ±m ilk test baÅŸarÄ±sÄ±z, port1,2,3 Ã§Ä±kÄ±ÅŸlarÄ±na baÄŸlÄ± debug'larda mesaj yok.
Ã¶rneÄŸin en basitinden gidelim:
msg.payload={
  method: "cmd",
  params: {type: "on", target: "light_pulse"}
}
geldiÄŸi gibi hemen ÅŸuradaki(config>timers>light_pulse) pass.1 mesajÄ± Ã§Ä±kmalÄ±ydÄ± 2 nolu porttan, fakat yok.
2 saniye sonra da pass.2 mesajÄ± Ã§Ä±kmalÄ±ydÄ± 2 nolu porttan, fakat yok. 
light_pulse: {
  type: "delay", duration: 2, unit: "s",
  pass: {
    1: {method: "cmd", params: {type: "on", target: "light"}, port: 2},
    2: {method: "cmd", params: {type: "off", target: "light"}, port: 2}
  }
}
target'ta timer adÄ± olmayan mesajlarÄ± doÄŸru biÃ§imde 2 nolu porttan Ã§Ä±karÄ±yor, bunda sorun yok.
henÃ¼z daha karmaÅŸÄ±k olan day_counter adlÄ± timer'Ä± test etmedim.

sorunlarÄ± giderebilir misin?
istersen pass mesaj mantÄ±ÄŸÄ±nÄ± tam olarak yazayÄ±m fakat kodda mevcut diye dÃ¼ÅŸÃ¼nÃ¼yorum.
sen kodda gÃ¶rdÃ¼ÄŸÃ¼n pass mesaj mantÄ±ÄŸÄ±nÄ± aÃ§Ä±kla lÃ¼tfen.
-------------------
sanÄ±rÄ±m ÅŸimdi sÄ±rada mqtt_manager var.
yine flow_context ile birlikte gÃ¶ndereyim ve bir gÃ¶z at istersen.
daha sonra testlere baÅŸlarÄ±m.

mqtt_manager:
{"method": "cmd", "params": {"type": "set", "target": {"light_pulse": {"duration": 6}}}}
-----------------------------
mqtt_manager'Ä± denemeye baÅŸladÄ±m. Ã¶ncelikle get metodu iÃ§in ÅŸÃ¶yle bir inject ile mesaj gÃ¶nderdim, rpc'yi taklit ederek.
msg.topic= "v1/devices/me/rpc/request/1001"
msg.payload={
  "method": "cmd",
  "params": {"type": "get", "target": {"light_pulse": {"duration": null}}}
}
port1,2,3 Ã§Ä±kÄ±ÅŸlarÄ±na da birer debug baÄŸladÄ±m.
Ã§Ä±kan mesaj ÅŸÃ¶yle:
07.08.2025 19:29:30node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
light_pulse: object
duration: null
tabi ki duration: 2 olarak Ã§Ä±kmalÄ±ydÄ± mesaj.
flow_context'te light_pulse iÃ§in duration deÄŸerini bulamamÄ±ÅŸ anlaÅŸÄ±lan.
path: value' gibi bir sorunumuz mu var?
get sorgulamasÄ± config veya runtime alanÄ± fark etmeksizin doÄŸru deÄŸeri bulup, gelen get mesajÄ±ndaki null yerine koyup cevap olarak gÃ¶ndermeli.
muhtemelen set mesajÄ±nda da benzer bir sorun olacaktÄ±r, henÃ¼z test etmedim.
ben full path olarak yani en root tarafÄ±, yanini config>timers>... veya runtime>material.. gibi yazmaya gerek olmadan bir yol bulunur diye dÃ¼ÅŸÃ¼nmÃ¼ÅŸtÃ¼m.
Ã§Ã¼nkÃ¼ flow_context'te Ã§akÄ±ÅŸma olacak alanlar yok.
evet set/get konusuyla baÅŸlayalÄ±m mqtt_manager'a.
kodu gÃ¶ndereyim mi istermisin?
msg.payload={
  method: "cmd",
  params: {type": "get", target: {config: {timers: {light_pulse: {duration: null}}}}}
}
msg.payload={
  method: "cmd",
  params: {type": "set", target: {config: {timers: {light_pulse: {duration: 5}}}}}
}

------------------------------
bu arada, timer_manager'da bir sorunu fark ettim.
sanki Ã§Ä±kÄ±ÅŸ portu yÃ¶nlendirmeleri hatalÄ±.
const out = [[], [], []]; // Port 1,2,3 biÃ§imindedir, istediÄŸim adlandÄ±rma budur.
timer'la ilgili olmayan komutlar doÄŸru biÃ§imde port 2'den Ã§Ä±kÄ±yor.
Ã¶rneÄŸin aÅŸaÄŸÄ±daki gelen mesaj aynen port 2'ye yÃ¶nlendiriliyor, bu doÄŸru, sorun yok.
msg.payload={
  "method": "cmd",
  "params": {"type": "forward_on", "target": "hatch"}
}
fakat Ã¶rneÄŸin timer'la ilgili gelen ÅŸu mesaj port 3'ten Ã§Ä±kÄ±yor.
msg.payload={
  "method": "cmd",
  "params": {"type": "on", "target": "light_pulse"}
}
oysa doÄŸrusu port 2'den Ã§Ä±kmasÄ±dÄ±r, Ã§Ã¼nkÃ¼ pass alanÄ±ndaki metadata'sÄ± port: 2.
light_pulse: {
  form: "delay", duration: 2, unit: "s",
  pass: {
    1: {method: "cmd", params: {type: "on", target: "light"}, port: 2},
    2: {method: "cmd", params: {type: "off", target: "light"}, port: 2}
  }
},
sanÄ±rÄ±m metadata port: X deÄŸerlerini 0 index'li kabul ediyor, port: 2 olmasÄ± gerekirken sanki port: 3 olarak yorumlanÄ±yor kodda.
acaba sorunun kaynaÄŸÄ± bu mudur, yoksa baÅŸka bir ÅŸey mi?
eÄŸer buysa nasÄ±l dÃ¼zeltebiliriz?
---------------
{"method": "cmd", "params": {"type": "get", "target": {"light_pulse": {"duration": null}}}}
---------------------------------
mqtt_manager aÃ§Ä±klamasÄ±.
method: "cmd" ile gelen tÃ¼m mesajlar iÃ§in ekstra yapÄ±lacak iÅŸler bir yana, mutlaka thingsboard rpc prosedÃ¼rÃ¼ uygulanÄ±r.
yani 1 nolu porttan cevap mesajÄ± gÃ¶nderilir ki thingsboard cevabÄ± alsÄ±n ve prosedÃ¼rÃ¼ baÅŸarÄ±lÄ± olarak sonlandÄ±rsÄ±n kendi tarafÄ±nda.
cevap mesajÄ± iÃ§in msg.topic'te kodda gÃ¶rdÃ¼ÄŸÃ¼n gibi requestId'li dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lÄ±r.
cevabÄ±n payload'u ise yalnÄ±zca bir istisna hariÃ§ daima gelen mesajÄ±n payload'unun aynÄ±sÄ±dÄ±r. 
istisna ise type: "get" olarak gelen mesajlardadÄ±r, gelen payload'da null yazan yere flow context'inden alÄ±nan deÄŸer koyulur ve cevap payload'u olarak gÃ¶nderilir, istisna durum yalnÄ±zca budur.
get'ten bahsettiÄŸimiz gÃ¶re hemen type: set olan mesajlarda ne olacak bakalÄ±m.
dediÄŸim gibi, method: "cmd" ile gelen tÃ¼m mesajlarda type: "get" Ã¶zel durumu hariÃ§, cevap payload'u gelen payload'un aynÄ±sÄ±dÄ±r, ve bir de topic dÃ¶nÃ¼ÅŸÃ¼mÃ¼ var tabi.
ÅŸimdi rpc prosedÃ¼rÃ¼nÃ¼ aÃ§Ä±klamÄ±ÅŸ olduk, devam edelim.
type: "set" ile gelenlerde flow context'i gÃ¼ncelleniyor, bunu yeterince konuÅŸtuk, get/set full path sistemine geÃ§tiÄŸimizi bundan bÃ¶yle.
target: "fsm" olarak gelen tÃ¼m mesajlar topic'leri yok edilerek ve payload'una hiÃ§ dokunmadan 2 nolu porttan gÃ¶nderilir.
ve burasÄ± Ã¶nemli, (type: "set" veya type: "get" veya taget: "fsm") olmayan tÃ¼m mesajlarÄ±n topic'leri yok edilip, payload'larÄ±na hiÃ§ dokunmadan 3 nolu porttan gÃ¶nderilir.
yani mqtt_manager kodunda, timer vb. bir ayrÄ±m sÃ¶z konusu deÄŸil, varsa bu ayrÄ±m iptal edilsin. 
buraya kadar hep method: "cmd" iÃ§in konuÅŸtuk, ÅŸimdi de method: "evt"'ye bakalÄ±m.
method: "evt" ile gelen tÃ¼m mesajlara telemetry prosedÃ¼rÃ¼ uygulanÄ±r, yani karÅŸÄ±lÄ±ÄŸÄ±nda 1 nolu porttan mesaj gÃ¶ndermek anlamÄ±ndadÄ±r ve mesaja bir de mag.topic= "v1/devices/me/telemetry" biÃ§iminde topic eklemek anlamÄ±ndadÄ±r.
yani thingsboard'a tek yÃ¶nlÃ¼ bir gÃ¶nderimdir.
method: "evt" ile gelen mesajlar iÃ§in gÃ¶nderilecek payload'un ne olacaÄŸÄ± konusunda bir ayrÄ±m var.
eÄŸer type: "telemetry_periodical", val: null ise gÃ¶nderilecek payload;
msg.payload={
  method: "evt",
  params: {runtime'Ä±n altÄ±ndaki tÃ¼m yapÄ± ve olduÄŸu gibi}
}
eÄŸer type: "telemetry_periodical", val: null ise gelen mesajÄ±n payload'una hiÃ§ dokunmadan gÃ¶nderilir.
tekrar hatÄ±rlatÄ±rsak method: "evt" ile gelen mesajlara karÅŸÄ±lÄ±k 1 nolu porttan mesaj gÃ¶nderilir, msg.mag.topic= "v1/devices/me/telemetry" biÃ§iminde topic ekleyerek ve yukarÄ±da aÃ§Ä±kladÄ±ÄŸÄ±m ayrÄ±ma bakÄ±p cevap payload'unu belirleyerek.

umarÄ±m hatalÄ± aÃ§Ä±klama yapmamÄ±ÅŸÄ±mdÄ±r, mqtt_manager'Ä±n bu aÃ§Ä±klamalarÄ±ma gÃ¶re dÃ¼zenlemesini yaparsan Ã§ok sevinirim.
istersen kodu tekrar gÃ¶nderirim..
---------------------
ÅŸÃ¶yle bir mesaj gÃ¶nderdim inject nodundan:
msg.topic= "v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
1 nolu porttan Ã§Ä±kan debug mesaj ÅŸÃ¶yle oldu:
07.08.2025 21:15:43node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: null
gÃ¶nderdiÄŸim mesaj mÄ± hatalÄ± yoksa kod mu acaba?
-------------------------,
tekrar anlayamadÄ±ÄŸÄ±m ÅŸey ÅŸu:
flowData zaten var.
const flowData = flow.get("flow") || {}; 
gelen mesaj diyelim get olsun ve Ã¶rneÄŸin target: {"a": {"b": {"c": null}}} olsun.
flowData.a.b.c bizim istediÄŸimiz deÄŸer deÄŸil mi?
------------------
kodu tekrar test ettim ÅŸÃ¶yle detay bir sorun var.
mevcut duration: 2 iken get yaptÄ±m, cevap ÅŸu Ã§Ä±ktÄ±, duration key yok olmuÅŸ aradan:
07.08.2025 22:18:51node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: 2
daha sonra duration: 8 olacak biÃ§imde set yaptÄ±m ve cevap ÅŸu Ã§Ä±ktÄ±, doÄŸru olarak:
07.08.2025 22:19:07node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8
sonra tekrar get yaptÄ±m ve cevap artÄ±k doÄŸru Ã§Ä±ktÄ±, duration key var.
07.08.2025 22:19:22node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8

kullandÄ±ÄŸÄ±m kod ÅŸu:

mqtt_manager:
------------------------
{"method": "cmd", "params": {"type": "start", "target": "fsm"}}

07.08.2025 22:45:47node: port 2
msg.payload : Object
object
method: "cmd"
params: object
type: "start"
target: "fsm"
-------------------------
sanÄ±rÄ±m mqtt_manager iÃ§in tÃ¼m testleri yaptÄ±m, tek bir detay sorun kaldÄ± geriye.
gelen ilk get mesajÄ±:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
Ã§Ä±kan debug mesaj (doÄŸru):
07.08.2025 23:19:43node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 2
gelen set mesajÄ±:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "set", "target": {"config": {"timers": {"light_pulse": {"duration": 8}}}}}}
Ã§Ä±kan debug mesajÄ±(doÄŸru):
07.08.2025 23:19:57node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: 8
gelen 2. get mesajÄ±:
msg.topic="v1/devices/me/rpc/request/1001"
msg.payload={"method": "cmd", "params": {"type": "get", "target": {"config": {"timers": {"light_pulse": {"duration": null}}}}}}
Ã§Ä±kan debug mesajÄ±(yanlÄ±ÅŸ):
07.08.2025 23:20:18node: port 1
v1/devices/me/rpc/response/1001 : msg.payload : Object
object
method: "cmd"
params: object
config: object
timers: object
light_pulse: object
duration: object
duration: 8
yani duration iÃ§inde bir duration daha olmuÅŸ.

kullandÄ±ÄŸÄ±m kod ÅŸu.
mqtt_manager:
{"subject":"hatch","body":"stop"}
---------------
tekrardan merhaba,
mqtt_manager kodunda bir deÄŸiÅŸiklik istiyorum.
bu fonksiyon nodunun 3 Ã§Ä±kÄ±ÅŸ portu vardÄ±, ÅŸimdi artÄ±k 2 portlu olacak, nod setup'Ä±nda gerekli deÄŸiÅŸikliÄŸi yaptÄ±m.
halen 3 nolu porttan Ã§Ä±kÄ±yor olan mesajlarÄ±n da 2 nolu port'tan Ã§Ä±kmalarÄ±nÄ± saÄŸlayabilir misin?
bu port yÃ¶nlendirme dÄ±ÅŸÄ±nda kodda baÅŸka hiÃ§bir deÄŸiÅŸiklik olmasÄ±n.
gerekli olabilir mi bilmiyorum ben yine de flow_context kodunu da gÃ¶nderiyorum.

mqtt_manager:
------------------------
tamamdÄ±r, mqtt_manager artÄ±k port 1 ve port 2 olarak 2 Ã§Ä±kÄ±ÅŸ portlu oldu.
ÅŸimdi bir deÄŸiÅŸiklik daha istiyorum.
method: "evt" ile gelen mesajlar ikiye ayrÄ±lÄ±yor ve benim kodu okuyabildiÄŸim kadarÄ±yla ÅŸÃ¶yle iÅŸliyor.
gelen telemetry_priodical iÃ§in flow context'in runtime alanÄ±nÄ±n altÄ±ndaki tÃ¼m yapÄ± olduÄŸu gibi gÃ¶nderiliyor ve sonuÃ§ olarak Ã§Ä±kan mesajÄ±n payload'u ÅŸÃ¶yle oluyor:
msg.payload={
  oxygen_detector: {val: "off"},
  humidity_detector: {val: "off"},
  .....,
  .....,
  .....,
}
else durumunda yani aslÄ±nda tekil olarak gelen mesajlarÄ±n payload'larÄ± ise olduÄŸu gibi(params'Ä±n iÃ§i) gÃ¶nderildiÄŸinden Ã¶rneÄŸin ÅŸÃ¶yle Ã§Ä±kÄ±yor:
msg.payload={
  type: "oxygen_detector",
  val: "val: "off"
}
aÅŸaÄŸÄ±daki koda bakÄ±ldÄ±ÄŸÄ±nda, buraya kadar sÃ¶ylediklerim doÄŸru mu?
eÄŸer doÄŸruysa gelen bu iki ayrÄ± mesaj opsiyonu iÃ§in nasÄ±l aynÄ± yapÄ±da mesaj Ã§Ä±kmasÄ±nÄ± istediÄŸimi aÃ§Ä±klayacaÄŸÄ±m ve mqtt_manager'da senden dÃ¼zeltmeni isteyeceÄŸim.
aynÄ± yapÄ±da Ã§Ä±kmalÄ±lar ki thingsboard tarafÄ±nda tek yÃ¶ntemle key: value'larÄ± ayÄ±klayabileyim, toplu da gelse tek tek de gelse thingsboard'a.

if (method === "evt") {
    const subType = params?.type;
    if (subType === "telemetry_periodical") {
        return [{
            topic: "v1/devices/me/telemetry",
            payload: runtime
        }, null];
    } else {
        return [{
            topic: "v1/devices/me/telemetry",
            payload: params
        }, null];
    }
}
--------------------------
merhaba,
raspberry pi'de node red ile bir flow oluÅŸturmaya devam ediyorum.
node-red-contrib-modbus paketide yÃ¼klÃ¼.
Ã¶ncelikle sana actuators nodunun ve flow_context nodunun kodlarÄ±nÄ± gÃ¶ndereyim, ve doÄŸrudan kod yazmaya yardÄ±mcÄ± olsun.
hemen ardÄ±ndan aÃ§Ä±klama gÃ¶ndereceÄŸim.

ÅŸimdi bir fonksiyon nodu daha eklemem gerekiyor flow'a.
Ã¶nce ÅŸu bilgiyi hatÄ±rlayalÄ±m.
flow'un node red restart'Ä±ndan(power reset/reboot) mÃ¼mkÃ¼n olduÄŸunca etkilenmemesini istiyorum, tÄ±pkÄ± bir plc gibi Ã§alÄ±ÅŸacak Ã§Ã¼nkÃ¼.
bir miktar zaman sapmasÄ± makul kabul edilir.
ÅŸimdilik bir flow_context nodu var ve giriÅŸine baÄŸlÄ± olan bir inject ile her node red restart'Ä±nda flow context'ini elle yÃ¼klÃ¼yorum.
daha sonra settings.js'de aÅŸaÄŸÄ±daki gibi, diske yazan, kalÄ±cÄ±lÄ±k ayarÄ±nÄ± yaptÄ±ÄŸÄ±mda bu noda gerek kalmayacak. 
contextStorage: {
  default: {
    module: "localfilesystem",
    config: {
      flushInterval: 30  // saniye cinsinden
    }
  }
}
node red tÃ¼m context'lerin global(kullanmÄ±yoruz)/flow/node, her 30 saniyede bir(flushinterval) son gÃ¼ncel halini diske kaydeder.
bu iÅŸlemi arka planda yapar, kendi baÄŸÄ±msÄ±z zamanlamasÄ±yla.
Ã¶rneÄŸin flow context her 1 saniyede gÃ¼ncelleniyor da olsa, diske yalnÄ±zca bir sonraki flushinterval geldiÄŸinde en gÃ¼ncel hali kaydedilir.
node red restart olduÄŸunda, flow en kÃ¶tÃ¼ senaryoda power down'dan 30 saniye Ã¶ncesindeki runtime deÄŸerleri ile yeniden Ã§alÄ±ÅŸmaya baÅŸlayacaktÄ±r.
bu benim iÃ§in makul bir sÃ¼redir.
ve bu yÃ¼zden timer_manager iÃ§inde; dÄ±ÅŸtan 1 saniyelik timer_tick ve date.now yÃ¶ntemiyle Ã§alÄ±ÅŸan kalÄ±cÄ± timer'lar tasarladÄ±k, node red'in kendi nodlarÄ± (inject, delay) kalÄ±cÄ± deÄŸiller ve uzun sÃ¼reli iÅŸler iÃ§in kullanÄ±lamazlardÄ±.
buraya kadar tamam ama eksik olan ÅŸu:
sinamics, loader(rÃ¶le grubu), diÄŸer rÃ¶leler(ÅŸimdilik light, buzzer var), bunlar aynÄ± elektrik sistemindeler ve elektrip gidip geldikten sonra muhtemelen hepsi "off" olarak baÅŸlayacaklar, runtime'larÄ± "forward_on", "on" vb. olarak kurtarÄ±lmÄ±ÅŸ olsa bile.
yani flow'a restore adlÄ± bir fonksiyon nodu eklemek gerekir ve Ã§Ä±kÄ±ÅŸÄ±nÄ± actuators noduna baÄŸlamak.
restore nodunun her node red start'Ä±nda bir defa Ã§aÄ±lÅŸmasÄ± iÃ§in sanÄ±rÄ±m ui configuration ekranÄ±nda "on message" deÄŸil de "on start" sekmesi altÄ±na kodu yazmak dÃ¼ÅŸÃ¼nÃ¼lebilir, en pratik yol bu mudur, ne dersin?
restore adÄ±nda ayrÄ± bir noda gerek yok, actuators'un kendi "on start" sekmesi kullanÄ±labilir restore edecek kodu yazmak iÃ§in.
fakat yine de generic bir restore nodu olsun flow'da. 
bence telemetry'yi restore etmenin gereÄŸi yok Ã§Ã¼nkÃ¼ zaten tÃ¼m event'lar anÄ±nda thingsboard'a gÃ¶nderilmiÅŸtir.
belki tam gÃ¶nderme anÄ±nda bir kesinti sorun olabilir. bilemiyorum, Ã§ok dÃ¼ÅŸÃ¼k olasÄ±lÄ±k.
peki restore nasÄ±l bir gÃ¶rev yapmalÄ±?
bence runtime'daki son durumlarÄ± forward_on/on/off vb. olarak ayrÄ±ÅŸtÄ±rmaya gerek olmadan son durumlarÄ±n gereÄŸi olan mesajlarÄ± Ã§Ä±karsÄ±n ve gerÃ§ek dÃ¼nyadaki modbus cihazlarÄ±nÄ± kendine node red start'Ä±nda sync etmiÅŸ olsun.
senin gÃ¶rÃ¼ÅŸÃ¼n nedir ne yapmalÄ±?

runtime'da sinamics, loader, relay'lar vb tÃ¼m actuatorler iÃ§in off'lar iÃ§in gerekmez demeden, hepsi iÃ§in gereken mesajlar Ã§Ä±ksÄ±n ve zorla sync etsin. 
restore nodu ayrÄ± olsun, "on_start" sekmesinin altÄ±na kodu yerleÅŸtiririz. ÅŸÃ¶yle bir bak istersen..
---------------
    fan_pwm: {"val":"off","phase":null,"on_time":0,"phase_until":0},
    light_pulse: {"val":"off","on_time":0,"done":false},
    day_counter: {"val":"off","on_time":0,"count":21,"next_time":0},
    telemetry_periodical: {"val":"off","on_time":0,"next_time":0},
    fsm: {"state":"stop"}
    ----------------------
restore fonksiyonu(kodu on start sekmesine yazÄ±yoruz) ilk Ã§alÄ±ÅŸmaya belirli bir sÃ¼re sonra baÅŸlasÄ±n.
bu sÃ¼re geÃ§meden mesaj gÃ¶ndermeye baÅŸlamasÄ±n.
Ã§Ã¼nkÃ¼ elektrik gidip geldiÄŸinde Ã¶rneÄŸin sinamics cihazlarÄ± henÃ¼z power up'larÄ±nÄ± tamamlamamÄ±ÅŸ olabilirler.
flow_context'e config>sinamics>restore_delay: 10, olarak saniye cinsinden bir sÃ¼re ekledim, bu sÃ¼reyi kullanalÄ±m ve gerekli kod eklemesini yapalÄ±m lÃ¼tfen.

----------------------------------
ÅŸimdi mqtt_manager'da bir deÄŸiÅŸiklik yapalÄ±m set|get konusuyla ilgili.
mevcut kod set payload'unu aÅŸaÄŸÄ±daki Ã¶rnekler gibi bekliyor:
msg.payload={
  method: "cmd",
  params: {type: "set", target: {config: {timers: {fan_pwm: {t_duty: <value>}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "set", target: {config: {io: {analog_inputs: {channels: {material: {pro: {material_detector:{on: <new-value>}}}}}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "set", target: {runtime: {oxygen_detector: {val: "on"}}}}; // bazen bozuk sensÃ¶rler iÃ§in runtime'da bu ÅŸekilde overwrite yapmam gerekebilir Ã§Ã¼nkÃ¼.
}
mevcut kod get payload'unu aÅŸaÄŸÄ±daki Ã¶rnekler gibi bekliyor:
msg.payload={
  method: "cmd",
  params: {type: "get", target: {config: {timers: {fan_pwm: {t_duty: null}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {config: {io: {analog_inputs: {channels: {material: {pro: {material_detector:{on: null}}}}}}}}};
}
msg.payload={
  method: "cmd",
  params: {type: "get", target: {runtime: {oxygen_detector: {val: null}}}};
}
yukarÄ±da anlattÄ±klarÄ±m doÄŸru mudur, ve karÅŸÄ±lÄ±ÄŸÄ±nda gÃ¶nderdiÄŸi cevaplar da aynÄ± yapÄ±dadÄ±r deÄŸil mi?
eÄŸer bunlar doÄŸru ise birazdan deÄŸiÅŸiklik isteÄŸimi gÃ¶ndereceÄŸim.

mqtt_manager:
----------------------------------
yeni bir Ã§Ã¶zÃ¼m arayÄ±ÅŸÄ±nÄ±n kaynaÄŸÄ±, thingsboard tarafÄ±ndaki rpc widget'lerinin initial deÄŸerleri iÃ§in get komutunu rpc prosedÃ¼rÃ¼ ile gÃ¶ndermem gerekmesi.
fakat thingsboard tarafÄ±nda widget initialization iÃ§in yalnÄ±zca method kÄ±smÄ±nÄ± gÃ¶nderebiliyorum, params kÄ±smÄ±nÄ± gÃ¶nderemiyorum rpc widget'lerden, yani orayÄ± kullanamam anladÄ±ÄŸÄ±m kadarÄ±yla.
Ã¶nÃ¼mde 2 yol var.
1.
mqtt_manager'da get ayrÄ±mÄ± iÃ§in mesajÄ±n ona method: "get" olarak gelmesi, yani gelen mesajda doÄŸrudan method ile ifade edilmesi.
ve bu durumda tÃ¼m flowData'nÄ±n thingsboard'a cevap olarak gÃ¶nderilmesi, orada ayÄ±klanmasÄ± post process'te.
ve belki de set iÃ§in deÄŸiÅŸikliÄŸe gitmemek.
2.
hem set hem de get iÃ§in geÃ§erli olabilecek biÃ§imde target: nested gÃ¶nderimi yerine, Ã¶rneÄŸin az Ã¶nce paylaÅŸmÄ±ÅŸ olduÄŸum Ã¶rneklere iÃ§in, mqtt_manager'a aÅŸaÄŸÄ±daki mesajlar gelecek biÃ§imde thingsboard'da ayar yapabilirim:
gelen set mesajÄ± Ã¶rneÄŸi:
msg.payload={
  method: "set.config.timers.fan_pwm.t_duty",
  params: {value: <flow context'e yazÄ±lacak yeni t_duty deÄŸeri>};
}
thingsboard rpc dÃ¶kÃ¼manÄ±ndan anladÄ±ÄŸÄ±m kadarÄ±yla set mesajÄ±na cevabÄ± basitÃ§e ÅŸÃ¶yle verebiliriz, iÃ§inde onay deÄŸerinin(value: <new-value> v) olup olmamasÄ± fark etmiyor:
msg.payload={
  response: true
}
gelen get mesajÄ± Ã¶rneÄŸi:
msg.payload={
  method: "get.config.timers.fan_pwm.t_duty",
  params: {}; // thingsboard widget'i params gÃ¶nderiyor mu gÃ¶ndermiyor mu bilmiyorum ama sanÄ±rÄ±m Ã§ok da Ã¶nemi yok, yine anladÄ±ÄŸÄ±m kadarÄ±yla.
}
get mesajÄ±na cevabÄ± ÅŸÃ¶yle verebiliriz:
msg.payload={
  value: <flow context'ten alÄ±nacak t_duty deÄŸeri>
}
yani set/get ayrÄ±mÄ± iÃ§in method'u "." split edip startsWith(set/get) bakarak Ã§alÄ±ÅŸÄ±r mqtt_manager kodu.
"." kullanmanÄ±n bir mahsuru var mÄ±, ">" gibi baÅŸka bir karakter mi kullanalÄ±m?
sonuÃ§ olarak ben 2. yolu daha Ã§ok beÄŸendim, hem set hem de get iÃ§in aynÄ± yapÄ± olur gelen mesajlarda.
ayrÄ±ca madem ki set iÃ§in aÅŸaÄŸÄ±daki response'u belirledik, o zaman method: "cmd" ile gelen mesajlar iÃ§in de aynÄ± response ile cevap verilsin.
msg.payload={
  response: true
}
mevcut kodda echo gibi cevap veriyorduk. 
yalnÄ±zca get iÃ§in yani method: "get......" ile gelen mesajlar iÃ§in Ã¶zel bir cevabÄ±mÄ±z olur.
not: burada anlattÄ±klarÄ±mÄ±n rpc ile ilgilidir, method: "evt" ile gelen mesaj'larla(telemetry) hiÃ§bir ilgisi yok.

ne dersin 2. yol uygun mu, ya da thingsboard ile ilgili bilmediÄŸim bir ÅŸey var mÄ±?
---------------
get.runtime.roof.speed.set_point

var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.value;

cmd

return {"type":"speed","set_point":value,"target":"fan"};
----------------------------
thingsboard'un Ã¶rneÄŸin time series chart widget'leri aÅŸaÄŸÄ±daki gibi bir data post process'e imkan saÄŸlÄ±yor:

"Data post-processing function

function (time, value, prevValue, timePrev, prevOrigValue): any

A JavaScript function doing post-processing on telemetry data.

Parameters:

time: number - timestamp in milliseconds of the current datapoint.
value: primitive (number/string/boolean) - A value of the current datapoint.
prevValue: primitive (number/string/boolean) - A value of the previous datapoint after applied post-processing.
timePrev: number - timestamp in milliseconds of the previous datapoint value.
prevOrigValue: primitive (number/string/boolean) - An original value of the previous datapoint.
Returns:

A primitive type (number, string or boolean) presenting the new datapoint value.

Examples
Multiply all datapoint values by 10:
return value * 10;
Round all datapoint values to whole numbers:
return Math.round(value);
Get relative difference between data points:
if (prevOrigValue) {
    return (value - prevOrigValue) / prevOrigValue;
} else {
    return 0;
}
Formatting data to time format
if (value) {
  return moment(value).format("DD/MM/YYYY HH:mm:ss");
}
return '';
Creates line-breaks for 0 values, when used in line chart
if (value === 0) {
  return null;
} else {
  return value;
}
Display data point of the HTML value card under the condition
return value ? '<div class="info"><b>Temperature: </b>'+value+' Â°C</div>' : '';"

yani bakÄ±ldÄ±ÄŸÄ±nda gelen telemetry datasÄ±nÄ± ancak number/string/boolean bir value olarak kabul ediyor gibi gÃ¶rÃ¼yorum.
peki benim mqtt_manager'dan gÃ¶nderdiÄŸin telemetry datasÄ± string olarak mÄ± thingsboard2a ulaÅŸÄ±yor? ya da ÅŸÃ¶yle sorayÄ±m, runtime'Ä±n altÄ±ndan material: {val: 0} olarak gÃ¶nderiyoruz. 

var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.oxygen_detector.val === "run" ? true : false;
------------------------------
// Post-process function
var source = typeof value !== 'undefined' ? value : data;
var obj = typeof source === 'string' ? JSON.parse(source) : source;

// Ã–rnek: tek bir val deÄŸeri dÃ¶ndÃ¼rmek
if (obj && obj.val !== undefined) {
    return obj.val;
}

// Ã–rnek: nested key (Ã¶r. oxygen_detector.val)
if (obj && obj.oxygen_detector && obj.oxygen_detector.val !== undefined) {
    return obj.oxygen_detector.val === "run"; // LED iÃ§in boolean
}

// VarsayÄ±lan
return null;
------------------------------------
context/
 â”œâ”€ <flowID>/
 â”‚   â”œâ”€ global.json
 â”‚   â”œâ”€ flow.json
 â”‚   â”œâ”€ <nodeID>.json
 â”‚   â”œâ”€ <baÅŸkaNodeID>.json
 â”‚   â””â”€ ...
global.json â†’ global.set() ile kaydedilenler

flow.json â†’ flow.set() ile kaydedilenler

<nodeID>.json â†’ node.context().set() ile kaydedilenler

<flowID> klasÃ¶r ismi, o flowâ€™un internal IDâ€™sidir.

-------------------------
Ã¶nceki konuya dÃ¶nersek:

Ã¶rneÄŸin thingsboard time series chart widget ile runtime'daki water deÄŸerini izlemek istiyorum.

thingsboard time series chart iÃ§in help ÅŸÃ¶yle:

"Data post-processing function

function (time, value, prevValue, timePrev, prevOrigValue): any

A JavaScript function doing post-processing on telemetry data.

Parameters:

time: number - timestamp in milliseconds of the current datapoint.
value: primitive (number/string/boolean) - A value of the current datapoint.
prevValue: primitive (number/string/boolean) - A value of the previous datapoint after applied post-processing.
timePrev: number - timestamp in milliseconds of the previous datapoint value.
prevOrigValue: primitive (number/string/boolean) - An original value of the previous datapoint.
Returns:

A primitive type (number, string or boolean) presenting the new datapoint value.

Examples
Multiply all datapoint values by 10:
return value * 10;
Round all datapoint values to whole numbers:
return Math.round(value);
Get relative difference between data points:
if (prevOrigValue) {
    return (value - prevOrigValue) / prevOrigValue;
} else {
    return 0;
}
Formatting data to time format
if (value) {
  return moment(value).format("DD/MM/YYYY HH:mm:ss");
}
return '';
Creates line-breaks for 0 values, when used in line chart
if (value === 0) {
  return null;
} else {
  return value;
}
Display data point of the HTML value card under the condition"

yani burada anahtar sÃ¶zcÃ¼k value ve primitive (number/string/boolean) diye bir aÃ§Ä±klamasÄ± var.

bizim mqtt_manager nodu flow tarafÄ±ndan method: "evt" ile gelen mesajlarÄ± mqtt_out noduna Ã¶rneÄŸin ÅŸÃ¶yle bir kodla gÃ¶nderiyor?
msg.payload={
  water: {val: 15}
}
yani json olarak yazarsak ÅŸÃ¶yle:
{
  "water": {"val": 15}
}
ve bu gÃ¶nderim gerÃ¶ekte object midir yoksa string hakine mi getirilmiÅŸtir ben bu konularÄ± iyi anlayamadÄ±m.
dolayÄ±sÄ±yla bir yorum yapamÄ±yorum.
istediÄŸim ÅŸey, 15 deÄŸerini, yani gelen deÄŸerleri chart'ta gÃ¶sterebilmek.
daha Ã¶nce bu konuda kod Ã¶nerileri gÃ¶ndermiÅŸtin, widget'in "veri iÅŸleme sonrasÄ± fonksiyon kullan" editÃ¶rÃ¼ne koyabilmem iÃ§in.
Ã¶rneÄŸin ÅŸu kod:
// value -> ThingsBoard'un grafiklerde verdiÄŸi parametre
if (typeof value === 'string') {
    try {
        value = JSON.parse(value);
    } catch (e) {
        return null; // JSON parse hatasÄ±nda veri yokmuÅŸ gibi davran
    }
}

// value bir nesne ise "val" alanÄ±nÄ± dÃ¶ndÃ¼r
if (value && typeof value === 'object' && 'val' in value) {
    return value.val;
}

// primitive ise direkt dÃ¶ndÃ¼r
return value;
kodu ilgili alana koyduÄŸumda aÅŸaÄŸÄ±daki satÄ±rda "Read only" uyarÄ± ikonunu gÃ¶rÃ¼yorum editÃ¶rde.
lÃ¼tfen bu konuyu Ã§Ã¶zmemi saÄŸlayacak olan kodu yazabilir misin?
veya acaba mÃ¼mkÃ¼n olmayacak mÄ±, mqtt_manager'dan mesaj gÃ¶nderim yapÄ±mÄ±zÄ± mÄ± deÄŸiÅŸtirmeliyiz, umarÄ±m gerek kalmaz.

gÃ¶nderdiÄŸin ÅŸu kodu denedim Ã¶nce bir uyarÄ± ve bir de hata veriyor.

if (typeof value === 'string') {
    value = JSON.parse(value);
}
return value.val;
uyarÄ± ikonu value = JSON.parse(value); satÄ±rÄ±nda, "Read only".
Ekle(Add) butonuna bastÄ±ÄŸÄ±mda ise "Fonksiyon bir deÄŸer dÃ¶ndÃ¼rmelidir" hata mesajÄ± geliyor ekrana ve kabul etmiyor.
bir de ÅŸÃ¶yle denedim;
var x;
if (typeof value === 'string') {
    x = JSON.parse(value);
}
return x.val;
uayrÄ± ikonu yok ama hata aynÄ± ve kabul etmiyor.
--------------------
{"state":"stop"}
-----------------
tekrardan merhaba,
aÅŸaÄŸÄ±daki analog_pro kodunu ve flow_context ile uymunu incelemeni rica ediyorum.
bazÄ± isim deÄŸiÅŸiklikleri yapmÄ±ÅŸ olsam da saÄŸlÄ±klÄ± Ã§alÄ±ÅŸÄ±yordur.
karÄ±ÅŸÄ±klÄ±k olamsÄ±n, bu adÄ±mda key'lerden yalnÄ±z _ang_ olanlar ilgi alanÄ±mÄ±zdadÄ±r.
_dig_ olanlar bir sonraki adÄ±mda sÄ±fÄ±rdan yazacaÄŸÄ±mÄ±z digital_pro adlÄ± fonksiyon nodunda kullanÄ±lacaklar.
ÅŸimdi hem bir sorun var mÄ± diye kontrol etmeni hem de hysteresis'i gÃ¶rmeni istiyorum.
tabi ki sonraki adÄ±mda digital_pro'daki hysteresis kodu _dig_ key'leri birazcÄ±k farklÄ± yorumlayacak.
_dig_, _ang_ ayrÄ±mÄ±nÄ± merak etmiÅŸsindir;
projede bir oxygen bir de humidity sensÃ¶r cihazlarÄ± var, hem analog 4-20ma(ang) hem de 2 adet alarm switch(dig) Ã§Ä±kÄ±ÅŸ saÄŸlÄ±yorlar.
dig olanlar'Ä±n eÅŸikleri cihazlarÄ±n kendinde parametre olarak girilmiÅŸ olur.
ang ise parametreleri flow_context'te olup eÅŸikler analog_pro'da oluÅŸturulur.
ÅŸimdilik hangi Ã§Ä±kÄ±ÅŸ tipinin kullanÄ±lacaÄŸÄ± belli deÄŸil, o nedenle her ihtimale aÃ§Ä±k olsun diye flow, bÃ¶yle yapÄ±yorum.

analog_pro:

flow_context:
----------------
LED OLD
var payload = typeof data === 'string' ? JSON.parse(data) : data;
return payload && payload.body === "run" ? true : false;
----------------

flow'da kodlarÄ± yazÄ±lmÄ±ÅŸ halde 12 adet fonksiyon nodu var.
bunlardan biri flow_context. daha Ã¶nce bahsettiÄŸim gibi settings.js'de kalÄ±cÄ±lÄ±k ayarÄ± yapÄ±ldÄ±ktan sonra dosya haline dÃ¶nÃ¼ÅŸecek, fakat ÅŸimdilik flow context'ini her node red restart'Ä±nda bir inject yardÄ±mÄ±yla bu nodu elle yÃ¼klemiÅŸ oluyorum.
sen bir konuda beni uyardÄ±n, flow context'i Ã¼zerinde Ã§ok kÄ±sa zaman'lar iÃ§inde bir Ã§ok nodun iÅŸlem yapmasÄ±, Ã¶zellikle yazma/gÃ¼ncelleme iÅŸlemi, Ã§eÅŸitli sorunlara neden olabilir diyerek.
ve nodlarÄ±n bu iÅŸlemi tÃ¼mden deÄŸil de sadece gerekli kÄ±smÄ±n gÃ¼ncellenmesi ile yapmasÄ±nÄ±n daha iyi olacaÄŸÄ±nÄ±, merge yÃ¶ntemini bildirdin.
ÅŸimdi nasÄ±l bir yol izleyelim ki tÃ¼m nodlarÄ± bu merge yÃ¶ntemi ile Ã§alÄ±ÅŸÄ±r hale getirelim.
her adÄ±mda sana hem deÄŸiÅŸecek nodu hem de yanÄ±nda flow_context nodunu gÃ¶ndereyim ve sen de nodu deÄŸiÅŸtir desem uygun mudur?


mergeDeep(flowData, newData);
flow.set("flow", flowData);

....

function mergeDeep(target, source) {
    for (const key of Object.keys(source)) {
        if (
            source[key] &&
            typeof source[key] === "object" &&
            !Array.isArray(source[key])
        ) {
            if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key])) {
                target[key] = {};
            }
            mergeDeep(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}
------------------
aklÄ±ma ÅŸu geldi, acaba merge tekniÄŸini yalnÄ±zca timer_manager'da mÄ± kullansak, diÄŸer nodlarda buna gerek olmadÄ±ÄŸÄ±nÄ± mÄ± dÃ¼ÅŸÃ¼nsek.
flow'da yalnÄ±zca timer_manager nodu periyodik olarak tetikleniyor ve sanki diyelim background gibi iÅŸlem yapÄ±yor. diÄŸer tÃ¼m nodlar ise bir sÄ±ralama ile tetiklenirler en kÃ¶tÃ¼ senaryoda bile, yani birinin flow context'i ile iÅŸi bitmeden ve mesaj Ã§Ä±karmadan diÄŸeri tetiklenmez henÃ¼z.
bilmiyorum tam anlatabildim mi? tamam bunun yanÄ±nda digital_inputs vb. nodlar da var, her 100ms'de bir modbus flex getter'Ä±n yolladÄ±ÄŸÄ± veriyi kontrol ediyorlar, ama kendi node context'leri ile bunu yapÄ±yorlar, ve yalnÄ±zca bir deÄŸiÅŸiklik varsa flow context'ini gÃ¼ncelliyorlar ki bu deÄŸiÅŸiklik mesela bir butona basÄ±lmasÄ±dÄ±r.
evet bir butona basÄ±ldÄ±ÄŸÄ±nda ardarda nodlar tetikleniyor ama dediÄŸim gibi sÄ±ralÄ±dÄ±r. fakat ben javascript konusunu iyi bilmediÄŸimden thread yÃ¶netimi nasÄ±l bilmediÄŸimden bu konuda yorum yapamÄ±yorum. senin fikrini merak ettim.
------------------------
evet beni Ã§ok iyi anladÄ±n.
Ã¶yleyse sadece node context'ini kullanalÄ±m merge ile yazma konusundan tamamen vazgeÃ§elim.
flow'daki hiÃ§bir nod'a (timer_manager dahil) merge fonksiyonu eklemeyeceÄŸiz. 
ve ÅŸimdi gelelim timer_manager'a:  
talebim tam olarak ÅŸÃ¶yle.
timer_manager nodu flow context'ini hiÃ§ kullanmasÄ±n, oradaki ihtiyacÄ±nÄ± tamamen node context'inde halletsin, yani kendi node context'ini kullansÄ±n tamamen.
sonra ben de flow_context nodunun kodundaki runtime alanÄ±ndaki aÅŸaÄŸÄ±daki satÄ±rlarÄ± tamamen sileyim, sen bunlarÄ± node context'i olacak biÃ§imde kullan ki timer'lar iÃ§in core kodlar deÄŸiÅŸmesin, yani node context'ine taÅŸÄ± bunlarÄ±.
fan_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
water_pump_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
light_pulse: {val: "off", on_time: 0, done: false},
light_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
buzzer_pulse: {val: "off", on_time: 0, done: false},
buzzer_pwm: {val: "off", phase: null, on_time: 0, phase_until: 0},
day_counter: {val: "off", on_time: 0, count: 21, next_time: 0},
telemetry_periodical: {val: "off", on_time: 0, next_time: 0},
not: timer_manager'Ä±n mevcut mesaj Ã¼retme ve onlarÄ± Ã§Ä±kÄ±ÅŸ portlarÄ±na yÃ¶nlendirme, timer logic'leri ve benzeri hiÃ§bir iÅŸlevi bozulmasÄ±n.

ÅŸimdi original kodlarÄ± tekrar gÃ¶nderiyorum.

timer_manager:
----------
var obj = (typeof value === 'string') ? JSON.parse(value) : value;
if (obj && obj.val !== undefined) {
    return obj.val.toUpperCase();
}
return null;

dd/MM/yyyy hh:mm
-------------------
en son olarak analog_inputs kodunu yazmÄ±ÅŸtÄ±k. ÅŸimdi ise aynÄ± context yaklaÅŸÄ±mlarÄ± ve aynÄ± change tekniÄŸi ile energy_meter'i dÃ¼zenleyelim.
zaten bu iki nod birbirine benzerdir.

Ã¶nce analog_inputs'u ve flow_context'i tekrar gÃ¶ndereyim referans olarak, sonraki adÄ±mda da energy_meter'i gÃ¶ndereyim dÃ¼zenleme yapman iÃ§in.
hazÄ±r mÄ±sÄ±n?

analog_inputs:
{"method": "cmd", "params": {"type": "speed", "set_point": 50, "target": "roof"}}
---
timer_manager'daki deÄŸiÅŸiklik iÃ§in flow_context'in runtime alanÄ±na aÅŸaÄŸÄ±daki satÄ±rÄ± ekledim.
day: {val: null},
yapmak istediÄŸim ÅŸey; day(count) deÄŸerini runtime'da da tutup, oraya da yazÄ±lmasÄ±nÄ± saÄŸlayÄ±p, mqtt_manager'Ä±n telemetry_periodical ile toplu publish'ine de dahil olmasÄ±nÄ± saÄŸlamak.
helen tekil event olarak mqtt_manager'dan publish ediliyor, 3. porttan oraya gÃ¶nderiliyor her gÃ¼n azalÄ±ÅŸÄ±nda.
oraya null yazdÄ±m, onun yerine 21 de yazabilirdim, hangisini yazmak daha iyi, veya fark eder mi?
zaten day_counter baÅŸlatÄ±ldÄ±ÄŸÄ±nda hemen config'deki base deÄŸerini oraya yazsÄ±n.
config'te de aynÄ± null kullanÄ±mÄ± var:
4: {method: "evt", params: {type: "day", val: null}, port: 3} // val: count
yani aÃ§Ä±kÃ§asÄ± null yerine count gelecek hepsi o kadar fakat ifade edemiyorum bir tÃ¼rlÃ¼.
ve sanÄ±rÄ±m null konusu nedeniyle timer_manager'da gereksiz bir kod kÄ±smÄ± da var, tam emin deÄŸilim.
null konusunu lÃ¼tfen Ã§Ã¶zelim pratik bir yoldan.
yani her iki yerde de(config, runtime) 21 yazsak doÄŸrudan, ne problem olur?
yani 21'in bir parametrik deÄŸiÅŸken olmasÄ± nedeniyle baÅŸlangÄ±Ã§ deÄŸerini bilemediÄŸimden tasarÄ±m zamanÄ±nda null yazÄ±yorum, kurtulalÄ±m o konudan. 

ÅŸimdi kodlarÄ± gÃ¶nderiyorum, timer_manager'da deÄŸiÅŸiklik iÃ§in ve hatta varsa farklÄ± bir Ã¶nderin null yerine, flow_context'te de o deÄŸiÅŸikliÄŸi yapayÄ±m.

timer_manager:
if (method === "cmd") {
  if (timers[target]) {
    if (!runtime[target]) {
      runtime[target] = {};
    }
    if (type === "on") {
      timerOn(timers[target], runtime[target], Date.now(), out, target);
    } else if (type === "off") {
      timerOff(timers[target], runtime[target], out, target);
    }
  } else if (target === "all" && type === "off") {
    for (const [key, timer] of Object.entries(timers)) {
      if (!runtime[key]) {
        runtime[key] = {};
      }
      timerOff(timer, runtime[key], out, key);
    }
  } else {
    out[1].push(msg);
  }
} else if (method === "evt" && type === "timer_tick") {
  timerTick(timers, runtime, Date.now(), out);
} else {
  out[1].push(msg);
}

case "cmd" iÃ§in case "fsm" deÄŸilse bir istisna hariÃ§ gelen tÃ¼m komutlar hiÃ§ dokunulmadan 1. porttan (outputs[0]) Ã§Ä±kacak, yani doÄŸrudan Ã§Ä±kÄ±ÅŸa iletilecek.
istisna ÅŸÃ¶yle; eÄŸer case "cmd" ve case "roof" ise:
--------------
gÃ¼zel oldu.
bence, Ã¶nce tekrar edip duran ÅŸu konuya bir Ã§Ã¶zÃ¼m bulalÄ±m. bir fonksiyona argÃ¼man olarak paslayalÄ±m, argÃ¼manlara baktÄ±ÄŸÄ±mÄ±zda zaten anlarÄ±z, yani okunaklÄ± kalÄ±r yine.. tabi 1. port'tan (sanÄ±rÄ±m hep "method: "cmd" ile Ã§Ä±kÄ±yor deÄŸil mi, ve 2. port'tan ise sadece "evt" ile Ã§Ä±kÄ±yor diye kÃ¼Ã§Ã¼k bir hatÄ±rlatma da yapmÄ±ÅŸ olayÄ±m.
yani ÅŸunlarÄ±:
outputs[0].push({ payload: { method: "on", params: { target: "water_pump_pwm" } } });
----------------------
actuators gÃ¼zel Ã§alÄ±ÅŸÄ±yor.
fakat bir istisna dÄ±ÅŸÄ±nda, en son Ã¼zerinde uÄŸraÅŸmÄ±ÅŸ olduÄŸumuz toplu off ile ilgili kod kÄ±smÄ±,
actuators'a gelen ÅŸu mesaj'a karÅŸÄ±lÄ±k;
msg.payload={"method": "cmd", "params": {"type": "off", "target": "all"}}
yani kodda ilgili kÄ±sÄ±m sanÄ±rÄ±m ÅŸuradan baÅŸlayan;
// === Toplu OFF ===
if (type === "off" && target === "all") {
  .....
actuators bu mesajÄ± aldÄ±ÄŸÄ±nda 3 nolu port'tan baÅŸarÄ±lÄ± biÃ§imde ardarda tÃ¼m mesajlarÄ± gÃ¶nderiyor, method: "evt"'li olarak herbiri. 
ve 2 nolu port'tan sinamics'ler iÃ§in tÃ¼m modbus mesajlarÄ±nÄ± da gÃ¶nderiyor baÅŸarÄ±lÄ± olarak.
fakat 1 nolu port'tan gÃ¶ndermesi gereken (relay_outputs_1 ve relay_outputs_2 ile ilgili) modbus mesajlarÄ±nÄ± gÃ¶ndermiyor.
yanlÄ±ÅŸ test ediyor olabilir miyim bilmiyorum, lÃ¼tfen sen de kodu kontrol et ve dediÄŸim gibi bir sorun varsa Ã§Ã¶zÃ¼mÃ¼nÃ¼ saÄŸlayabilirsin.

Modbus Failure On State sending Get More About It By Logging


ÅŸÃ¶yle Ã§alÄ±ÅŸsÄ±n;
Ã¶nce 2 saniye beklesin, sonra  
------------------

flow_context'te sinamics altÄ±ndaki restore_delay satÄ±rÄ±nÄ± sileceÄŸim, restore'de varsa gereken sÃ¼re(ler)'i hard code yapalÄ±m.
restore kodunu restore fonksiyon nodunun "on start" sekmesine yazÄ±yoruz ki node red baÅŸladÄ±ÄŸÄ±nda hemen bu kod Ã§alÄ±ÅŸsÄ±n diye.
ben node red'in settings.js'sinde contextstorage iÃ§in filememory olarak kalÄ±cÄ±lÄ±k ayarÄ± yapacaÄŸÄ±m. 
ÅŸÃ¶yle Ã§alÄ±ÅŸsÄ±n.
Ã¶ncelikle ÅŸu mesajÄ± gÃ¶ndersin ve sisteme enerji gitsin;
msg.payload={"method": "cmd", "params": {"type": "on", "target": "emergency_contactor"}}
sonra 5 saniye bekleyip ÅŸu mesajlarÄ± koddaki mevcut yÃ¶ntemle zaman aralÄ±ÄŸÄ± vererek gÃ¶ndermeye baÅŸlasÄ±n;
msg.payload={"method": "cmd", "params": {"type": "off", "target": "all"}}
// EÄŸer hÄ±z bilgisi varsa onu da ekle (sinamics'lerle ilgili)
yukarÄ±daki deÄŸiÅŸikliklerde mevcut koddaki yÃ¶ntemleri koruyalÄ±m.
--------------
kodlarÄ± flow'a yÃ¼kle
restore dene
thingsboard ile dene
analog_inputs'u dene
digital_inputs'u dene
service enable yap
settings yap dosyalara bak
pi connect dene
kart kopyala
----------------------
mv flows.json flows.json.bak      # mevcut dosyayÄ± yedekle
nano flows.json
-------------------------
actuators'un sinamics'lerle ilgili method: "evt" olarak Ã§Ä±kardÄ±ÄŸÄ± mesaj yapÄ±sÄ±nÄ± deÄŸiÅŸtirmeliyim.
aktiflik/yÃ¶n komutlarÄ± geldiÄŸinde ÅŸÃ¶yle Ã§Ä±karÄ±yor, bu hÄ±zÄ± gÃ¶stermiyor oluyor:
msg.payload={"method": "evt", "params": {"type": "roof", "val": "forward_on"}}
hÄ±z komutlarÄ±nda ise ÅŸÃ¶yle bir ÅŸey Ã§Ä±karÄ±yor, bu da sorunlu.
msg.payload={"method": "evt", "params": {"type": "roof", "val":{"speed":{"set_point":100}}}}
benim flow'da bir de mqtt_manager fonksiyon nodu var, tekil evt'leri ve method: "evt", params: {type: "telemetry_periodical", val: null} olarak gelenleri aynÄ± mesaj yapÄ±syla gÃ¶nderiyor, tasarÄ±mÄ± Ã¶yledir.
acaba actuators'da nasÄ±l bir dÃ¼zenleme yapsam?
sinamics'ler iÃ§in Ã§Ä±kan mesajlarda hem aktiflik/yÃ¶n ve hem de hÄ±z bilgilerini daima birlikte mi Ã§Ä±karsak, hangisi deÄŸiÅŸmiÅŸ olursa olsun fark etmeden?
yani sinamics mesajlarÄ± actuators'den daima ÅŸu Ã¶rnek yapÄ±daki gibi mi Ã§Ä±ksa iyi olur, ne dersin?
msg.payload={"method": "evt", "params": {"type": "roof", "speed":{"set_point":100}, "val": "forward_on"}}
Ã¶rneÄŸin flow context'inde ÅŸÃ¶yle yer alÄ±yorlar:
roof: {speed: {set_point: 100}, val: "off"}
actuators'da bu dÃ¼zenlemeyi yaptÄ±ktan sonra mqtt_manager nodunu da eÄŸer gerekiyorsa uyumlu hale getirelim, Ã¶enemli bir sorun oldu bu bana.

istersen birazdan actuators ve flow_context kodlarÄ±nÄ± tekrar gÃ¶ndereyim sana.
not: flow_context nodunu artÄ±k flow'da kullanmÄ±yorum(artÄ±k context filememory2den yÃ¼kleniyor, kalÄ±cÄ±dÄ±r), ama iÃ§eriÄŸi oradan gÃ¶rebiliyoruz.





[
    {
        "id": "2d8538969c77a5df",
        "type": "tab",
        "label": "my_flow",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c3488bd8821ff6d8",
        "type": "modbus-client",
        "name": "203_115200_tcp_rtu_rel_out",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.203",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "2206e55e928c8b8f",
        "type": "modbus-client",
        "name": "201_115200_tcp_rtu_dig_inp",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.201",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e707d8a8f03b29cf",
        "type": "modbus-client",
        "name": "204_9600_tcp_rtu_ang_inp_eng_met",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.204",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "9703a3f2808e2fa6",
        "type": "modbus-client",
        "name": "202_9600_tcp_rtu_sinamics",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.202",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e1d018cea69d77b6",
        "type": "mqtt-broker",
        "name": "mqtt_broker",
        "broker": "54.208.96.163",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0719549b97c80402",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "relays_writer",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "server": "c3488bd8821ff6d8",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "10",
        "x": 890,
        "y": 660,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "ecf66dea2db91aea",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs",
        "func": "const ctx = context;\nconst flowData = flow.get(\"flow\");\n\nconst labels = flowData.config.labels;\nconst digitalInputs = flowData.config.io.digital_inputs;\nconst channels = digitalInputs.channels;\n\n// Giriş verisi: [<number>] şeklinde array\nconst rawVal = msg.payload?.[0];\nif (typeof rawVal !== \"number\") return null;\n\n// Hafıza başlat (bit geçmişi)\nif (!ctx.get(\"history\")) {\n  ctx.set(\"history\", {});\n}\nconst history = ctx.get(\"history\");\n\n// Değişen input'lar buraya\nconst changed = [];\n\nfor (const [key, def] of Object.entries(channels)) {\n  const bitIndex = def.map;\n  const bitVal = (rawVal >> bitIndex) & 1;\n  const newVal = labels[String(bitVal === 1)]; // \"true\"/\"false\" string olarak erişim\n\n  if (!history[key]) {\n    history[key] = [newVal];\n    // İlk seferde runtime'a yaz\n    if (flowData.runtime[key].val !== newVal) {\n      flowData.runtime[key].val = newVal;\n      changed.push({\n        payload: {\n          method: \"evt\",\n          params: { type: key, val: newVal }\n        }\n      });\n    }\n    continue;\n  }\n\n  const prevStates = history[key];\n  prevStates.push(newVal);\n  if (prevStates.length > 2) prevStates.shift();\n\n  const [prev, curr] = prevStates;\n\n  if (prev === curr && flowData.runtime[key].val !== curr) {\n    flowData.runtime[key].val = curr;\n    changed.push({\n      payload: {\n        method: \"evt\",\n        params: { type: key, val: curr }\n      }\n    });\n    history[key] = [curr];\n  } else {\n    history[key] = prevStates;\n  }\n}\n\nctx.set(\"history\", history);\n\n// Runtime'ı sadece değişiklik varsa yaz\nif (changed.length > 0) {\n  flow.set(\"flow\", flowData);\n  return [changed];\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 220,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "db72d07653f1bbe9",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs",
        "func": "const flowData = flow.get(\"flow\");\nconst analogInputs = flowData.config.io.analog_inputs;\nconst channels = analogInputs.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    const raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    // factor varsa uygula\n    const factor = (typeof def.factor === \"number\") ? def.factor : 1;\n    const rawEff = raw * factor;\n\n    let scaled = rawEff;\n    if (def.scale) {\n        const { in_min, in_max, out_min, out_max } = def.scale;\n        scaled = ((rawEff - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;\n    }\n    scaled = parseFloat(scaled.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(scaled - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'te sakla\n        lastVals[key] = scaled;\n\n        // Flow runtime'a yaz\n        flowData.runtime[key].val = scaled;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: scaled\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 280,
        "wires": [
            [
                "54a9a79a7c485b62",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "1b7f0d4c81a3700c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter",
        "func": "const flowData = flow.get(\"flow\");\nconst channels = flowData.config.energy_meter.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    let raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    // Çarpan uygula (ör: factor)\n    if (def.factor) {\n        raw *= def.factor;\n    }\n\n    raw = parseFloat(raw.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(raw - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'e son değeri yaz\n        lastVals[key] = raw;\n\n        // Flow context runtime'a yaz\n        flowData.runtime[key].val = raw;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: raw\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 380,
        "wires": [
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "8d59f82c1f6e0d51",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs_getter",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "2206e55e928c8b8f",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 380,
        "y": 220,
        "wires": [
            [
                "ecf66dea2db91aea"
            ],
            []
        ]
    },
    {
        "id": "14e917ac3699c006",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "0.1",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 11, \"address\": 144 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 130,
        "y": 220,
        "wires": [
            [
                "8d59f82c1f6e0d51"
            ]
        ]
    },
    {
        "id": "532186e49e9bd932",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "10",
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 12, \"address\": 160 , \"quantity\": 8}",
        "payloadType": "json",
        "x": 140,
        "y": 280,
        "wires": [
            [
                "890e808611421ece"
            ]
        ]
    },
    {
        "id": "d1db2b67e2afbffe",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": "30",
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 2, \"address\": 29 , \"quantity\": 2}",
        "payloadType": "json",
        "x": 130,
        "y": 380,
        "wires": [
            [
                "6f4e90bab79df245"
            ]
        ]
    },
    {
        "id": "6f4e90bab79df245",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_getter",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 380,
        "y": 380,
        "wires": [
            [
                "1b7f0d4c81a3700c"
            ],
            []
        ]
    },
    {
        "id": "155eb5f34a3f5ca3",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "sin_writer",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "9703a3f2808e2fa6",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 880,
        "y": 600,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "0defb2d453130745",
        "type": "mqtt in",
        "z": "2d8538969c77a5df",
        "name": "mqtt_in",
        "topic": "v1/devices/me/rpc/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "e1d018cea69d77b6",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 870,
        "y": 160,
        "wires": [
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "b7b87a40dd91a021",
        "type": "mqtt out",
        "z": "2d8538969c77a5df",
        "name": "mqtt_out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "e1d018cea69d77b6",
        "x": 1320,
        "y": 160,
        "wires": []
    },
    {
        "id": "c3f4a0e8f8030852",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "flow_context",
        "func": "const payload = msg.payload || {};\nconst method = payload.method || \"\";\nconst params = payload.params || {};\n\nif (!(method === \"cmd\" && params.type === \"inject\" && params.target === \"flow_context\")) {\n    return null; // diğer tüm mesajları görmezden gel\n}\n\nconst flowData = {\n  config: {\n    labels: {true: \"on\", false: \"off\"},\n    io: {\n      queue_interval: 100,\n      digital_inputs: {\n        config_node: \"201_115200_tcp_rtu_dig_inp\",\n        unitid: 11,\n        channels: {        \n          oxygen_detector_dig_low: {map: 0},\n          oxygen_detector_dig_high: {map: 1},\n          //stop_button: {map: 15}\n        }      \n      },\n      analog_inputs: {\n        config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n        unitid: 12,        \n        channels: {\n          humidity: {map: 6, change: 3, factor: 0.01, scale: {in_min: 4, in_max: 20, out_min: 0, out_max: 100}, pro: {humidity_detector_ang: {low: 30, high: 60}}},\n          oxygen: {map: 7, change: 0.2, factor: 0.01, scale: {in_min: 4.81, in_max: 20, out_min: 1.63, out_max: 21.53}} // +0.63 offset to out_min 1 and out_max 20.9\n        }\n      },\n      relay_outputs_1: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 13,\n        channels: {\n          roof_forward_contactor: {map: 0},\n          roof_reverse_contactor: {map: 1},\n          light: {map: 6},\n          water_valve: {map: 7}\n        }\n      },\n      relay_outputs_2: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 14,\n        channels: {\n          loader_forward_valve: {map: 4},\n          loader_reverse_valve: {map: 5},\n          loader_motor: {map: 6},\n          power_contactor: {map: 7}\n        }\n      },\n      relay_groups: {\n        roof: {\n          roof_forward_contactor: null,\n          roof_reverse_contactor: null,\n        },\n        loader: {\n          loader_motor: null,\n          loader_forward_valve: null,\n          loader_reverse_valve: null    \n        }\n      }\n    },\n    energy_meter: {\n      config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n      unitid: 2,      \n      channels: {\n        kwh: {map: 0, factor: 0.01, change: 2}\n      }\n    },  \n    sinamics: {\n      config_node: \"202_9600_tcp_rtu_sinamics\",\n      channels: {\n        fan: {unitid: 12},\n        discharger: {unitid: 14}\n      },\n      command_words: {forward: 1151, reverse: 3199, off: 1150, fault_ack_res: 1150, fault_ack_set: 1278},\n      status_word: {\n        work: {map: 2},\n        fault: {map: 3},\n        warning: {map: 7},\n        direction: {map: 14}\n      },\n      speed_max: 16384, // modbus send >> set_point / 100 * speed_max\n      queue_interval: 100,\n      power_up_time: 15000\n    },\n    timers: {      \n      fan_pwm: {\n        form: \"pwm\",\n        t_duty: 10, t_cycle: 180, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"forward\", target: \"fan\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"fan\"}, port: 2}\n        }\n      },\n      light_pulse: {\n        form: \"delay\", duration: 2, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"light\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"light\"}, port: 2}\n        }\n      },\n      water_valve_pwm: {\n        form: \"pwm\", t_duty: 15, t_cycle: 1440, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"water_valve\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"water_valve\"}, port: 2}\n        }        \n      },\n      day_counter: {\n        form: \"counter\", direction: \"down\", interval: 1, base: 21, signal: 3, unit: \"d\",\n        pass: {\n          2: {method: \"cmd\", params: {type: \"dry\", target: \"fsm\"}, port: 1},\n          3: {method: \"cmd\", params: {type: \"end\", target: \"fsm\"}, port: 1},\n          4: {method: \"evt\", params: {type: \"day\"}, port: 3} // val buradan sabit gelmeyecek\n        }             \n      }\n    }\n  },\n  runtime: {\n    oxygen: {val: 0},\n    oxygen_detector_dig_low: {val: \"on\"},\n    oxygen_detector_dig_high: {val: \"on\"},\n    humidity: {val: 0}, \n    humidity_detector_ang_low: {val: \"on\"},\n    humidity_detector_ang_high: {val: \"on\"},\n    kwh: {val: 0},\n    //stop_button: {val: \"on\"},\n    power_contactor: {val: \"off\"},\n    water_valve: {val: \"off\"},  \n    light: {val: \"off\"},\n    roof: {val: \"off\"},\n    roof_forward_contactor: {val: \"off\"},\n    roof_reverse_contactor: {val: \"off\"},\n    loader: {val: \"off\"},\n    loader_forward_valve: {val: \"off\"},\n    loader_reverse_valve: {val: \"off\"},\n    loader_motor: {val: \"off\"},\n    fan: {val: \"off\", speed_set_point: 100},\n    discharger: {val: \"off\", speed_set_point: 100},\n    fsm: {val: \"end\"}\n  }\n}\n\nflow.set(\"flow\", flowData);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 160,
        "wires": [
            [
                "beb4346081038e85"
            ]
        ]
    },
    {
        "id": "2467bf030b733b1e",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "flow_context_inject",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"method\": \"cmd\", \"params\": {\"type\": \"inject\", \"target\": \"flow_context\"}}",
        "payloadType": "json",
        "x": 130,
        "y": 160,
        "wires": [
            [
                "c3f4a0e8f8030852"
            ]
        ]
    },
    {
        "id": "8701a07643f54a7b",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "timer_manager",
        "func": "const flowData = flow.get(\"flow\");\nconst timers = flowData.config.timers;\n\nconst method = msg?.payload?.method || msg?.method;\nconst params = msg?.payload?.params || msg?.params || {};\nconst target = params.target;\nconst type = params.type;\n\nconst out = [[], [], []]; // Port 1,2,3\nlet runtime = context.get(\"runtime\") || {};\n\nfunction toMs(val, unit) {\n  const map = { s: 1000, min: 60000, h: 3600000, d: 86400000 };\n  return val * (map[unit] ?? 1000);\n}\n\nfunction pushMessage(timer, passKey, out, runtime = {}, target = null) {\n  const entry = timer.pass?.[passKey];\n  if (!entry) return;\n\n  const message = RED.util.cloneMessage(entry);\n  const port = (entry.port ?? 0) - 1;\n  if (port < 0 || port > 2) return;\n\n  delete message.port;\n\n  if (message.params && target && runtime[target]) {\n    for (const [key, val] of Object.entries(message.params)) {\n      if (val === null && runtime[target][key] !== undefined) {\n        message.params[key] = runtime[target][key];\n      } else if (typeof val === \"object\" && val !== null && \"val\" in val) {\n        message.params[key].val = runtime[target].count;\n      }\n    }\n\n    if (timer.form === \"counter\" && passKey === 4 && message.params.val === undefined) {\n      message.params.val = runtime[target].count;\n    }\n  }\n\n  out[port].push({ payload: message });\n}\n\nfunction timerOn(timer, rt, now, out, target, forcedCount = null) {\n  rt.state = \"on\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.on_time = now;\n      rt.done = false;\n      rt.phase_until = now + toMs(timer.duration, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"pwm\":\n      rt.on_time = now;\n      rt.phase = \"a\";\n      rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"counter\":\n      rt.on_time = now;\n      rt.count = forcedCount !== null ? forcedCount : timer.base;\n      rt.next_time = now + toMs(timer.interval, timer.unit);\n\n      const entry4 = timer.pass?.[4];\n      if (entry4) {\n        entry4.params = entry4.params || {};\n        delete entry4.params.val; // runtime[target].count koyabilmesi için\n      }\n\n      pushMessage(timer, 1, out, runtime, target);\n      pushMessage(timer, 4, out, runtime, target);\n      break;\n  }\n}\n\nfunction timerOff(timer, rt, out, target, suppressMessages = false) {\n  rt.state = \"off\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.done = true;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"pwm\":\n      rt.phase = null;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"counter\":\n      rt.count = 0;\n      if (!suppressMessages) {\n        pushMessage(timer, 3, out, runtime, target);\n        pushMessage(timer, 4, out, runtime, target);\n      }\n\n      // day_counter için evt day 0 mesajı\n      if (target === \"day_counter\") {\n        out[2].push({\n          payload: {\n            method: \"evt\",\n            params: { type: \"day\", val: 0 }\n          }\n        });\n      }\n      break;\n  }\n\n  // Genel reset\n  rt.on_time = null;\n  rt.next_time = null;\n  rt.phase_until = null;\n  rt.phase = null;\n}\n\nfunction timerTick(timers, runtime, now, out) {\n  for (const [key, timer] of Object.entries(timers)) {\n    const rt = runtime[key];\n    if (!rt || rt.state !== \"on\") continue;\n\n    switch (timer.form) {\n      case \"delay\":\n        if (!rt.done && now >= rt.phase_until) {\n          rt.done = true;\n          pushMessage(timer, 2, out);\n        }\n        break;\n\n      case \"pwm\":\n        if (now >= rt.phase_until) {\n          if (rt.phase === \"a\") {\n            rt.phase = \"b\";\n            rt.phase_until = now + toMs(timer.t_cycle - timer.t_duty, timer.unit);\n            pushMessage(timer, 2, out);\n          } else {\n            rt.phase = \"a\";\n            rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n            pushMessage(timer, 1, out);\n          }\n        }\n        break;\n\n      case \"counter\":\n        if (now >= rt.next_time && rt.count > 0) {\n          rt.count -= 1;\n          rt.next_time = now + toMs(timer.interval, timer.unit);\n\n          if (timer.signal !== undefined && rt.count === timer.signal) {\n            pushMessage(timer, 2, out, runtime, key);\n          }\n\n          pushMessage(timer, 4, out, runtime, key);\n\n          if (rt.count === 0) {\n            rt.state = \"off\";\n            pushMessage(timer, 3, out, runtime, key);\n\n            if (key === \"day_counter\") {\n              out[2].push({\n                payload: {\n                  method: \"evt\",\n                  params: { type: \"day\", val: 0 }\n                }\n              });\n            }\n\n            rt.on_time = null;\n            rt.next_time = null;\n            rt.phase_until = null;\n            rt.phase = null;\n          }\n        }\n        break;\n    }\n  }\n}\n\n// --- CMD handling ---\nif (method === \"cmd\") {\n  // --- Special skip for day_counter ---\n  if (type === \"skip\" && target === \"day_counter\") {\n    if (!runtime[target]) runtime[target] = {};\n    const rt = runtime[target];\n\n    timerOn(timers[target], rt, Date.now(), out, target, timers[target].signal);\n\n  } else if (timers[target]) {\n    if (!runtime[target]) runtime[target] = {};\n    if (type === \"on\") {\n      timerOn(timers[target], runtime[target], Date.now(), out, target);\n    } else if (type === \"off\") {\n      timerOff(timers[target], runtime[target], out, target);\n    }\n  } else if (type === \"off\" && target === \"timers\") {\n    for (const [key, timer] of Object.entries(timers)) {\n      if (!runtime[key]) runtime[key] = {};\n      timerOff(timer, runtime[key], out, key, true);\n    }\n  } else {\n    out[1].push(msg);\n  }\n\n} else if (method === \"evt\" && type === \"timer_tick\") {\n  timerTick(timers, runtime, Date.now(), out);\n} else {\n  out[1].push(msg);\n}\n\ncontext.set(\"runtime\", runtime);\n\nreturn out.some(arr => arr.length) ? out : null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 340,
        "wires": [
            [
                "22442867c06e05b8",
                "664d95256e2c36ad"
            ],
            [
                "8b077bd685e2a66c",
                "d7108d799a8d52c2",
                "03585ea38892f6a5"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "1156fe8823a93a99",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "timer_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"method\": \"evt\", \"params\": {\"type\": \"timer_tick\", \"val\": null}}",
        "payloadType": "json",
        "x": 1110,
        "y": 280,
        "wires": [
            [
                "8701a07643f54a7b"
            ]
        ]
    },
    {
        "id": "22442867c06e05b8",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "fsm",
        "func": "const flowData = flow.get(\"flow\");\nconst runtime = flowData.runtime;\nlet currentState = runtime.fsm.val;\n\nconst payload = msg.payload;\nif (!payload || typeof payload !== \"object\") return null;\n\nconst method = payload.method;\nconst params = payload.params || {};\nconst type = params.type;\nconst target = params.target;\nconst val = params.val;\n\nconst outputs = [[], []];\n\nfunction transition(toState) {\n  if (toState !== currentState) {\n    currentState = toState;\n    flowData.runtime.fsm.val = currentState;\n    flow.set(\"flow\", flowData);\n    sendEvt(\"fsm\", { val: currentState });\n  }\n}\n\nfunction sendCmd(type, target, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"cmd\",\n      params: { type, target, ...extraParams }\n    }\n  };\n  outputs[0].push(msg);\n}\n\nfunction sendEvt(type, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"evt\",\n      params: { type, ...extraParams }\n    }\n  };\n  outputs[1].push(msg);\n}\n\n// --- Ana mesaj işleme ---\nif (method === \"evt\") {\n\n  if (type === \"oxygen_detector_dig_low\") {\n    if (val === \"off\") {\n      if (currentState === \"start\") {\n        sendCmd(\"on\", \"fan_pwm\");\n      }      \n    }\n  } else if (type === \"oxygen_detector_dig_high\") {\n    if (val === \"off\") {\n      if (currentState === \"start\") {\n        sendCmd(\"off\", \"fan_pwm\");\n      }      \n    }\n  } else if (type === \"humidity_detector_ang_low\") {\n    if (val === \"off\") {\n      if (currentState === \"start\") {\n        sendCmd(\"on\", \"water_valve_pwm\");\n      }      \n    }\n  } else if (type === \"humidity_detector_ang_high\") {\n    if (val === \"off\") {\n      if (currentState === \"start\") {\n        sendCmd(\"off\", \"water_valve_pwm\");\n      }      \n    }\n  }\n\n} else if (method === \"cmd\") {\n\n  if (target === \"fsm\") {\n\n    if (type === \"start\") {\n      if (runtime.oxygen_detector_dig_high === \"on\") {\n        sendCmd(\"on\", \"fan_pwm\");\n      } else {\n        sendCmd(\"off\", \"fan_pwm\");\n      }\n      if (runtime.humidity_detector_ang_high === \"on\") {\n        sendCmd(\"on\", \"water_valve_pwm\");\n      } else {\n        sendCmd(\"off\", \"water_valve_pwm\");\n      }    \n      sendCmd(\"on\", \"day_counter\");\n      transition(\"start\");\n\n    } else if (type === \"dry\") {      \n      sendCmd(\"on\", \"fan_pwm\");\n      sendCmd(\"off\", \"water_valve_pwm\");\n      sendCmd(\"skip\", \"day_counter\");\n      transition(\"dry\");\n\n    } else if (type === \"end\") {\n      sendCmd(\"off\", \"timers\");\n      sendCmd(\"off\", \"actuators\");\n      transition(\"end\");\n    }\n\n  } else {\n    outputs[0].push(msg);\n  }\n}\n\nreturn outputs;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 300,
        "wires": [
            [
                "8701a07643f54a7b",
                "c191c7397b21bd4f"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "0b3654ab51cfd27c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager",
        "func": "// Sabitler\nconst TELEMETRY_TOPIC = \"v1/devices/me/telemetry\";\nconst RPC_RESPONSE_PREFIX = \"v1/devices/me/rpc/response/\";\n\nconst topic = msg.topic || \"\";\nconst payload = msg.payload || {};\nconst method = payload?.method || \"\";\nconst params = payload?.params || {};\n\nconst flowData = flow.get(\"flow\") || {};\n\n// Güvenli msgId\nconst msgId = (topic.split(\"/\").pop()) || \"unknown\";\n\nfunction getValueAtPath(obj, path) {\n    if (!Array.isArray(path) || path.length === 0) return obj;\n    return path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : null), obj);\n}\n\nfunction setValueAtPath(obj, path, value) {\n    if (!Array.isArray(path) || path.length === 0) {\n        throw new Error(\"Invalid path for set\");\n    }\n    let current = obj;\n    for (let i = 0; i < path.length - 1; i++) {\n        const key = path[i];\n        if (!(key in current) || typeof current[key] !== 'object' || current[key] === null) {\n            current[key] = {};\n        }\n        current = current[key];\n    }\n    current[path[path.length - 1]] = value;\n}\n\nfunction buildRpcResponse(id, content) {\n    return {\n        topic: RPC_RESPONSE_PREFIX + id,\n        payload: content\n    };\n}\n\nfunction buildTelemetryMsg(content) {\n    return {\n        topic: TELEMETRY_TOPIC,\n        payload: content\n    };\n}\n\n// 1) EVT — esnek versiyon\nif (method === \"evt\") {\n    const subType = params?.type;\n\n    // Geri kalan tüm evt’ler için esnek format:\n    // params.type dışındaki her şeyi otomatik kapsar\n    if (subType) {\n        // type dışındaki tüm alanları bir objeye kopyala\n        const { type, ...rest } = params;\n        // örn. { motor1: {x:10,y:20}} gibi\n        const formatted = { [subType]: rest };\n        return [buildTelemetryMsg(formatted), null, null];\n    }\n\n    // params.type yoksa: params doğrudan telemetry payload olarak gönderilir\n    return [buildTelemetryMsg(params), null, null];\n}\n\n// 2) CMD\nif (method === \"cmd\") {\n    // Özel \"inject → flow_context\" komutu kontrolü\n    if (params?.type === \"inject\" && params?.target === \"flow_context\") {\n        return [buildRpcResponse(msgId, { response: true }), null, { payload }];\n    }\n    // Normal cmd\n    return [buildRpcResponse(msgId, { response: true }), { payload }, null];\n}\n\n// 3) set/get tipi dot-path'li method'lar\nconst [action, ...pathParts] = method.split(\".\");\n\nif (action === \"get\") {\n    try {\n        const value = getValueAtPath(flowData, pathParts);\n        return [buildRpcResponse(msgId, { value: value === undefined ? null : value }), null, null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null, null];\n    }\n}\n\nif (action === \"set\") {\n    try {\n        if (!pathParts || pathParts.length === 0) {\n            return [buildRpcResponse(msgId, { error: \"Invalid set path\" }), null, null];\n        }\n        const newValue = params?.value;\n        setValueAtPath(flowData, pathParts, newValue);\n        flow.set(\"flow\", flowData);\n        return [buildRpcResponse(msgId, { response: true }), null, null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null, null];\n    }\n}\n\n// Bilinmeyen method'lar\nreturn [null, null, null];\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 160,
        "wires": [
            [
                "b7b87a40dd91a021",
                "4374c2d006a762aa"
            ],
            [
                "22442867c06e05b8",
                "a8d45eb24d6240ac"
            ],
            [
                "c3f4a0e8f8030852"
            ]
        ]
    },
    {
        "id": "54a9a79a7c485b62",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst analogChannels = flowData.config.io.analog_inputs.channels;\nconst runtime = flowData.runtime;\n\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || typeof val !== \"number\") return null;\n\nconst channelDef = analogChannels[key];\nif (!channelDef || !channelDef.pro) return null;\n\nconst changed = [];\n\n// örn. humidity.pro = { humidity_detector_ang: { low: 30, high: 60 } }\nfor (const [detectorKey, thresholds] of Object.entries(channelDef.pro)) {\n    if (!thresholds || typeof thresholds.low !== \"number\" || typeof thresholds.high !== \"number\") continue;\n\n    // 2 key oluştur: ..._ang_low ve ..._ang_high\n    const lowKey = `${detectorKey}_low`;\n    const highKey = `${detectorKey}_high`;\n\n    // önce mevcut durumları oku\n    const prevLow = runtime[lowKey]?.val ?? \"on\";\n    const prevHigh = runtime[highKey]?.val ?? \"on\";\n\n    let newLow = prevLow;\n    let newHigh = prevHigh;\n\n    // low alanı için kural: val < low → off, aksi → on\n    if (val < thresholds.low) newLow = \"off\";\n    else newLow = \"on\";\n\n    // high alanı için kural: val > high → off, aksi → on\n    if (val > thresholds.high) newHigh = \"off\";\n    else newHigh = \"on\";\n\n    // değişim varsa runtime'ı güncelle ve mesaj oluştur\n    if (newLow !== prevLow) {\n        runtime[lowKey] = { val: newLow };\n        changed.push({\n            payload: {\n                method: \"evt\",\n                params: { type: lowKey, val: newLow }\n            }\n        });\n    }\n\n    if (newHigh !== prevHigh) {\n        runtime[highKey] = { val: newHigh };\n        changed.push({\n            payload: {\n                method: \"evt\",\n                params: { type: highKey, val: newHigh }\n            }\n        });\n    }\n}\n\n// yalnızca değişiklik varsa flow context'i güncelle\nif (changed.length) {\n    flow.set(\"flow\", flowData);\n    return [changed];\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 320,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "890e808611421ece",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs_getter",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 380,
        "y": 280,
        "wires": [
            [
                "db72d07653f1bbe9"
            ],
            []
        ]
    },
    {
        "id": "341579e5df71af16",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "power_on",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "{\"method\": \"cmd\", \"params\": {\"type\": \"on\", \"target\": \"power\"}}",
        "payloadType": "json",
        "x": 880,
        "y": 340,
        "wires": [
            [
                "22442867c06e05b8"
            ]
        ]
    },
    {
        "id": "beb4346081038e85",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "flow_context_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 380,
        "y": 120,
        "wires": []
    },
    {
        "id": "4374c2d006a762aa",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager_1_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 100,
        "wires": []
    },
    {
        "id": "c191c7397b21bd4f",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "fsm_1_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 900,
        "y": 380,
        "wires": []
    },
    {
        "id": "664d95256e2c36ad",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "timer_manager_1_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 400,
        "wires": []
    },
    {
        "id": "0dfb91744e6dc6e8",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "sin_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": "20",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 100,
        "y": 540,
        "wires": [
            [
                "7d089b8f40676014"
            ]
        ]
    },
    {
        "id": "7d089b8f40676014",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "sin_read",
        "func": "// === SIN_READ..JS ===\n// Bu fonksiyon nodu, her tetiklendiğinde tüm sinamics sürücülerinin\n// ZSW Status Word registerlerini okumak için mesaj üretir.\n// Çıkışı sin_queue'ya bağlıdır.\n\nconst flowData = flow.get(\"flow\");\nif (!flowData?.config?.sinamics) return null;\n\n// Sürücü listesi flow context'ten alınıyor\nconst sinamicsChannels = flowData.config.sinamics.channels;\nconst address = 109;   // ZSW Status Word register adresi\nconst quantity = 1;    // Okunacak register sayısı\n\n// Mesajları oluştur\nconst msgs = Object.entries(sinamicsChannels).map(([name, cfg]) => {\n    const unitid = cfg.unitid;\n\n    return {\n        unitid: unitid, // ✅ üst property olarak\n        payload: {\n            fc: 3,\n            unitid: unitid,  // yine payload içinde de bırakıyoruz (Modbus için)\n            address: address,\n            quantity: quantity\n        }\n    };\n});\n\n// Tek çıkıştan dört mesaj olarak göndermek için:\nreturn [msgs];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 540,
        "wires": [
            [
                "23a2e5b697446475"
            ]
        ]
    },
    {
        "id": "8b077bd685e2a66c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "sin_write",
        "func": "// === SIN_WRITE.JS ===\n// Bu node gelen \"cmd\" mesajlarına göre sinamics sürücülerine modbus write mesajları oluşturur\n// Çıkışı sin_queue'ya bağlı olacak, evt mesajları üretmeyecek\n\nconst flowData = flow.get(\"flow\");\nif (!flowData || !flowData.config || !flowData.config.sinamics) return null;\n\nconst config = flowData.config;\nconst runtime = flowData.runtime;\nconst payload = msg.payload;\n\nif (!payload || payload.method !== \"cmd\" || typeof payload.params !== \"object\") return null;\n\nconst { type, target, set_point } = payload.params;\nif (!type || !target) return null;\n\nconst sinamicsChannels = config.sinamics.channels;\nconst commandWords = config.sinamics.command_words;\nconst speedMax = config.sinamics.speed_max || 16384;\nconst powerUpTime = config.sinamics.power_up_time || 15000;\n\n// Speed helper (default=100)\nfunction getSpeedValue(sp) {\n    const spVal = (typeof sp === \"number\") ? sp : 100; // default 100\n    return Math.round(spVal / 100 * speedMax);\n}\n\n// Modbus write mesajı oluştur\nfunction createModbusMsg(value, unitid, address, quantity = 1) {\n    return { payload: { value, fc: 6, unitid, address, quantity } };\n}\n\n// 🔹 TOPLU OFF – sadece off komut word gönderir ve runtime günceller\nfunction setAllOff(runtimeObj) {\n    const msgs = [];\n    for (const [name, sin] of Object.entries(sinamicsChannels)) {\n        const unitid = sin.unitid;\n\n        const offVal = commandWords.off;\n        if (offVal != null) {\n            msgs.push(createModbusMsg(offVal, unitid, 99, 1));\n        }\n\n        // Runtime güncelle\n        if (!runtimeObj[name]) runtimeObj[name] = {};\n        runtimeObj[name].val = \"off\";\n    }\n    return msgs;\n}\n\n// 🔹 TOPLU SPEED – her cihaz için speed_set_point gönderir\nfunction setAllSpeed(runtimeObj) {\n    const msgs = [];\n    for (const [name, sin] of Object.entries(sinamicsChannels)) {\n        const unitid = sin.unitid;\n\n        const speedValue = getSpeedValue(runtimeObj[name]?.speed_set_point);\n        msgs.push(createModbusMsg(speedValue, unitid, 100, 1));\n    }\n    return msgs;\n}\n\n// 🔹 TOPLU FAULT ACK\nfunction ackAllFault() {\n    const msgs = [];\n    const faultAckSet = commandWords.fault_ack_set;\n    const faultAckRes = commandWords.fault_ack_res;\n\n    if (faultAckSet == null || faultAckRes == null) {\n        node.warn(\"fault_ack_set veya fault_ack_res tanımlı değil.\");\n        return msgs;\n    }\n\n    for (const [name, sin] of Object.entries(sinamicsChannels)) {\n        msgs.push(createModbusMsg(faultAckSet, sin.unitid, 99, 1));\n    }\n    for (const [name, sin] of Object.entries(sinamicsChannels)) {\n        msgs.push(createModbusMsg(faultAckRes, sin.unitid, 99, 1));\n    }\n    return msgs;\n}\n\n// Mesajları tek çıkışa gönder\nfunction sendMsgs(msgs) {\n    for (const m of msgs) node.send(m);\n}\n\nlet modbusMsgs = [];\n\n/* 🔹 Fault Acknowledgement tüm sinamics için */\nif (type === \"fault_ack\" && target === \"sinamics\") {\n    modbusMsgs = ackAllFault();\n    sendMsgs(modbusMsgs);\n\n/* 🔹 Actuators OFF – eski davranış korunuyor */\n} else if (type === \"off\" && target === \"actuators\") {\n    modbusMsgs = [\n        ...setAllOff(runtime),\n        ...setAllSpeed(runtime)\n    ];\n    sendMsgs(modbusMsgs);\n\n/* 🔹 Power OFF – hiçbir işlem yapmadan çık, ama if dursun */\n} else if (type === \"off\" && target === \"power\") {\n    // İstenilen şekilde hiçbir şey yapılmıyor\n    return null;\n\n/* 🔹 Power ON – önce bekle, sonra off + speed gönder (runtime’ı güncel çekerek) */\n} else if (type === \"on\" && target === \"power\") {\n    setTimeout(() => {\n        // 10 sn sonra güncel flowData çek\n        const currentFlowData = flow.get(\"flow\") || {};\n        if (!currentFlowData.runtime) currentFlowData.runtime = {};\n\n        const msgs = [\n            ...setAllOff(currentFlowData.runtime),\n            ...setAllSpeed(currentFlowData.runtime)\n        ];\n        sendMsgs(msgs);\n\n        // güncel runtime’ı tekrar kaydet\n        flow.set(\"flow\", currentFlowData);\n    }, powerUpTime);\n\n/* 🔹 Bireysel sinamics hedefleri (forward/reverse/off/speed) */\n} else if (sinamicsChannels[target]) {\n    const unitid = sinamicsChannels[target].unitid;\n\n    if ([\"forward\", \"reverse\", \"off\"].includes(type)) {\n        // 1️⃣ Speed register (speed_set_point, default 100) — önce gönder\n        const speedValue = getSpeedValue(runtime[target]?.speed_set_point);\n        modbusMsgs.push(createModbusMsg(speedValue, unitid, 100, 1));\n\n        // 2️⃣ Komut word (forward/reverse/off) — sonra gönder\n        const value = commandWords[type];\n        if (value != null) {\n            modbusMsgs.push(createModbusMsg(value, unitid, 99, 1));\n            if (!runtime[target]) runtime[target] = {};\n            runtime[target].val = type;\n        }\n    }\n\n    if (type === \"speed\" && typeof set_point === \"number\") {\n        const speedValue = getSpeedValue(set_point);\n        modbusMsgs.push(createModbusMsg(speedValue, unitid, 100, 1));\n        if (!runtime[target]) runtime[target] = {};\n        runtime[target].speed_set_point = set_point;   // artık speed_set_point\n    }\n\n    sendMsgs(modbusMsgs);\n} else {\n    return null; // Sadece sinamics target'larını işler\n}\n\n// güncel flowData’yı kaydet\nflow.set(\"flow\", flowData);\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 580,
        "wires": [
            [
                "23a2e5b697446475"
            ]
        ]
    },
    {
        "id": "23a2e5b697446475",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "sin_queue",
        "func": "/****************************************************\n * sin_queue – dispatcher (write öncelikli)\n * Port 1 → sin_getter  (fc:3 read)\n * Port 2 → sin_writer  (fc:6 write)\n ****************************************************/\n\n// --- Config’ten queue_interval çek ---\nlet flowData = flow.get(\"flow\") || {};\nlet queueInterval = 100; // default\nif (flowData.config?.sinamics?.queue_interval) {\n    queueInterval = flowData.config.sinamics.queue_interval;\n}\n\n// --- Kuyrukları node context’te tut ---\nlet queueWrite  = context.get(\"queueWrite\")  || [];\nlet queueRead   = context.get(\"queueRead\")   || [];\nlet timerActive = context.get(\"timerActive\") || false;\n\n// --- fc alanını payload’dan çek ---\nconst fc = msg?.payload?.fc;\n\n// --- Mesajı ilgili kuyruğa at ---\nif (fc === 6) {\n    // Write mesajı\n    queueWrite.push(msg);\n} else if (fc === 3) {\n    // Read mesajı\n    queueRead.push(msg);\n} else {\n    // fc tanımlı değilse görmezden gel\n    return null;\n}\n\n// --- Kuyrukları context’e yaz ---\ncontext.set(\"queueWrite\", queueWrite);\ncontext.set(\"queueRead\", queueRead);\n\n// --- Timer başlatılmamışsa başlat ---\nif (!timerActive) {\n    context.set(\"timerActive\", true);\n    sendNext();\n}\n\nreturn null; // şimdilik mesaj döndürmüyoruz, node.send() kullanıyoruz\n\n/****************************************************\n * Fonksiyonlar\n ****************************************************/\nfunction sendNext() {\n    // Kuyrukları oku\n    let qW = context.get(\"queueWrite\") || [];\n    let qR = context.get(\"queueRead\")  || [];\n\n    let nextMsg = null;\n    let port = null;\n\n    // Öncelik: önce write kuyruğu\n    if (qW.length > 0) {\n        nextMsg = qW.shift();\n        port = 2; // sin_writer çıkışı\n    } else if (qR.length > 0) {\n        nextMsg = qR.shift();\n        port = 1; // sin_getter çıkışı\n    }\n\n    // Kuyrukları geri kaydet\n    context.set(\"queueWrite\", qW);\n    context.set(\"queueRead\", qR);\n\n    if (nextMsg) {\n        // İki çıkışlı fonksiyon nodu: [out1, out2]\n        node.send([\n            port === 1 ? nextMsg : null,\n            port === 2 ? nextMsg : null\n        ]);\n\n        // queue_interval sonra tekrar çalıştır\n        setTimeout(sendNext, queueInterval);\n    } else {\n        // Kuyruklar boş, timer’ı durdur\n        context.set(\"timerActive\", false);\n    }\n}\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// --- sin_queue node reset on start ---\ncontext.set(\"timerActive\", false);\ncontext.set(\"queueWrite\", []);\ncontext.set(\"queueRead\", []);\n",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 540,
        "wires": [
            [
                "7893af14ca0f63cc"
            ],
            [
                "155eb5f34a3f5ca3",
                "e14dbe6bed8406e9"
            ]
        ]
    },
    {
        "id": "b08e6ec489add032",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "sin_evt",
        "func": "/****************************************************\n * sin_evt – sin_getter’dan gelen ZSW (status word)\n * değişim olduğunda evt mesajı üretir.\n * Tüm bit tanımları config.status_word’dan dinamik alınır.\n * Çıkış msg.payload üzerinden verilecek.\n ****************************************************/\n\nconst flowData = flow.get(\"flow\") || {};\nconst sinConfig = flowData.config?.sinamics || {};\nconst labels = flowData.config?.labels || { true: \"on\", false: \"off\" };\nconst statusWordMap = sinConfig.status_word || {};\n\n// payload array [val] veya tek val olabilir\nconst rawVal = Array.isArray(msg.payload) ? msg.payload[0] : msg.payload;\n\n// UnitID'yi olabilecek tüm kaynaklardan sırayla dene (en garantili yol)\nconst unitid =\n    msg?.unitid ??\n    msg?.payload?.unitid ??\n    msg?.modbusRequest?.unitid ??\n    msg?.modbusResponseBuffer?.unitid ??\n    msg?.input?.unitid;\n\nif (unitid === undefined) {\n    node.warn(\"sin_evt: unitid bilgisi bulunamadı, gelen msg:\");\n    node.warn(msg); // 🔹 tüm mesajı dump et\n    return null;\n}\n\n// Hangi kanala ait olduğunu bul\nlet targetName = null;\nfor (const [name, ch] of Object.entries(sinConfig.channels || {})) {\n    if (ch.unitid === unitid) {\n        targetName = name;\n        break;\n    }\n}\n\nif (!targetName) {\n    node.warn(\"sin_evt: unitid eşleşmedi \" + unitid);\n    return null;\n}\n\n// bit okuma fonksiyonu\nfunction getBit(val, bitIndex) {\n    return (val & (1 << bitIndex)) !== 0;\n}\n\n// config.status_word’daki tüm key’leri dinamik çöz\nlet stateObj = {};\nfor (const [key, def] of Object.entries(statusWordMap)) {\n    const bitIndex = def.map;\n    const bitVal = getBit(rawVal, bitIndex);\n    stateObj[key] = labels[bitVal]; // örn. on/off\n}\n\n// Son durumla karşılaştır, değişim varsa gönder\nlet lastStates = context.get(\"lastStates\") || {};\nlet last = lastStates[targetName];\n\nlet changed = false;\nif (!last) {\n    changed = true; // ilk sefer\n} else {\n    for (let k of Object.keys(stateObj)) {\n        if (stateObj[k] !== last[k]) {\n            changed = true;\n            break;\n        }\n    }\n}\n\nif (changed) {\n    // Kaydet\n    lastStates[targetName] = stateObj;\n    context.set(\"lastStates\", lastStates);\n\n    // evt mesajını payload içine sar\n    const evtMsg = {\n        payload: {\n            method: \"evt\",\n            params: {\n                type: targetName,\n                val: stateObj\n            }\n        }\n    };\n\n    return evtMsg;\n} else {\n    return null; // değişim yok\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 540,
        "wires": [
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "7893af14ca0f63cc",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "sin_getter",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "9703a3f2808e2fa6",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": true,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 880,
        "y": 540,
        "wires": [
            [
                "b08e6ec489add032"
            ],
            []
        ]
    },
    {
        "id": "d7108d799a8d52c2",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "relays_write",
        "func": "// === RELAYS_WRITE.JS — WITH ROOF CONTROL INTEGRATED ===\n\n// ===== const / başlangıç =====\nconst flowData = flow.get(\"flow\");\nif (!flowData || !flowData.config) return null;\n\nconst config = flowData.config;\nconst runtime = flowData.runtime || {};\nconst labels = config.labels || { true: \"on\", false: \"off\" };\n\nconst payload = msg.payload || {};\nif (payload.method !== \"cmd\" || typeof payload.params !== \"object\") return null;\nconst { type, target } = payload.params || {};\nif (!type || !target) return null;\n\n// local arrays\nlet arr1 = context.get(\"last_write_array_1\") || Array(8).fill(false);\nlet arr2 = context.get(\"last_write_array_2\") || Array(8).fill(false);\n\n// channels / unitid\nconst relayChannels = { ...(config.io.relay_outputs_1?.channels || {}), ...(config.io.relay_outputs_2?.channels || {}) };\nconst unitids = { 1: config.io.relay_outputs_1?.unitid, 2: config.io.relay_outputs_2?.unitid };\nconst arrays = { 1: arr1, 2: arr2 };\nconst POWER_BIT = config.io.relay_outputs_2?.channels?.power_contactor?.map;\n\n// ===== functions =====\nfunction getRelayInfo(name) {\n  if (config.io.relay_outputs_1?.channels?.[name]) {\n    return { array: arr1, bit: config.io.relay_outputs_1.channels[name].map, unitid: unitids[1], arrayName: \"last_write_array_1\" };\n  }\n  if (config.io.relay_outputs_2?.channels?.[name]) {\n    return { array: arr2, bit: config.io.relay_outputs_2.channels[name].map, unitid: unitids[2], arrayName: \"last_write_array_2\" };\n  }\n  return null;\n}\n\nfunction createRelayMsgFromArray(theArray, unitid, arrayName) {\n  const word = theArray.reduce((w, b, i) => (b ? w | (1 << i) : w), 0);\n  context.set(arrayName, theArray);\n  return { payload: { value: word, fc: 6, unitid, address: 128, quantity: 1 } };\n}\n\nfunction sendEvtIfChanged(name, valStr) {\n  if ((runtime[name]?.val) !== valStr) {\n    runtime[name] = { val: valStr };\n    node.send([null, { payload: { method: \"evt\", params: { type: name, val: valStr } } }]);\n  }\n}\n\nfunction computePowerNewValue(preservePower, setPower) {\n  if (preservePower) {\n    const rtVal = runtime.power_contactor?.val;\n    if (rtVal === \"on\") return true;\n    if (rtVal === \"off\") return false;\n    if (POWER_BIT !== undefined) return !!arr2[POWER_BIT];\n    return false;\n  }\n  if (typeof setPower === \"boolean\") return setPower;\n  return false;\n}\n\n// ===== resetRelays =====\nfunction resetRelays({ preservePower = false, setPower = null } = {}) {\n  arr1.fill(false);\n  arr2.fill(false);\n\n  // diğer röleleri kapat\n  Object.keys(relayChannels).forEach(name => {\n    if (name === \"power_contactor\") return; \n    const ch = relayChannels[name];\n    const targetArray = (ch.unitid === unitids[1]) ? arr1 : arr2;\n    targetArray[ch.map] = false;\n    sendEvtIfChanged(name, \"off\");\n  });\n\n  // loader group off\n  if (config.io.relay_groups?.loader) {\n    Object.keys(config.io.relay_groups.loader).forEach(k => {\n      const r = getRelayInfo(k);\n      if (r) r.array[r.bit] = false;\n    });\n    sendEvtIfChanged(\"loader\", \"off\");\n  }\n\n  // roof group off\n  if (config.io.relay_groups?.roof) {\n    Object.keys(config.io.relay_groups.roof).forEach(k => {\n      const r = getRelayInfo(k);\n      if (r) r.array[r.bit] = false;\n    });\n    sendEvtIfChanged(\"roof\", \"off\");\n  }\n\n  // power bit\n  const newPowerBool = computePowerNewValue(preservePower, setPower);\n  if (POWER_BIT !== undefined) {\n    arr2[POWER_BIT] = !!newPowerBool;\n    sendEvtIfChanged(\"power_contactor\", labels[!!newPowerBool]);\n  }\n\n  context.set(\"last_write_array_1\", arr1);\n  context.set(\"last_write_array_2\", arr2);\n\n  const msgs = [];\n  if (unitids[1] != null) msgs.push(createRelayMsgFromArray(arr1, unitids[1], \"last_write_array_1\"));\n  if (unitids[2] != null) msgs.push(createRelayMsgFromArray(arr2, unitids[2], \"last_write_array_2\"));\n  node.send([msgs, null]);\n}\n\nfunction writeSingleRelay(name, setOn) {\n  const info = getRelayInfo(name);\n  if (!info) return;\n  info.array[info.bit] = !!setOn;\n  context.set(info.arrayName, info.array);\n  sendEvtIfChanged(name, (info.array[info.bit] ? labels[true] : labels[false]));\n  node.send([[ createRelayMsgFromArray(info.array, info.unitid, info.arrayName) ], null]);\n}\n\n// ===== Loader Handler =====\nfunction handleLoaderCmd(cmdType) {\n  if (!config.io.relay_groups?.loader) return;\n  const keys = Object.keys(config.io.relay_groups.loader || {});\n  const motorKey = keys[0], fwdKey = keys[1], revKey = keys[2];\n  const motor = getRelayInfo(motorKey), fwd = getRelayInfo(fwdKey), rev = getRelayInfo(revKey);\n  if (!(motor && fwd && rev)) return;\n\n  [motor, fwd, rev].forEach(r => r.array[r.bit] = false);\n\n  if (cmdType === \"forward\") { motor.array[motor.bit] = true; fwd.array[fwd.bit] = true; }\n  else if (cmdType === \"reverse\") { motor.array[motor.bit] = true; rev.array[rev.bit] = true; }\n\n  context.set(motor.arrayName, motor.array);\n  context.set(fwd.arrayName, fwd.array);\n  context.set(rev.arrayName, rev.array);\n\n  sendEvtIfChanged(\"loader\", cmdType);\n  sendEvtIfChanged(motorKey, motor.array[motor.bit] ? labels[true] : labels[false]);\n  sendEvtIfChanged(fwdKey, fwd.array[fwd.bit] ? labels[true] : labels[false]);\n  sendEvtIfChanged(revKey, rev.array[rev.bit] ? labels[true] : labels[false]);\n\n  const msgs = [];\n  [motor, fwd, rev].forEach(r => msgs.push(createRelayMsgFromArray(r.array, r.unitid, r.arrayName)));\n  const uniqueMsgs = Array.from(new Map(msgs.map(m => [m.payload.unitid, m])).values());\n  node.send([uniqueMsgs, null]);\n}\n\n// ===== Roof Handler (NEW) =====\nfunction handleRoofCmd(cmdType) {\n  if (!config.io.relay_groups?.roof) return;\n  const keys = Object.keys(config.io.relay_groups.roof || {});\n  const fwdKey = keys[0], revKey = keys[1];\n  const fwd = getRelayInfo(fwdKey), rev = getRelayInfo(revKey);\n  if (!(fwd && rev)) return;\n\n  [fwd, rev].forEach(r => r.array[r.bit] = false);\n\n  if (cmdType === \"forward\") { fwd.array[fwd.bit] = true; }\n  else if (cmdType === \"reverse\") { rev.array[rev.bit] = true; }\n\n  context.set(fwd.arrayName, fwd.array);\n  context.set(rev.arrayName, rev.array);\n\n  sendEvtIfChanged(\"roof\", cmdType);\n  sendEvtIfChanged(fwdKey, fwd.array[fwd.bit] ? labels[true] : labels[false]);\n  sendEvtIfChanged(revKey, rev.array[rev.bit] ? labels[true] : labels[false]);\n\n  const msgs = [];\n  [fwd, rev].forEach(r => msgs.push(createRelayMsgFromArray(r.array, r.unitid, r.arrayName)));\n  const uniqueMsgs = Array.from(new Map(msgs.map(m => [m.payload.unitid, m])).values());\n  node.send([uniqueMsgs, null]);\n}\n\n// ===== main flow =====\nif ((type === \"off\" && target === \"actuators\") || (type === \"off\" && target === \"power\") || (type === \"on\" && target === \"power\")) {\n  const args = (target === \"actuators\") ? { preservePower: true } : { setPower: (type === \"on\") };\n  resetRelays(args);\n} else if (target === \"loader\") {\n  handleLoaderCmd(type);\n} else if (target === \"roof\") {\n  handleRoofCmd(type);\n} else {\n  writeSingleRelay(target, type === \"on\");\n}\n\nflow.set(\"flow\", flowData);\nreturn null;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 660,
        "wires": [
            [
                "634cca30ddec5b5e"
            ],
            [
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "634cca30ddec5b5e",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "relays_queue",
        "func": "// === RELAYS_QUEUE.JS ===\n// relays_write port1’den gelen fc:6 write mesajlarını sıraya alır ve\n// relays_writer node’una gönderir.\n\nconst queueInterval = flow.get(\"flow\")?.config?.io?.queue_interval || 100;\n\nlet sendQueue = context.get(\"sendQueue\") || [];\nsendQueue = sendQueue.concat(Array.isArray(msg) ? msg : [msg]); // gelen mesaj dizisi olabilir\ncontext.set(\"sendQueue\", sendQueue);\n\nif (!context.get(\"isSending\")) processQueue();\n\nfunction processQueue() {\n  let q = context.get(\"sendQueue\") || [];\n  if (q.length === 0) {\n    context.set(\"isSending\", false);\n    return;\n  }\n  context.set(\"isSending\", true);\n  const m = q.shift();\n  context.set(\"sendQueue\", q);\n  node.send(m); // relays_writer’a tek tek gönder\n  setTimeout(processQueue, queueInterval);\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 660,
        "wires": [
            [
                "0719549b97c80402",
                "7c91402c2c82f119"
            ]
        ]
    },
    {
        "id": "e14dbe6bed8406e9",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "sin_queue_2_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 700,
        "wires": []
    },
    {
        "id": "7c91402c2c82f119",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "relays_queue_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 620,
        "y": 740,
        "wires": []
    },
    {
        "id": "03585ea38892f6a5",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "timer_manager_2_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 440,
        "wires": []
    },
    {
        "id": "a8d45eb24d6240ac",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager_2_dbg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 60,
        "wires": []
    }
]
[
    {
        "id": "2d8538969c77a5df",
        "type": "tab",
        "label": "my_flow",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c3488bd8821ff6d8",
        "type": "modbus-client",
        "name": "203_115200_tcp_rtu_rel_out",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.203",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "2206e55e928c8b8f",
        "type": "modbus-client",
        "name": "201_115200_tcp_rtu_dig_inp",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.201",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e707d8a8f03b29cf",
        "type": "modbus-client",
        "name": "204_9600_tcp_rtu_ang_inp_eng_met",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.204",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": "1000",
        "reconnectOnTimeout": true,
        "reconnectTimeout": "2000",
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "9703a3f2808e2fa6",
        "type": "modbus-client",
        "name": "202_9600_tcp_rtu_sinamics",
        "clienttype": "tcp",
        "bufferCommands": true,
        "stateLogEnabled": false,
        "queueLogEnabled": false,
        "failureLogEnabled": false,
        "tcpHost": "192.168.1.202",
        "tcpPort": "4196",
        "tcpType": "TCP-RTU-BUFFERED",
        "serialPort": "/dev/ttyUSB",
        "serialType": "RTU-BUFFERD",
        "serialBaudrate": 9600,
        "serialDatabits": 8,
        "serialStopbits": 1,
        "serialParity": "none",
        "serialConnectionDelay": 100,
        "serialAsciiResponseStartDelimiter": "0x3A",
        "unit_id": "",
        "commandDelay": 1,
        "clientTimeout": 1000,
        "reconnectOnTimeout": true,
        "reconnectTimeout": 2000,
        "parallelUnitIdsAllowed": true,
        "showErrors": false,
        "showWarnings": true,
        "showLogs": true
    },
    {
        "id": "e1d018cea69d77b6",
        "type": "mqtt-broker",
        "name": "mqtt_broker",
        "broker": "54.208.96.163",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "0719549b97c80402",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "write_relay_outputs",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "server": "c3488bd8821ff6d8",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "10",
        "x": 1270,
        "y": 540,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "ecf66dea2db91aea",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs",
        "func": "const ctx = context;\nconst flowData = flow.get(\"flow\");\n\nconst labels = flowData.config.labels;\nconst digitalInputs = flowData.config.io.digital_inputs;\nconst channels = digitalInputs.channels;\n\n// Giriş verisi: [<number>] şeklinde array\nconst rawVal = msg.payload?.[0];\nif (typeof rawVal !== \"number\") return null;\n\n// Hafıza başlat (bit geçmişi)\nif (!ctx.get(\"history\")) {\n  ctx.set(\"history\", {});\n}\nconst history = ctx.get(\"history\");\n\n// Değişen input'lar buraya\nconst changed = [];\n\nfor (const [key, def] of Object.entries(channels)) {\n  const bitIndex = def.map;\n  const bitVal = (rawVal >> bitIndex) & 1;\n  const newVal = labels[String(bitVal === 1)]; // \"true\"/\"false\" string olarak erişim\n\n  if (!history[key]) {\n    history[key] = [newVal];\n    // İlk seferde runtime'a yaz\n    if (flowData.runtime[key].val !== newVal) {\n      flowData.runtime[key].val = newVal;\n      changed.push({\n        payload: {\n          method: \"evt\",\n          params: { type: key, val: newVal }\n        }\n      });\n    }\n    continue;\n  }\n\n  const prevStates = history[key];\n  prevStates.push(newVal);\n  if (prevStates.length > 2) prevStates.shift();\n\n  const [prev, curr] = prevStates;\n\n  if (prev === curr && flowData.runtime[key].val !== curr) {\n    flowData.runtime[key].val = curr;\n    changed.push({\n      payload: {\n        method: \"evt\",\n        params: { type: key, val: curr }\n      }\n    });\n    history[key] = [curr];\n  } else {\n    history[key] = prevStates;\n  }\n}\n\nctx.set(\"history\", history);\n\n// Runtime'ı sadece değişiklik varsa yaz\nif (changed.length > 0) {\n  flow.set(\"flow\", flowData);\n  return [changed];\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 160,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c",
                "2b810660372548f4",
                "1fdf1ec66afd9b22"
            ]
        ]
    },
    {
        "id": "db72d07653f1bbe9",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs",
        "func": "const flowData = flow.get(\"flow\");\nconst analogInputs = flowData.config.io.analog_inputs;\nconst channels = analogInputs.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    const raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    // factor varsa uygula\n    const factor = (typeof def.factor === \"number\") ? def.factor : 1;\n    const rawEff = raw * factor;\n\n    let scaled = rawEff;\n    if (def.scale) {\n        const { in_min, in_max, out_min, out_max } = def.scale;\n        scaled = ((rawEff - in_min) / (in_max - in_min)) * (out_max - out_min) + out_min;\n    }\n    scaled = parseFloat(scaled.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(scaled - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'te sakla\n        lastVals[key] = scaled;\n\n        // Flow runtime'a yaz\n        flowData.runtime[key].val = scaled;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: scaled\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 240,
        "wires": [
            [
                "54a9a79a7c485b62",
                "89af02b1bc8fde6a"
            ]
        ]
    },
    {
        "id": "1b7f0d4c81a3700c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter",
        "func": "const flowData = flow.get(\"flow\");\nconst channels = flowData.config.energy_meter.channels;\n\n// Giriş verisi: [<number>, <number>, ...]\nconst rawVals = msg.payload;\nif (!Array.isArray(rawVals)) return null;\n\nconst results = [];\nconst lastVals = context.get(\"lastVals\") || {};\n\nfor (const [key, def] of Object.entries(channels)) {\n    const index = def.map;\n    let raw = rawVals[index];\n    if (typeof raw !== \"number\") continue;\n\n    // Çarpan uygula (ör: factor)\n    if (def.factor) {\n        raw *= def.factor;\n    }\n\n    raw = parseFloat(raw.toFixed(3));\n\n    const last = lastVals[key];\n    const diff = (last !== undefined) ? Math.abs(raw - last) : Infinity;\n\n    if (diff >= (def.change ?? 0)) {\n        // Node context'e son değeri yaz\n        lastVals[key] = raw;\n\n        // Flow context runtime'a yaz\n        flowData.runtime[key].val = raw;\n        flow.set(\"flow\", flowData);\n\n        // Mesaj oluştur\n        results.push({\n            payload: {\n                method: \"evt\",\n                params: {\n                    type: key,\n                    val: raw\n                }\n            }\n        });\n    }\n}\n\n// Güncellenmiş son değerleri sakla\ncontext.set(\"lastVals\", lastVals);\n\nif (results.length === 0) return null;\nreturn [results];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 320,
        "wires": [
            [
                "8b647d54a390a264"
            ]
        ]
    },
    {
        "id": "8d59f82c1f6e0d51",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "get_digital_inputs",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "2206e55e928c8b8f",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 160,
        "wires": [
            [
                "ecf66dea2db91aea"
            ],
            []
        ]
    },
    {
        "id": "14e917ac3699c006",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "0.1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 11, \"address\": 144 , \"quantity\": 1}",
        "payloadType": "json",
        "x": 130,
        "y": 160,
        "wires": [
            [
                "8d59f82c1f6e0d51"
            ]
        ]
    },
    {
        "id": "532186e49e9bd932",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "10",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 12, \"address\": 160 , \"quantity\": 8}",
        "payloadType": "json",
        "x": 140,
        "y": 220,
        "wires": [
            [
                "890e808611421ece"
            ]
        ]
    },
    {
        "id": "d1db2b67e2afbffe",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"fc\": 3, \"unitid\": 1, \"address\": 29 , \"quantity\": 2}",
        "payloadType": "json",
        "x": 130,
        "y": 320,
        "wires": [
            [
                "6f4e90bab79df245"
            ]
        ]
    },
    {
        "id": "6f4e90bab79df245",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "get_energy_meter",
        "showStatusActivities": false,
        "showErrors": true,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 320,
        "wires": [
            [
                "1b7f0d4c81a3700c"
            ],
            []
        ]
    },
    {
        "id": "155eb5f34a3f5ca3",
        "type": "modbus-flex-write",
        "z": "2d8538969c77a5df",
        "name": "write_sinamics",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "server": "9703a3f2808e2fa6",
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 1260,
        "y": 600,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "69b69a40e08aa884",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "actuators",
        "func": "const flowData = flow.get(\"flow\");\nconst config = flowData.config;\nconst runtime = flowData.runtime;\n\nconst payload = msg.payload;\nif (!payload || payload.method !== \"cmd\" || typeof payload.params !== \"object\") return null;\n\nconst { type, target, set_point } = payload.params;\nif (!type || !target) return null;\n\nconst relayChannels1 = config.io.relay_outputs_1.channels || {};\nconst relayChannels2 = config.io.relay_outputs_2.channels || {};\nconst unitid1 = config.io.relay_outputs_1.unitid;\nconst unitid2 = config.io.relay_outputs_2.unitid;\n\nlet currentArray1 = context.get(\"last_write_array_1\") || Array(8).fill(false);\nlet currentArray2 = context.get(\"last_write_array_2\") || Array(8).fill(false);\n\nfunction getRelayInfo(name) {\n  if (relayChannels1?.[name]) return { array: currentArray1, bit: relayChannels1[name].map, unitid: unitid1, arrayName: \"last_write_array_1\" };\n  if (relayChannels2?.[name]) return { array: currentArray2, bit: relayChannels2[name].map, unitid: unitid2, arrayName: \"last_write_array_2\" };\n  return null;\n}\n\nfunction createRelayMsg(array, unitid, arrayName) {\n  let word = 0;\n  for (let i = 0; i < 8; i++) {\n    if (array[i]) word |= (1 << i);\n  }\n  context.set(arrayName, array);\n  return { payload: { value: word, fc: 6, unitid, address: 128, quantity: 1 } };\n}\n\nconst relayMsgs = [];\nconst sinamicsMsgs = [];\nconst evtMsgs = [];\n\nfunction enqueueMsgs() {\n  let sendQueue = context.get(\"sendQueue\") || [];\n  const queuedMsgs = [];\n  relayMsgs.forEach(m => queuedMsgs.push([0, m]));\n  sinamicsMsgs.forEach(m => queuedMsgs.push([1, m]));\n  evtMsgs.forEach(m => queuedMsgs.push([2, m]));\n  sendQueue.push(...queuedMsgs);\n  context.set(\"sendQueue\", sendQueue);\n  if (!context.get(\"isSending\")) processQueue();\n}\n\nfunction processQueue() {\n  let sendQueue = context.get(\"sendQueue\") || [];\n  if (sendQueue.length === 0) {\n    context.set(\"isSending\", false);\n    return;\n  }\n  context.set(\"isSending\", true);\n  const [portIndex, msgObj] = sendQueue.shift();\n  context.set(\"sendQueue\", sendQueue);\n  node.send([\n    portIndex === 0 ? msgObj : null,\n    portIndex === 1 ? msgObj : null,\n    portIndex === 2 ? msgObj : null\n  ]);\n  setTimeout(processQueue, 50);\n}\n\n// === Toplu OFF ===\nfunction doActuatorsOff() {\n  currentArray1 = Array(8).fill(false);\n  currentArray2 = Array(8).fill(false);\n  const emBit = relayChannels2.power_contactor?.map;\n  if (emBit !== undefined) currentArray2[emBit] = runtime.power_contactor?.val === \"on\";\n\n  context.set(\"last_write_array_1\", currentArray1);\n  context.set(\"last_write_array_2\", currentArray2);\n\n  for (const name of Object.keys({ ...relayChannels1, ...relayChannels2 })) {\n    if (name === \"power_contactor\") continue;\n    if (runtime[name]) {\n      runtime[name].val = \"off\";\n      evtMsgs.push({ payload: { method: \"evt\", params: { type: name, val: \"off\" } } });\n    }\n  }\n\n  // Loader OFF\n  const loaderKeys = Object.entries({ ...relayChannels1, ...relayChannels2 })\n    .filter(([_, val]) => val.group === \"loader\")\n    .map(([key]) => key);\n  loaderKeys.forEach(key => {\n    const r = getRelayInfo(key);\n    if (r) r.array[r.bit] = false;\n  });\n  runtime.loader = { val: \"off\" };\n  evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader\", val: \"off\" } } });\n\n  // SINAMICS OFF\n  for (const [name, sin] of Object.entries(config.sinamics?.channels || {})) {\n    sinamicsMsgs.push({ payload: { value: config.sinamics.command_words.off, fc: 6, unitid: sin.unitid, address: 99, quantity: 1 } });\n    if (!runtime[name]) runtime[name] = {};\n    runtime[name].val = \"off\";\n    if (runtime[name].speed?.set_point) {\n      const value = Math.round(runtime[name].speed.set_point / 100 * config.sinamics.speed_max);\n      sinamicsMsgs.push({ payload: { value, fc: 6, unitid: sin.unitid, address: 100, quantity: 1 } });\n    }\n    evtMsgs.push({ payload: { method: \"evt\", params: { type: name, val: runtime[name].val, speed: runtime[name].speed ? { set_point: runtime[name].speed.set_point } : undefined } } });\n  }\n\n  relayMsgs.push(createRelayMsg(currentArray1, unitid1, \"last_write_array_1\"));\n  relayMsgs.push(createRelayMsg(currentArray2, unitid2, \"last_write_array_2\"));\n  enqueueMsgs();\n}\n\n// === Restore ===\nif (type === \"on\" && target === \"power\") {\n  evtMsgs.push({ payload: { method: \"evt\", params: { type: \"power_contactor\", val: \"on\" } } });\n  const emRelay = getRelayInfo(\"power_contactor\");\n  if (emRelay) {\n    emRelay.array[emRelay.bit] = true;\n    runtime.power_contactor = { val: \"on\" };   // eksik olan eklendi\n    relayMsgs.push(createRelayMsg(emRelay.array, emRelay.unitid, emRelay.arrayName));\n  }\n  enqueueMsgs();\n  setTimeout(doActuatorsOff, 10000);\n\n} else if (type === \"off\" && target === \"power\") {\n  // 1. önce tüm aktüatörler kapat\n  doActuatorsOff();\n\n  // 2. sonra 1 sn bekleyip power_contactor kapat\n  setTimeout(() => {\n    const emRelay = getRelayInfo(\"power_contactor\");\n    if (emRelay) {\n      emRelay.array[emRelay.bit] = false;                 // röle array güncelle\n      runtime.power_contactor = { val: \"off\" };           // runtime güncelle\n      evtMsgs.push({ payload: { method: \"evt\", params: { type: \"power_contactor\", val: \"off\" } } });\n      relayMsgs.push(createRelayMsg(emRelay.array, emRelay.unitid, emRelay.arrayName));  // modbus yazma\n      enqueueMsgs();  // kuyruk çalıştır\n    }\n  }, 1000);\n\n} else if (type === \"off\" && target === \"actuators\") {\n  doActuatorsOff();\n} else {\n  const sinamics = config.sinamics?.channels?.[target];\n  if (sinamics) {\n    const unitid = sinamics.unitid;\n    const commandWords = config.sinamics.command_words;\n    const speedMax = config.sinamics.speed_max;\n    if ([\"forward_on\", \"reverse_on\", \"off\"].includes(type)) {\n      const value = commandWords[type];\n      if (value != null) {\n        sinamicsMsgs.push({ payload: { value, fc: 6, unitid, address: 99, quantity: 1 } });\n        if (!runtime[target]) runtime[target] = {};\n        runtime[target].val = type;\n      }\n    }\n    if (type === \"speed\" && typeof set_point === \"number\") {\n      const value = Math.round(set_point / 100 * speedMax);\n      sinamicsMsgs.push({ payload: { value, fc: 6, unitid, address: 100, quantity: 1 } });\n      if (!runtime[target]) runtime[target] = {};\n      if (!runtime[target].speed) runtime[target].speed = {};\n      runtime[target].speed.set_point = set_point;\n    }\n    evtMsgs.push({ payload: { method: \"evt\", params: { type: target, val: runtime[target].val, speed: runtime[target].speed ? { set_point: runtime[target].speed.set_point } : undefined } } });\n    enqueueMsgs();\n  } else {\n    if ([\"on\", \"off\"].includes(type)) {\n      const relay = getRelayInfo(target);\n      if (relay) {\n        const val = type === \"on\";\n        relay.array[relay.bit] = val;\n        runtime[target] = { val: type };\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: target, val: type } } });\n      }\n    }\n\n    // === Tekil loader komutları için güncelleme ===\n    if (target === \"loader\" && [\"forward_on\", \"reverse_on\", \"off\"].includes(type)) {\n      const loaderKeys = Object.entries({ ...relayChannels1, ...relayChannels2 })\n        .filter(([_, val]) => val.group === \"loader\")\n        .map(([key]) => key);\n      const relays = Object.fromEntries(loaderKeys.map(key => [key, getRelayInfo(key)]).filter(([_, info]) => info));\n      const motor = relays[\"loader_motor\"];\n      const fwd = relays[\"loader_forward_valve\"];\n      const rev = relays[\"loader_reverse_valve\"];\n      if (motor && fwd && rev) {\n        if (type === \"forward_on\") { motor.array[motor.bit] = true; fwd.array[fwd.bit] = true; rev.array[rev.bit] = false; }\n        else if (type === \"reverse_on\") { motor.array[motor.bit] = true; fwd.array[fwd.bit] = false; rev.array[rev.bit] = true; }\n        else if (type === \"off\") { motor.array[motor.bit] = false; fwd.array[fwd.bit] = false; rev.array[rev.bit] = false; }\n\n        // runtime güncelle\n        runtime.loader = { val: type };\n        runtime.loader_motor = { val: type === \"off\" ? \"off\" : \"on\" };\n        runtime.loader_forward_valve = { val: type === \"off\" ? \"off\" : (type === \"forward_on\" ? \"on\" : \"off\") };\n        runtime.loader_reverse_valve = { val: type === \"off\" ? \"off\" : (type === \"reverse_on\" ? \"on\" : \"off\") };\n\n        // evt mesajları ekle\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader\", val: type } } });\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader_motor\", val: runtime.loader_motor.val } } });\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader_forward_valve\", val: runtime.loader_forward_valve.val } } });\n        evtMsgs.push({ payload: { method: \"evt\", params: { type: \"loader_reverse_valve\", val: runtime.loader_reverse_valve.val } } });\n      }\n    }\n\n    relayMsgs.push(createRelayMsg(currentArray1, unitid1, \"last_write_array_1\"));\n    relayMsgs.push(createRelayMsg(currentArray2, unitid2, \"last_write_array_2\"));\n    enqueueMsgs();\n  }\n}\n\nflow.set(\"flow\", flowData);\nreturn null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 540,
        "wires": [
            [
                "0719549b97c80402",
                "1c798b44f6d4353a"
            ],
            [
                "155eb5f34a3f5ca3",
                "7ccdddabf54a9ffe"
            ],
            [
                "0b3654ab51cfd27c",
                "86a9ac90f6c99b53"
            ]
        ]
    },
    {
        "id": "0defb2d453130745",
        "type": "mqtt in",
        "z": "2d8538969c77a5df",
        "name": "mqtt_in",
        "topic": "v1/devices/me/rpc/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "e1d018cea69d77b6",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 570,
        "y": 60,
        "wires": [
            [
                "0b3654ab51cfd27c",
                "f1a672c83645300a"
            ]
        ]
    },
    {
        "id": "b7b87a40dd91a021",
        "type": "mqtt out",
        "z": "2d8538969c77a5df",
        "name": "mqtt_out",
        "topic": "",
        "qos": "0",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "e1d018cea69d77b6",
        "x": 1240,
        "y": 60,
        "wires": []
    },
    {
        "id": "c3f4a0e8f8030852",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "flow_context",
        "func": "const payload = msg.payload || {};\nconst method = payload.method || \"\";\nconst params = payload.params || {};\n\nif (!(method === \"cmd\" && params.type === \"inject\" && params.target === \"flow_context\")) {\n    return null; // diğer tüm mesajları görmezden gel\n}\n\nconst flowData = {\n  config: {\n    labels: {true: \"on\", false: \"off\"},\n    io: {\n      digital_inputs: {\n        config_node: \"201_115200_tcp_rtu_dig_inp\",\n        unitid: 11,\n        channels: {        \n          oxygen_detector_dig_alr_1: {map: 0, pro: {oxygen_detector_dig: \"off\"}},\n          oxygen_detector_dig_alr_2: {map: 1, pro: {oxygen_detector_dig: \"on\"}},\n          humidity_detector_dig_alr_1: {map: 2, pro: {humidity_detector_dig: \"off\"}},\n          humidity_detector_dig_alr_2: {map: 3, pro: {humidity_detector_dig: \"on\"}},\n          roof_forward_limit: {map: 4},\n          roof_reverse_limit: {map: 5},\n          cabinet_door: {map: 6},\n          stop_button: {map: 15}\n        }      \n      },\n      analog_inputs: {\n        config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n        unitid: 12,        \n        channels: {\n          oxygen: {map: 0, change: 0.2, factor: 0.01, scale: {in_min: 4, in_max: 20, out_min: 0.5, out_max: 20.9}, pro: {oxygen_detector_ang: {off: 3.2, on: 14.7}}},\n          humidity: {map: 1, change: 3, factor: 0.01, scale: {in_min: 4, in_max: 20, out_min: 0, out_max: 100}, pro: {humidity_detector_ang: {off: 30, on: 60}}}\n        }\n      },\n      relay_outputs_1: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 13,\n        channels: {\n          light: {map: 6},\n          buzzer: {map: 7}\n        }\n      },\n      relay_outputs_2: {\n        config_node: \"203_115200_tcp_rtu_rel_out\",\n        unitid: 14,\n        channels: {\n          loader_forward_valve: {map: 4, group: \"loader\"},\n          loader_reverse_valve: {map: 5, group: \"loader\"},\n          loader_motor: {map: 6, group: \"loader\"},\n          power_contactor: {map: 7}\n        }\n      }\n    },\n    energy_meter: {\n      config_node: \"204_9600_tcp_rtu_ang_inp_eng_met\",\n      unitid: 1,      \n      channels: {\n        kwh: {map: 0, factor: 0.01, change: 2, pro: {kwh_detector: {off: 30, on: 60}}}\n      }\n    },  \n    sinamics: {\n      config_node: \"202_9600_tcp_rtu_sinamics\",\n      command_words: {forward_on: 1279, reverse_on: 3327, off: 1278},\n      speed_max: 16384, // modbus send >> set_point / 100 * speed_max\n      channels: {\n        roof: {unitid: 11},\n        fan: {unitid: 12},\n        water_pump: {unitid: 13},\n        discharger: {unitid: 14}\n      }\n    },\n    timers: {      \n      fan_pwm: {\n        form: \"pwm\",\n        t_duty: 10, t_cycle: 180, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"forward_on\", target: \"fan\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"fan\"}, port: 2}\n        }\n      },\n      water_pump_pwm: {\n        form: \"pwm\",\n        t_duty: 15, t_cycle: 360, unit: \"min\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"forward_on\", target: \"water_pump\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"water_pump\"}, port: 2}\n        }\n      },\n      light_pulse: {\n        form: \"delay\", duration: 2, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"light\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"light\"}, port: 2}\n        }\n      },\n      light_pwm: {\n        form: \"pwm\", t_duty: 2, t_cycle: 5, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"light\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"light\"}, port: 2}\n        }        \n      },\n      buzzer_pulse: {\n        form: \"delay\", duration: 2, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"buzzer\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"buzzer\"}, port: 2}\n        }\n      },\n      buzzer_pwm: {\n        form: \"pwm\", t_duty: 2, t_cycle: 5, unit: \"s\",\n        pass: {\n          1: {method: \"cmd\", params: {type: \"on\", target: \"buzzer\"}, port: 2},\n          2: {method: \"cmd\", params: {type: \"off\", target: \"buzzer\"}, port: 2}\n        }        \n      },\n      day_counter: {\n        form: \"counter\", direction: \"down\", interval: 1, base: 21, signal: 3, unit: \"d\",\n        pass: {\n          2: {method: \"cmd\", params: {type: \"dry\", target: \"fsm\"}, port: 1},\n          3: {method: \"cmd\", params: {type: \"end\", target: \"fsm\"}, port: 1},\n          4: {method: \"evt\", params: {type: \"day\"}, port: 3} // val buradan sabit gelmeyecek\n        }             \n      },\n      telemetry_periodical: {\n        form: \"loop\", interval: 2, unit: \"min\",\n        pass: {\n          1: {method: \"evt\", params: {type: \"telemetry_periodical\", val: null}, port: 3}\n        }        \n      }\n    }\n  },\n  runtime: {\n    oxygen_detector_dig_alr_1: {val: \"on\"},\n    oxygen_detector_dig_alr_2: {val: \"on\"},\n    humidity_detector_dig_alr_1: {val: \"on\"},\n    humidity_detector_dig_alr_2: {val: \"on\"},\n    roof_forward_limit: {val: \"on\"},\n    roof_reverse_limit: {val: \"on\"},\n    cabinet_door: {val: \"off\"},\n    stop_button: {val: \"off\"},\n    oxygen: {val: 0},\n    humidity: {val: 0}, \n    loader_forward_valve: {val: \"off\"},\n    loader_reverse_valve: {val: \"off\"},\n    loader_motor: {val: \"off\"},\n    power_contactor: {val: \"off\"},\n    light: {val: \"off\"},\n    buzzer: {val: \"off\"},  \n    roof: {speed: {set_point: 100}, val: \"off\"},\n    fan: {speed: {set_point: 100}, val: \"off\"},\n    water_pump: {speed: {set_point: 100}, val: \"off\"},\n    discharger: {speed: {set_point: 100}, val: \"off\"},\n    loader: {val: \"off\"},\n    kwh: {val: 0},\n    oxygen_detector_dig: {val: \"off\"},\n    oxygen_detector_ang: {val: \"off\"},\n    humidity_detector_dig: {val: \"off\"},\n    humidity_detector_ang: {val: \"off\"},\n    kwh_detector: {val: \"off\"},\n    fsm: {state: \"end\"}\n  }\n}\n\nflow.set(\"flow\", flowData);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 60,
        "wires": [
            [
                "beb4346081038e85"
            ]
        ]
    },
    {
        "id": "2467bf030b733b1e",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "flow_context_inject",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"method\": \"cmd\", \"params\": {\"type\": \"inject\", \"target\": \"flow_context\"}}",
        "payloadType": "json",
        "x": 130,
        "y": 60,
        "wires": [
            [
                "c3f4a0e8f8030852"
            ]
        ]
    },
    {
        "id": "8701a07643f54a7b",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "timer_manager",
        "func": "const flowData = flow.get(\"flow\");\nconst timers = flowData.config.timers;\n\nconst method = msg?.payload?.method || msg?.method;\nconst params = msg?.payload?.params || msg?.params || {};\nconst target = params.target;\nconst type = params.type;\n\nconst out = [[], [], []]; // Port 1,2,3\nlet runtime = context.get(\"runtime\") || {};\n\nfunction toMs(val, unit) {\n  const map = { s: 1000, min: 60000, h: 3600000, d: 86400000 };\n  return val * (map[unit] ?? 1000);\n}\n\nfunction pushMessage(timer, passKey, out, runtime = {}, target = null) {\n  const entry = timer.pass?.[passKey];\n  if (!entry) return;\n\n  const message = RED.util.cloneMessage(entry);\n  const port = (entry.port ?? 0) - 1;\n  if (port < 0 || port > 2) return;\n\n  delete message.port;\n\n  if (message.params && target && runtime[target]) {\n    for (const [key, val] of Object.entries(message.params)) {\n      if (val === null && runtime[target][key] !== undefined) {\n        message.params[key] = runtime[target][key];\n      } else if (typeof val === \"object\" && val !== null && \"val\" in val) {\n        message.params[key].val = runtime[target].count;\n      }\n    }\n\n    if (timer.form === \"counter\" && passKey === 4 && message.params.val === undefined) {\n      message.params.val = runtime[target].count;\n    }\n  }\n\n  out[port].push({ payload: message });\n}\n\nfunction timerOn(timer, rt, now, out, target, forcedCount = null) {\n  rt.state = \"on\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.on_time = now;\n      rt.done = false;\n      rt.phase_until = now + toMs(timer.duration, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"pwm\":\n      rt.on_time = now;\n      rt.phase = \"a\";\n      rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"loop\":\n      rt.on_time = now;\n      rt.next_time = now + toMs(timer.interval, timer.unit);\n      pushMessage(timer, 1, out);\n      break;\n\n    case \"counter\":\n      rt.on_time = now;\n      rt.count = forcedCount !== null ? forcedCount : timer.base;\n      rt.next_time = now + toMs(timer.interval, timer.unit);\n\n      const entry4 = timer.pass?.[4];\n      if (entry4) {\n        entry4.params = entry4.params || {};\n        entry4.params.val = rt.count;\n      }\n\n      pushMessage(timer, 1, out, runtime, target);\n      pushMessage(timer, 4, out, runtime, target);\n      break;\n  }\n}\n\nfunction timerOff(timer, rt, out, target, suppressMessages = false) {\n  rt.state = \"off\";\n\n  switch (timer.form) {\n    case \"delay\":\n      rt.done = true;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"pwm\":\n      rt.phase = null;\n      if (!suppressMessages) pushMessage(timer, 2, out);\n      break;\n\n    case \"loop\":\n      if (!suppressMessages) pushMessage(timer, 1, out);\n      break;\n\n    case \"counter\":\n      rt.count = 0;\n      if (!suppressMessages) {\n        pushMessage(timer, 3, out, runtime, target);\n        pushMessage(timer, 4, out, runtime, target);\n      }\n\n      // day_counter için evt day 0 mesajı her koşulda\n      if (target === \"day_counter\") {\n        out[2].push({\n          payload: {\n            method: \"evt\",\n            params: { type: \"day\", val: 0 }\n          }\n        });\n      }\n      break;\n  }\n\n  // Genel reset: runtime içindeki yardımcı alanlar\n  rt.on_time = null;\n  rt.next_time = null;\n  rt.phase_until = null;\n  rt.phase = null;\n}\n\nfunction timerTick(timers, runtime, now, out) {\n  for (const [key, timer] of Object.entries(timers)) {\n    const rt = runtime[key];\n    if (!rt || rt.state !== \"on\") continue;\n\n    switch (timer.form) {\n      case \"delay\":\n        if (!rt.done && now >= rt.phase_until) {\n          rt.done = true;\n          pushMessage(timer, 2, out);\n        }\n        break;\n\n      case \"pwm\":\n        if (now >= rt.phase_until) {\n          if (rt.phase === \"a\") {\n            rt.phase = \"b\";\n            rt.phase_until = now + toMs(timer.t_cycle - timer.t_duty, timer.unit);\n            pushMessage(timer, 2, out);\n          } else {\n            rt.phase = \"a\";\n            rt.phase_until = now + toMs(timer.t_duty, timer.unit);\n            pushMessage(timer, 1, out);\n          }\n        }\n        break;\n\n      case \"loop\":\n        if (now >= rt.next_time) {\n          rt.next_time = now + toMs(timer.interval, timer.unit);\n          pushMessage(timer, 1, out);\n        }\n        break;\n\n      case \"counter\":\n        if (now >= rt.next_time && rt.count > 0) {\n          rt.count -= 1;\n          rt.next_time = now + toMs(timer.interval, timer.unit);\n\n          if (timer.signal !== undefined && rt.count === timer.signal) {\n            pushMessage(timer, 2, out, runtime, key);\n          }\n\n          pushMessage(timer, 4, out, runtime, key);\n\n          if (rt.count === 0) {\n            rt.state = \"off\";\n            pushMessage(timer, 3, out, runtime, key);\n\n            // Son kalan gün evt day 0 mesajı\n            if (key === \"day_counter\") {\n              out[2].push({\n                payload: {\n                  method: \"evt\",\n                  params: { type: \"day\", val: 0 }\n                }\n              });\n            }\n\n            // Reset runtime yardımcı alanlar\n            rt.on_time = null;\n            rt.next_time = null;\n            rt.phase_until = null;\n            rt.phase = null;\n          }\n        }\n        break;\n    }\n  }\n}\n\n// --- CMD handling ---\nif (method === \"cmd\") {\n  // --- Special skip for day_counter ---\n  if (type === \"skip\" && target === \"day_counter\") {\n    if (!runtime[target]) runtime[target] = {};\n    const rt = runtime[target];\n\n    // day_counter'ı signal anına getir ve timerOn gibi başlat\n    timerOn(timers[target], rt, Date.now(), out, target, timers[target].signal);\n\n  } else if (timers[target]) {\n    if (!runtime[target]) runtime[target] = {};\n    if (type === \"on\") {\n      timerOn(timers[target], runtime[target], Date.now(), out, target);\n    } else if (type === \"off\") {\n      timerOff(timers[target], runtime[target], out, target);\n    }\n  } else if (type === \"off\" && target === \"timers\") {\n    for (const [key, timer] of Object.entries(timers)) {\n      if (key === \"telemetry_periodical\") continue;\n      if (!runtime[key]) runtime[key] = {};\n      timerOff(timer, runtime[key], out, key, true);\n    }\n  } else {\n    out[1].push(msg);\n  }\n\n} else if (method === \"evt\" && type === \"timer_tick\") {\n  timerTick(timers, runtime, Date.now(), out);\n} else {\n  out[1].push(msg);\n}\n\ncontext.set(\"runtime\", runtime);\n\nreturn out.some(arr => arr.length) ? out : null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 440,
        "wires": [
            [
                "22442867c06e05b8",
                "664d95256e2c36ad"
            ],
            [
                "69b69a40e08aa884",
                "eabb49f6ea664cdf"
            ],
            [
                "0b3654ab51cfd27c",
                "9185b5217ebdc209"
            ]
        ]
    },
    {
        "id": "1156fe8823a93a99",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "timer_tick",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"method\": \"evt\", \"params\": {\"type\": \"timer_tick\", \"val\": null}}",
        "payloadType": "json",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "8701a07643f54a7b"
            ]
        ]
    },
    {
        "id": "22442867c06e05b8",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "fsm",
        "func": "const flowData = flow.get(\"flow\");\nconst runtime = flowData.runtime;\nlet currentState = runtime.fsm.state;\n\nconst payload = msg.payload;\nif (!payload || typeof payload !== \"object\") return null;\n\nconst method = payload.method;\nconst params = payload.params || {};\nconst type = params.type;\nconst target = params.target;\nconst val = params.val;\n\nconst outputs = [[], []];\n\nfunction transition(toState) {\n  if (toState !== currentState) {\n    currentState = toState;\n    flowData.runtime.fsm.state = currentState;\n    flow.set(\"flow\", flowData);\n    sendEvt(\"fsm\", { state: currentState });\n  }\n}\n\nfunction sendCmd(type, target, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"cmd\",\n      params: { type, target, ...extraParams }\n    }\n  };\n  outputs[0].push(msg);\n}\n\nfunction sendEvt(type, extraParams = {}) {\n  const msg = {\n    payload: {\n      method: \"evt\",\n      params: { type, ...extraParams }\n    }\n  };\n  outputs[1].push(msg);\n}\n\n// --- Ana mesaj işleme ---\nif (method === \"evt\") {\n\n  if (type === \"oxygen_detector_dig\") {\n    if (currentState === \"start\") {\n      if (val === \"off\") {\n        sendCmd(\"on\", \"fan_pwm\");\n      } else if (val === \"on\") {\n        sendCmd(\"off\", \"fan_pwm\");\n      }\n    }\n\n  } else if (type === \"humidity_detector_ang\") {\n    if (currentState === \"start\") {\n      if (val === \"off\") {\n        sendCmd(\"on\", \"water_pump_pwm\");\n      } else if (val === \"on\") {\n        sendCmd(\"off\", \"water_pump_pwm\");\n      }\n    }\n\n  } else if (type === \"roof_forward_limit\") {\n    if (val === \"off\") {\n      sendCmd(\"off\", \"roof\");\n    }\n\n  } else if (type === \"roof_reverse_limit\") {\n    if (val === \"off\") {\n      sendCmd(\"off\", \"roof\");\n    }\n\n  } else if (type === \"cabinet_door\") {\n    // boş\n\n  } else if (type === \"stop_button\") {\n    // boş\n  }\n\n} else if (method === \"cmd\") {\n\n  if (target === \"fsm\") {\n\n    if (type === \"start\") {\n      if (runtime.oxygen_detector_dig.val === \"off\") {\n        sendCmd(\"on\", \"fan_pwm\");\n      } else if (runtime.oxygen_detector_dig.val === \"on\") {\n        sendCmd(\"off\", \"fan_pwm\");\n      }\n      if (runtime.humidity_detector_ang.val === \"off\") {\n        sendCmd(\"on\", \"water_pump_pwm\");\n      } else if (runtime.humidity_detector_ang.val === \"on\") {\n        sendCmd(\"off\", \"water_pump_pwm\");\n      }\n      sendCmd(\"on\", \"day_counter\");\n      transition(\"start\");\n\n    } else if (type === \"dry\") {\n      sendCmd(\"skip\", \"day_counter\");\n      sendCmd(\"on\", \"fan_pwm\");\n      sendCmd(\"off\", \"water_pump_pwm\");\n      transition(\"dry\");\n\n    } else if (type === \"end\") {\n      sendCmd(\"off\", \"timers\");\n      sendCmd(\"off\", \"actuators\");\n      transition(\"end\");\n    }\n\n  } else if (target === \"roof\") {\n\n    if (type === \"forward_on\") {\n      if (runtime.roof_forward_limit.val === \"off\") {\n        return;\n      }\n    } else if (type === \"reverse_on\") {\n      if (runtime.roof_reverse_limit.val === \"off\") {\n        return;\n      }\n    }\n    outputs[0].push(msg);     \n    \n  } else {\n    outputs[0].push(msg);\n  }\n}\n\nreturn outputs;\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 260,
        "wires": [
            [
                "8701a07643f54a7b",
                "c191c7397b21bd4f"
            ],
            [
                "0b3654ab51cfd27c",
                "abbeb7f879dce340"
            ]
        ]
    },
    {
        "id": "0b3654ab51cfd27c",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager",
        "func": "// Sabitler\nconst TELEMETRY_TOPIC = \"v1/devices/me/telemetry\";\nconst RPC_RESPONSE_PREFIX = \"v1/devices/me/rpc/response/\";\n\nconst topic = msg.topic || \"\";\nconst payload = msg.payload || {};\nconst method = payload?.method || \"\";\nconst params = payload?.params || {};\n\nconst flowData = flow.get(\"flow\") || {};\n\n// Güvenli msgId (topic beklenen formatta değilse 'unknown' kullan)\nconst msgId = (topic.split(\"/\").pop()) || \"unknown\";\n\nfunction getValueAtPath(obj, path) {\n    if (!Array.isArray(path) || path.length === 0) return obj;\n    return path.reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : null), obj);\n}\n\nfunction setValueAtPath(obj, path, value) {\n    if (!Array.isArray(path) || path.length === 0) {\n        throw new Error(\"Invalid path for set\");\n    }\n    let current = obj;\n    for (let i = 0; i < path.length - 1; i++) {\n        const key = path[i];\n        if (!(key in current) || typeof current[key] !== 'object' || current[key] === null) {\n            current[key] = {};\n        }\n        current = current[key];\n    }\n    current[path[path.length - 1]] = value;\n}\n\nfunction buildRpcResponse(id, content) {\n    return {\n        topic: RPC_RESPONSE_PREFIX + id,\n        payload: content\n    };\n}\n\nfunction buildTelemetryMsg(content) {\n    return {\n        topic: TELEMETRY_TOPIC,\n        payload: content\n    };\n}\n\n// 1) evt\nif (method === \"evt\") {\n    const subType = params?.type;\n\n    if (subType === \"telemetry_periodical\") {\n        return [buildTelemetryMsg(flowData.runtime || {}), null, null];\n    } \n    else if (subType === \"fsm\") {\n        const formatted = { fsm: { state: params.state } };\n        return [buildTelemetryMsg(formatted), null, null];\n    }\n    else {\n        const key = params?.type;\n\n        if (params?.val !== undefined && params?.speed !== undefined) {\n            const formatted = { [key]: { val: params.val, speed: params.speed } };\n            return [buildTelemetryMsg(formatted), null, null];\n        } else if (params?.val !== undefined) {\n            const formatted = { [key]: { val: params.val } };\n            return [buildTelemetryMsg(formatted), null, null];\n        } else if (params?.speed !== undefined) {\n            const formatted = { [key]: { speed: params.speed } };\n            return [buildTelemetryMsg(formatted), null, null];\n        }\n\n        return [null, null, null];\n    }\n}\n\n// 2) cmd\nif (method === \"cmd\") {\n    // Özel \"inject → flow_context\" komutu kontrolü\n    if (params?.type === \"inject\" && params?.target === \"flow_context\") {\n        return [buildRpcResponse(msgId, { response: true }), null, { payload }];\n    }\n    // Normal cmd\n    return [buildRpcResponse(msgId, { response: true }), { payload }, null];\n}\n\n// 3) set/get tipi dot-path'li method'lar\nconst [action, ...pathParts] = method.split(\".\");\n\nif (action === \"get\") {\n    try {\n        const value = getValueAtPath(flowData, pathParts);\n        return [buildRpcResponse(msgId, { value: value === undefined ? null : value }), null, null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null, null];\n    }\n}\n\nif (action === \"set\") {\n    try {\n        if (!pathParts || pathParts.length === 0) {\n            return [buildRpcResponse(msgId, { error: \"Invalid set path\" }), null, null];\n        }\n        const newValue = params?.value;\n        setValueAtPath(flowData, pathParts, newValue);\n        flow.set(\"flow\", flowData);\n        return [buildRpcResponse(msgId, { response: true }), null, null];\n    } catch (err) {\n        return [buildRpcResponse(msgId, { error: err.message }), null, null];\n    }\n}\n\n// Bilinmeyen method'lar\nreturn [null, null, null];\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 60,
        "wires": [
            [
                "b7b87a40dd91a021",
                "4374c2d006a762aa"
            ],
            [
                "22442867c06e05b8",
                "6dcda7c82fb9d78e"
            ],
            [
                "c3f4a0e8f8030852",
                "67f93eb4cc3f69b4"
            ]
        ]
    },
    {
        "id": "54a9a79a7c485b62",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "analog_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst analogChannels = flowData.config.io.analog_inputs.channels;\nconst runtime = flowData.runtime;\n\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || typeof val !== \"number\") return null;\n\nconst channelDef = analogChannels[key];\nif (!channelDef || !channelDef.pro) return null;\n\nconst changed = [];\n\nfor (const [detectorKey, thresholds] of Object.entries(channelDef.pro)) {\n    if (!thresholds || typeof thresholds.on !== \"number\" || typeof thresholds.off !== \"number\") continue;\n\n    const prevVal = runtime[detectorKey]?.val ?? \"off\";\n    let newVal = null;\n\n    // Kural 1: runtime off + val >= on → on\n    if (prevVal === \"off\" && val >= thresholds.on) {\n        newVal = \"on\";\n    }\n    // Kural 2: runtime on + val <= off → off\n    else if (prevVal === \"on\" && val <= thresholds.off) {\n        newVal = \"off\";\n    }\n\n    if (newVal && newVal !== prevVal) {\n        runtime[detectorKey] = { val: newVal };\n        flow.set(\"flow\", flowData);\n\n        changed.push({\n            payload: {\n                method: \"evt\",\n                params: { type: detectorKey, val: newVal }\n            }\n        });\n    }\n}\n\nreturn changed.length ? [changed] : null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 280,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c",
                "e6b1b4baeb9ea6aa"
            ]
        ]
    },
    {
        "id": "8b647d54a390a264",
        "type": "function",
        "z": "2d8538969c77a5df",
        "d": true,
        "name": "energy_meter_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst energyChannels = flowData.config.energy_meter.channels;\nconst runtime = flowData.runtime;\n\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || typeof val !== \"number\") return null;\n\nconst channelDef = energyChannels[key];\nif (!channelDef || !channelDef.pro) return null;\n\nconst changed = [];\n\nfor (const [detectorKey, thresholds] of Object.entries(channelDef.pro)) {\n    if (!thresholds || typeof thresholds.on !== \"number\" || typeof thresholds.off !== \"number\") continue;\n\n    const prevVal = runtime[detectorKey]?.val ?? \"off\";\n    let newVal = null;\n\n    // Kural 1: runtime off + val >= on → on\n    if (prevVal === \"off\" && val >= thresholds.on) {\n        newVal = \"on\";\n    }\n    // Kural 2: runtime on + val <= off → off\n    else if (prevVal === \"on\" && val <= thresholds.off) {\n        newVal = \"off\";\n    }\n\n    if (newVal && newVal !== prevVal) {\n        runtime[detectorKey] = { val: newVal };\n        flow.set(\"flow\", flowData);\n\n        changed.push({\n            payload: {\n                method: \"evt\",\n                params: { type: detectorKey, val: newVal }\n            }\n        });\n    }\n}\n\nreturn changed.length ? [changed] : null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 360,
        "wires": [
            [
                "22442867c06e05b8",
                "0b3654ab51cfd27c"
            ]
        ]
    },
    {
        "id": "2b810660372548f4",
        "type": "function",
        "z": "2d8538969c77a5df",
        "name": "digital_pro",
        "func": "const flowData = flow.get(\"flow\");\nconst digitalChannels = flowData.config.io.digital_inputs.channels;\nconst runtime = flowData.runtime;\n\nconst m = msg.payload;\nif (typeof m !== \"object\") return null;\n\nconst key = m.params?.type;\nconst val = m.params?.val;\nif (typeof key !== \"string\" || (val !== \"on\" && val !== \"off\")) return null;\n\nconst channelDef = digitalChannels[key];\nif (!channelDef || !channelDef.pro) return null;\n\n// Ortak alarm anahtarı\nconst [commonKey] = Object.keys(channelDef.pro);\nconst expectedVal = channelDef.pro[commonKey];\nif (!commonKey) return null;\n\n// Sadece iki kural\nlet newVal = null;\nif (val === \"on\" && expectedVal === \"off\" && runtime[commonKey].val === \"on\") {\n    newVal = \"off\";\n} else if (val === \"off\" && expectedVal === \"on\" && runtime[commonKey].val === \"off\") {\n    newVal = \"on\";\n}\n\nif (!newVal) return null;\n\nruntime[commonKey].val = newVal;\nflow.set(\"flow\", flowData);\n\nreturn [[{\n    payload: {\n        method: \"evt\",\n        params: { type: commonKey, val: newVal }\n    }\n}]];\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 200,
        "wires": [
            [
                "22442867c06e05b8",
                "0361884ba2bf6086"
            ]
        ]
    },
    {
        "id": "890e808611421ece",
        "type": "modbus-flex-getter",
        "z": "2d8538969c77a5df",
        "name": "get_analog_inputs",
        "showStatusActivities": false,
        "showErrors": false,
        "showWarnings": true,
        "logIOActivities": false,
        "server": "e707d8a8f03b29cf",
        "useIOFile": false,
        "ioFile": "",
        "useIOForPayload": false,
        "emptyMsgOnFail": false,
        "keepMsgProperties": false,
        "delayOnStart": false,
        "startDelayTime": "",
        "x": 370,
        "y": 220,
        "wires": [
            [
                "db72d07653f1bbe9"
            ],
            []
        ]
    },
    {
        "id": "341579e5df71af16",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "power_on",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "{\"method\": \"cmd\", \"params\": {\"type\": \"on\", \"target\": \"power\"}}",
        "payloadType": "json",
        "x": 1240,
        "y": 300,
        "wires": [
            [
                "22442867c06e05b8"
            ]
        ]
    },
    {
        "id": "7701af895b46dbeb",
        "type": "inject",
        "z": "2d8538969c77a5df",
        "name": "telemetry_periodical",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "60",
        "topic": "",
        "payload": "{\"method\": \"cmd\", \"params\": {\"type\": \"on\", \"target\": \"telemetry_periodical\"}}",
        "payloadType": "json",
        "x": 620,
        "y": 480,
        "wires": [
            [
                "8701a07643f54a7b"
            ]
        ]
    },
    {
        "id": "1c798b44f6d4353a",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "actuators_1",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 660,
        "wires": []
    },
    {
        "id": "7ccdddabf54a9ffe",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "actuators_2",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 700,
        "wires": []
    },
    {
        "id": "86a9ac90f6c99b53",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "actuators_3",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 740,
        "wires": []
    },
    {
        "id": "1fdf1ec66afd9b22",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "digital_inputs_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 660,
        "wires": []
    },
    {
        "id": "0361884ba2bf6086",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "digital_pro_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 540,
        "y": 700,
        "wires": []
    },
    {
        "id": "89af02b1bc8fde6a",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "analog_inputs_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 740,
        "wires": []
    },
    {
        "id": "e6b1b4baeb9ea6aa",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "analog_pro_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 540,
        "y": 780,
        "wires": []
    },
    {
        "id": "f1a672c83645300a",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_in_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 310,
        "y": 660,
        "wires": []
    },
    {
        "id": "beb4346081038e85",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "flow_context_x",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 110,
        "y": 660,
        "wires": []
    },
    {
        "id": "4374c2d006a762aa",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager_1",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 330,
        "y": 700,
        "wires": []
    },
    {
        "id": "6dcda7c82fb9d78e",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager_2",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 330,
        "y": 740,
        "wires": []
    },
    {
        "id": "67f93eb4cc3f69b4",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "mqtt_manager_3",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 330,
        "y": 780,
        "wires": []
    },
    {
        "id": "c191c7397b21bd4f",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "fsm_1",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 660,
        "wires": []
    },
    {
        "id": "664d95256e2c36ad",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "timer_manager_1",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 660,
        "wires": []
    },
    {
        "id": "eabb49f6ea664cdf",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "timer_manager_2",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 700,
        "wires": []
    },
    {
        "id": "9185b5217ebdc209",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "timer_manager_3",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 740,
        "wires": []
    },
    {
        "id": "abbeb7f879dce340",
        "type": "debug",
        "z": "2d8538969c77a5df",
        "name": "fsm_2",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 700,
        "wires": []
    }
]